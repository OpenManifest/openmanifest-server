{"version":3,"sources":["DataTableCell.tsx","DataTableHeader.tsx","DataTableTitle.tsx","DataTablePagination.tsx","DataTableRow.tsx","DataTable.tsx","node_modules/react-native-gesture-handler/State.js","node_modules/@babel/runtime/helpers/get.js","node_modules/react-native-gesture-handler/createHandler.js","../../../../.config/yarn/global/node_modules/timers-browserify/main.js","node_modules/react-native-gesture-handler/GestureHandlerPropTypes.js","node_modules/react-native-gesture-handler/NativeViewGestureHandler.js","node_modules/react-native-gesture-handler/createNativeWrapper.js","node_modules/react-native-gesture-handler/Directions.js","node_modules/react-native-gesture-handler/GestureHandlerRootView.js","node_modules/react-native-gesture-handler/gestureHandlerRootHOC.js","node_modules/react-native-gesture-handler/GestureButtons.js","node_modules/react-native-gesture-handler/GestureHandlerButton.web.js","node_modules/react-native-gesture-handler/GestureComponents.web.js","node_modules/react-native-gesture-handler/PlatformConstants.web.js","node_modules/react-native-gesture-handler/Gestures.js","node_modules/react-native-gesture-handler/Swipeable.js","node_modules/react-native-gesture-handler/DrawerLayout.js","node_modules/react-native-gesture-handler/touchables/TouchableNativeFeedback.js","node_modules/react-native-gesture-handler/touchables/GenericTouchable.js","node_modules/react-native-gesture-handler/touchables/TouchableWithoutFeedback.js","node_modules/react-native-gesture-handler/touchables/TouchableOpacity.js","node_modules/react-native-gesture-handler/touchables/TouchableHighlight.js","node_modules/@egjs/hammerjs/dist/hammer.esm.js","node_modules/react-native-gesture-handler/web/constants.js","node_modules/react-native-gesture-handler/web/Errors.js","node_modules/react-native-gesture-handler/web/NodeManager.js","node_modules/react-native-gesture-handler/web/GestureHandler.js","node_modules/react-native-gesture-handler/web/DraggingGestureHandler.js","node_modules/react-native-gesture-handler/web/utils.js","node_modules/react-native-gesture-handler/web/FlingGestureHandler.js","node_modules/react-native-gesture-handler/web/DiscreteGestureHandler.js","node_modules/react-native-gesture-handler/web/PressGestureHandler.js","node_modules/react-native-gesture-handler/web/LongPressGestureHandler.js","node_modules/react-native-gesture-handler/web/NativeViewGestureHandler.js","node_modules/react-native-gesture-handler/web/PanGestureHandler.js","node_modules/react-native-gesture-handler/web/IndiscreteGestureHandler.js","node_modules/react-native-gesture-handler/web/PinchGestureHandler.js","node_modules/react-native-gesture-handler/RNGestureHandlerModule.web.js","node_modules/react-native-gesture-handler/web/RotationGestureHandler.js","node_modules/react-native-gesture-handler/web/TapGestureHandler.js","../../../../.config/yarn/global/node_modules/setimmediate/setImmediate.js","node_modules/fbjs/lib/areEqual.js","node_modules/@babel/runtime/helpers/superPropBase.js"],"names":["DataTableCell","rest","style","styles","numeric","numberOfLines","StyleSheet","container","flex","flexDirection","alignItems","right","justifyContent","DataTableHeader","borderBottomColor","color","theme","header","height","paddingHorizontal","borderBottomWidth","withTheme","DataTableTitle","spinAnim","React","Animated","sortDirection","current","toValue","duration","useNativeDriver","textColor","spin","inputRange","outputRange","icon","transform","rotate","name","size","direction","I18nManager","disabled","onPress","alignContent","paddingVertical","cell","lineHeight","fontSize","fontWeight","sorted","marginLeft","DataTablePagination","labelColor","page","onPageChange","numberOfPages","paddingLeft","label","marginRight","borderStyle","minHeight","content","pointerEvents","DataTable","width","State","UNDETERMINED","FAILED","BEGAN","CANCELLED","ACTIVE","END","state","keys","Object","i","length","superPropBase","_get","target","property","receiver","Reflect","get","module","exports","__esModule","base","desc","getOwnPropertyDescriptor","call","value","findNodeHandle","node","Platform","OS","findNodeHandleRN","NativeModules","UIManager","customGHEventsConfig","onGestureHandlerEvent","registrationName","onGestureHandlerStateChange","genericDirectEventTypes","getConstants","setJSResponder","oldSetJSResponder","clearJSResponder","oldClearJSResponder","tag","blockNativeResponder","RNGestureHandlerModule","handleSetJSResponder","handleClearJSResponder","handlerTag","handlerIDToTag","isConfigParam","param","undefined","filterConfig","props","validProps","defaults","res","forEach","key","transformIntoHandlerTags","top","left","bottom","handlerIDs","Array","isArray","map","filter","handle","handlerID","_handlerTag","hasUnresolvedRefs","extract","refs","some","r","stateToPropMappings","createHandler","handlerName","propTypes","config","transformProps","customNativeProps","Handler","_onGestureHandlerEvent","event","nativeEvent","onGestureEvent","_onGestureHandlerStateChange","onHandlerStateChange","stateEventName","_refHandler","_viewNode","ref","Children","only","children","_createGestureHandler","newConfig","_config","createGestureHandler","_attachGestureHandler","newViewTag","_viewTag","attachGestureHandler","_updateGestureHandler","updateGestureHandler","id","Error","dropGestureHandler","this","_updateEnqueued","clearImmediate","setImmediate","_update","constructor","viewTag","deepEqual","updates","mergedProps","gestureEventHandler","gestureStateEventHandler","child","grandChildren","Touchable","TOUCH_TARGET_DEBUG","type","displayName","toArray","push","renderDebugView","hitSlop","cloneElement","collapsable","Component","self","window","apply","Function","prototype","Timeout","clearFn","_id","_clearFn","setTimeout","scope","arguments","clearTimeout","setInterval","clearInterval","timeout","close","unref","enroll","item","msecs","_idleTimeoutId","_idleTimeout","unenroll","_unrefActive","active","_onTimeout","global","GestureHandlerPropTypes","PropTypes","string","minPointers","number","enabled","bool","waitFor","oneOfType","object","arrayOf","simultaneousHandlers","shouldCancelWhenOutside","shape","vertical","horizontal","func","onBegan","onFailed","onCancelled","onActivated","onEnded","NativeViewGestureHandler","shouldActivateOnStart","disallowInterruption","NATIVE_WRAPPER_PROPS_FILTER","createNativeWrapper","ComponentWrapper","forwardRef","gestureHandlerProps","reduce","indexOf","View","create","RawButton","accessibilityRole","BaseButton","_handleEvent","oldState","pointerInside","_lastActive","onActiveStateChange","_onHandlerStateChange","e","_onGestureEvent","rippleColor","processColor","AnimatedBaseButton","createAnimatedComponent","btnStyles","underlay","position","RectButton","_onActiveStateChange","_opacity","setValue","activeOpacity","Value","resolvedStyle","flatten","opacity","backgroundColor","underlayColor","borderRadius","borderTopLeftRadius","borderTopRightRadius","borderBottomLeftRadius","borderBottomRightRadius","defaultProps","BorderlessButton","borderless","ScrollView","RNScrollView","RNSwitch","RNTextInput","RNDrawerLayoutAndroid","positions","FlatList","renderScrollComponent","scrollProps","TapGestureHandler","maxDurationMs","maxDelayMs","numberOfTaps","maxDeltaX","maxDeltaY","maxDist","ForceTouchFallback","numberOfPointers","console","warn","PlatformConstants","forceTouchAvailable","minForce","maxForce","feedbackOnActivation","minDurationMs","PanGestureHandler","activeOffsetY","activeOffsetX","failOffsetY","failOffsetX","minDist","minVelocity","minVelocityX","minVelocityY","maxPointers","avgTouches","minDeltaX","activeOffsetXStart","activeOffsetXEnd","failOffsetXStart","failOffsetXEnd","minOffsetX","minDeltaY","activeOffsetYStart","activeOffsetYEnd","failOffsetYStart","failOffsetYEnd","minOffsetY","transformPanGestureHandlerProps","_updateAnimatedEvent","friction","overshootFriction","dragX","useNativeAnimations","rowTranslation","leftWidth","rowWidth","rightOffset","rightWidth","Math","max","overshootLeft","overshootRight","transX","add","interpolate","_transX","_showLeftAction","_leftActionTranslate","Number","MIN_VALUE","extrapolate","_showRightAction","_rightActionTranslate","_onTapHandlerStateChange","_handleRelease","velocityX","translationX","rowState","leftThreshold","rightThreshold","startOffsetX","_currentOffset","_animateRow","fromValue","setState","sign","spring","restSpeedThreshold","restDisplacementThreshold","velocity","bounciness","animationOptions","start","finished","onSwipeableLeftOpen","onSwipeableRightOpen","onSwipeableClose","onSwipeableOpen","onSwipeableLeftWillOpen","onSwipeableRightWillOpen","onSwipeableWillClose","onSwipeableWillOpen","_onRowLayout","layout","openLeft","openRight","renderLeftActions","renderRightActions","leftActions","translateX","onLayout","x","rightActions","containerStyle","childrenContainerStyle","overflow","absoluteFillObject","isRTL","DrawerLayout","context","_accessibilityIsModalView","createRef","_pointerEventsView","_panGestureHandler","_drawerShown","drawerPosition","drawerWidth","drawerType","dragXValue","touchXValue","touchX","drawerTranslation","containerWidth","multiply","dragOffsetFromOnStartPosition","_openValue","_handleContainerLayout","_emitStateChanged","newState","drawerWillShow","onDrawerStateChanged","_openingHandlerStateChange","keyboardDismissMode","Keyboard","dismiss","hideStatusBar","StatusBar","setHidden","statusBarAnimation","drawerLockMode","closeDrawer","gestureStartX","dragOffsetBasedOnStart","_animateDrawer","_updateShowing","showing","setNativeProps","accessibilityViewIsModal","minSwipeDistance","edgeWidth","fromLeft","gestureOrientation","nextFramePosition","min","willShow","onDrawerOpen","onDrawerClose","openDrawer","options","forceUpdate","_renderOverlay","invariant","dynamicOverlayStyles","overlayColor","overlay","_renderDrawer","containerStyles","drawerBackgroundColor","drawerContainerStyle","contentContainerStyle","drawerSlide","containerSlide","reverseContentDirection","dynamicDrawerStyles","openValue","drawerTranslateX","closedDrawerOffset","drawerStyles","main","containerOnBack","containerInFront","importantForAccessibility","drawerContainer","renderNavigationView","_setPanGestureRef","onGestureRef","Left","Right","zIndex","TOUCHABLE_STATE","PublicPropTypes","accessible","accessibilityLabel","accessibilityHint","onPressIn","onPressOut","onLongPress","nativeID","testID","delayPressIn","delayPressOut","delayLongPress","InternalPropTypes","extraButtonProps","onStateChange","GenericTouchable","longPressDetected","STATE","onMoveIn","onMoveOut","moveToState","handlePressIn","shouldCallOnPress","pressOutTimeout","handleGoToUndetermined","onLongPressDetected","pressInTimeout","time","longPressTimeout","reset","handleMoveOutside","coreProps","accessibilityComponentType","accessibilityStates","accessibilityTraits","publicPropTypes","internalPropTypes","TouchableWithoutFeedback","TouchableOpacity","getChildStyleOpacityWithDefault","childStyle","setOpacityTo","timing","easing","Easing","inOut","quad","from","to","any","TouchableHighlight","showUnderlay","hasPressHandler","extraChildStyle","extraUnderlayStyle","onShowUnderlay","hideUnderlay","onHideUnderlay","compose","renderChildren","_extends","assign","source","hasOwnProperty","_inheritsLoose","subClass","superClass","__proto__","_assertThisInitialized","ReferenceError","win","assign$1","TypeError","output","index","nextKey","VENDOR_PREFIXES","TEST_ELEMENT","document","createElement","round","abs","now","Date","prefixed","obj","prefix","prop","camelProp","toUpperCase","slice","PREFIXED_TOUCH_ACTION","NATIVE_TOUCH_ACTION","TOUCH_ACTION_MAP","touchMap","cssSupports","CSS","supports","val","getTouchActionProps","SUPPORT_TOUCH","SUPPORT_POINTER_EVENTS","SUPPORT_ONLY_TOUCH","test","navigator","userAgent","PROPS_XY","PROPS_CLIENT_XY","each","iterator","boolOrFn","args","inStr","str","find","TouchAction","manager","set","_proto","compute","element","actions","toLowerCase","trim","update","touchAction","recognizers","recognizer","enable","concat","getTouchAction","hasPanX","hasPanY","cleanTouchActions","join","preventDefaults","input","srcEvent","offsetDirection","session","prevented","preventDefault","hasNone","isTapPointer","pointers","isTapMovement","distance","isTapTouchTime","deltaTime","DIRECTION_LEFT","DIRECTION_UP","preventSrc","hasParent","parent","parentNode","getCenter","pointersLength","clientX","y","clientY","simpleCloneInputData","timeStamp","center","deltaX","deltaY","getDistance","p1","p2","sqrt","getAngle","atan2","PI","getVelocity","computeInputData","firstInput","firstMultiple","offsetCenter","angle","offset","offsetDelta","prevDelta","prevInput","eventType","computeDeltaXY","end","overallVelocity","overallVelocityX","overallVelocityY","scale","rotation","getRotation","velocityY","last","lastInterval","v","computeIntervalInputData","srcEventTarget","composedPath","path","inputHandler","pointersLen","changedPointersLen","changedPointers","isFirst","isFinal","emit","recognize","splitStr","split","addEventListeners","types","handler","addEventListener","removeEventListeners","removeEventListener","getWindowForElement","doc","ownerDocument","defaultView","parentWindow","Input","callback","inputTarget","domHandler","ev","init","evEl","evTarget","evWin","destroy","inArray","src","findByKey","POINTER_INPUT_MAP","pointerdown","pointermove","pointerup","pointercancel","pointerout","IE10_POINTER_TYPE_ENUM","2","3","4","5","POINTER_ELEMENT_EVENTS","POINTER_WINDOW_EVENTS","MSPointerEvent","PointerEvent","PointerEventInput","_Input","_this","proto","store","removePointer","eventTypeNormalized","replace","pointerType","isTouch","storeIndex","pointerId","button","splice","uniqueArray","sort","results","values","a","b","TOUCH_INPUT_MAP","touchstart","touchmove","touchend","touchcancel","TouchInput","targetIds","touches","getTouches","targetTouches","allTouches","identifier","changedTouches","changedTargetTouches","touch","MOUSE_INPUT_MAP","mousedown","mousemove","mouseup","MouseInput","pressed","which","setLastTouch","eventData","primaryTouch","lastTouch","lts","lastTouches","recordTouches","isSyntheticEvent","t","dx","dy","TouchMouseInput","_manager","inputEvent","inputData","isMouse","sourceCapabilities","firesTouchEvents","mouse","invokeArrayArg","arg","fn","_uniqueId","getRecognizerByNameIfManager","otherRecognizer","stateStr","Recognizer","simultaneous","requireFail","recognizeWith","dropRecognizeWith","requireFailure","dropRequireFailure","hasRequireFailures","canRecognizeWith","additionalEvent","tryEmit","canEmit","inputDataClone","process","TapRecognizer","_Recognizer","taps","interval","threshold","posThreshold","pTime","pCenter","_timer","_input","count","_this2","validPointers","validMovement","validTouchTime","failTimeout","validInterval","validMultiTap","_this3","tapCount","AttrRecognizer","attrTest","optionPointers","isRecognized","isValid","directionStr","PanRecognizer","_AttrRecognizer","DIRECTION_HORIZONTAL","pX","pY","directionTest","hasMoved","SwipeRecognizer","PinchRecognizer","RotateRecognizer","PressRecognizer","validTime","domEvents","inputClass","cssProps","userSelect","touchSelect","touchCallout","contentZooming","userDrag","tapHighlightColor","preset","toggleCssProps","oldCssProps","Manager","handlers","createInputInstance","stop","force","stopped","curRecognizer","existing","remove","targetRecognizer","on","events","off","data","gestureEvent","createEvent","initEvent","gesture","dispatchEvent","triggerDomEvent","SINGLE_TOUCH_INPUT_MAP","SingleTouchInput","started","normalizeSingleTouches","all","changed","deprecate","method","message","deprecationMessage","stack","log","extend","dest","merge","inherit","properties","childP","baseP","_super","bindFn","Hammer","VERSION","DIRECTION_ALL","DIRECTION_DOWN","DIRECTION_RIGHT","DIRECTION_VERTICAL","DIRECTION_NONE","INPUT_START","INPUT_MOVE","INPUT_END","INPUT_CANCEL","STATE_POSSIBLE","STATE_BEGAN","STATE_CHANGED","STATE_ENDED","STATE_RECOGNIZED","STATE_CANCELLED","STATE_FAILED","Tap","Pan","Swipe","Pinch","Rotate","Press","DEG_RAD","EventMap","Direction","RIGHT","LEFT","UP","DOWN","GesturePropError","expectedType","gestures","getHandler","getNodes","_gestureInstances","invokeNullableMethod","__getHandler","argMapping","__nodeConfig","nativeValue","GestureHandler","isGestureRunning","hasGestureFailed","view","hammer","pendingGestures","previousState","lastSentState","clearSelfAsPending","removePendingGesture","isPointInView","rect","getBoundingClientRect","sendEvent","transformEventData","sync","params","getHammerConfig","shouldEnableGestureOnSetup","isDiscrete","_stillWaiting","_getPendingGestures","_hasCustomActivationCriteria","deltaRotation","initialRotation","isGestureEnabledForEvent","getConfig","success","failed","simulateCancelEvent","_gestureInstance","minDistSq","minVelocitySq","maxDistSq","NodeManager","NaN","ensureConfig","updateHasCustomActivationCriteria","addPendingGesture","changedTouch","getState","transformNativeEvent","cancelEvent","onWaitingEnded","cancelPendingGestures","notifyPendingGestures","onGestureEnded","NativeGestureClass","onRawEvent","setupEvents","onStart","onGestureActivated","__initialX","__initialY","DraggingGestureHandler","ratio","PixelRatio","translationY","absoluteX","absoluteY","isnan","isNaN","isValidNumber","TEST_MIN_IF_NOT_NAN","limit","VEC_LEN_SQ","TEST_MAX_IF_NOT_NAN","fireAfterInterval","FlingGestureHandler","getDirection","directions","Set","pointerLength","validPointerCount","DiscreteGestureHandler","shouldFailUnderCustomCriteria","PressGestureHandler","shouldDelayTouches","onGestureStart","visualFeedbackTimer","initialEvent","sendGestureStartedEvent","shouldDelayTouchForEvent","LongPressGestureHandler","contains","forceInvalidate","nextState","horizontalDirections","verticalDirections","criteria","deltaScale","absDeltaRotation","shouldActivateUnderCustomCriteria","shouldMultiFingerPanFail","IndiscreteGestureHandler","PinchGestureHandler","focalX","focalY","Gestures","RotationGestureHandler","anchorX","anchorY","onSuccessfulTap","_shouldFireEndEvent","_multiTapTimer","GestureClass","newView","setView","updateGestureConfig","getGestureHandlerNode","registerImmediate","nextHandle","tasksByHandle","currentlyRunningATask","attachTo","getPrototypeOf","toString","nextTick","runIfPresent","postMessage","importScripts","postMessageIsAsynchronous","oldOnMessage","onmessage","canUsePostMessage","messagePrefix","random","onGlobalMessage","attachEvent","installPostMessageImplementation","MessageChannel","channel","port1","port2","installMessageChannelImplementation","html","documentElement","script","onreadystatechange","removeChild","appendChild","installReadyStateChangeImplementation","task","run","aStackPool","bStackPool","aStack","pop","bStack","result","eq","objToStr","className","String","multiline","ignoreCase","valueOf"],"mappings":";8VAqDA,IAAMA,EAAgB,SAAC,GAAD,IAAC,EAAD,EAAC,WAAD,EAAC,QAAD,EAAC,QAA+BC,EAAhC,6CACpB,4BAEEC,MAAO,CAACC,EAAD,UAAmBC,GAAWD,EAA9B,WAEP,qBAAME,cAAe,GALzB,KASAL,+BAEA,IAAMG,EAASG,EAAA,SAAkB,CAC/BC,UAAW,CACTC,KADS,EAETC,cAFS,MAGTC,WAAY,UAGdC,MAAO,CACLC,eAAgB,cAIpB,I,gPCzBA,IAAMC,EAAkB,SAAC,GAAgD,IAAhD,EAA+C,EAA/C,WAA+C,EAA/C,QAA+C,EAA/C,MAA6BZ,EAAkB,oCAChEa,EAAoBC,IAAMC,WAAND,sBAA1B,SAKA,OACE,4BAAgBb,MAAO,CAACC,EAAD,OAAgB,CAAEW,qBAAlB,KADzB,IAOFD,iCAEA,IAAMV,EAASG,EAAA,SAAkB,CAC/BW,OAAQ,CACNR,cADM,MAENS,OAFM,GAGNC,kBAHM,GAINC,kBAA8C,EAA3Bd,qBAIRe,cAAf,G,8OCCA,IAAMC,EAAiB,SAAC,GASV,IATU,EASX,EATW,UASX,EATW,WASX,EATW,UASX,EATW,gBASX,EATW,QASX,EATW,MASX,IAFXjB,qBAEW,MATW,EASX,EADRJ,EACQ,wFACMsB,EAAaC,SAC5B,IAAIC,IAAJ,MAAmBC,kBADrB,IAAQC,QAIRH,aAAgB,WACdC,aAA0B,CACxBG,QAASF,kBADe,EAExBG,SAFwB,IAGxBC,iBAAiB,IAHnBL,UAKC,CAACC,EANJF,IAQA,IAAMO,EAAYhB,IAAMC,SAAND,sBAAlB,SAEMiB,EAAOT,EAAA,YAAqB,CAChCU,WAAY,CAAC,EADmB,GAEhCC,YAAa,CAAC,OAAO,YAGjBC,EAAOT,EACX,gBAACD,EAAA,EAAD,MAAevB,MAAO,CAACC,EAAD,KAAc,CAAEiC,UAAW,CAAC,CAAEC,OAAQL,OAC1D,qBACEM,KADF,WAEEC,KAFF,GAGExB,MAAOC,SAHT,KAIEwB,UAAWC,gBAA4B,SAN7C,KAWA,OACE,uBAA0BC,UAA1B,EAA8CC,QAASA,GAAvD,GACE,qBAAMzC,MAAO,CAACC,EAAD,UAAmBC,GAAWD,EAA9B,UAAb,EAGE,qBACED,MAAO,CACLC,EADK,KAELuB,EAAgBvB,EAAH,OAAmB,CAAEY,MAAOgB,IAE3C1B,cAAeA,GAVvB,MAmBFiB,gCAEA,IAAMnB,EAASG,EAAA,SAAkB,CAC/BC,UAAW,CACTC,KADS,EAETC,cAFS,MAGTmC,aAHS,SAITC,gBAAiB,IAGnBlC,MAAO,CACLC,eAAgB,YAGlBkC,KAAM,CACJ5B,OADI,GAEJ6B,WAFI,GAGJC,SAHI,GAIJC,WAJI,MAKJvC,WAAY,UAGdwC,OAAQ,CACNC,WAAY,GAGdhB,KAAM,CACJjB,OADI,GAEJN,eAAgB,YAILS,cAAf,G,wNC5EA,IAAM+B,EAAsB,SAAC,GAQf,IARe,EAQhB,EARgB,QAQhB,EARgB,OAQhB,EARgB,gBAQhB,EARgB,eAQhB,EARgB,QAQhB,EARgB,MAOxBnD,EACQ,uEACLoD,EAAatC,IAAMC,SAAND,sBAAnB,SAEA,OACE,4BAAgBb,MAAO,CAACC,EAAD,eACrB,qBAAMD,MAAO,CAACC,EAAD,MAAe,CAAEY,MAAOsC,IAAehD,cAAe,GADrE,GAIE,qBACE8B,KAAM,gBAAC,EAAD,EAAC,KAAQpB,EAAT,EAASA,MAAT,OACJ,qBACEuB,KADF,eAEEvB,MAFF,EAGEwB,KAHF,EAIEC,UAAWC,gBAA4B,SAG3C1B,MAAOC,SATT,KAUE0B,SAVF,IAUYY,EACVX,QAAS,kBAAMY,EAAaD,EAAD,MAE7B,qBACEnB,KAAM,gBAAC,EAAD,EAAC,KAAQpB,EAAT,EAASA,MAAT,OACJ,qBACEuB,KADF,gBAEEvB,MAFF,EAGEwB,KAHF,EAIEC,UAAWC,gBAA4B,SAG3C1B,MAAOC,SATT,KAUE0B,SAAUc,OAAuBF,IAASE,EAV5C,EAWEb,QAAS,kBAAMY,EAAaD,EAAD,QAMnCF,qCAEA,IAAMjD,EAASG,EAAA,SAAkB,CAC/BC,UAAW,CACTK,eADS,WAETH,cAFS,MAGTC,WAHS,SAIT+C,YAAa,IAGfC,MAAO,CACLV,SADK,GAELW,YAAa,MAIFtC,cAAf,G,+MC3FA,IA0BMlB,EAASG,EAAA,SAAkB,CAC/BC,UAAW,CACTqD,YADS,QAETxC,kBAAmBd,IAFV,cAGTuD,UAHS,GAIT1C,kBAAmB,IAErB2C,QAAS,CACPtD,KADO,EAEPC,cAAe,SAIJY,eAvCM,SAAC,GAOR,IAPQ,EAOT,EAPS,UAOT,EAPS,QAOT,EAPS,QAOT,EAPS,WAOT,EAPS,cAMjBpB,EACQ,8DACLa,EAAoBC,IAAMC,WAAND,sBAA1B,SAKA,OACE,4BAEE4B,QAFF,EAGEzC,MAAO,CAACC,EAAD,UAAmB,CAAEW,qBAArB,KAEP,qBAAMZ,MAAOC,EAAb,QAA6B4D,cAAeA,GANhD,O,+MCAF,IAAMC,EAAY,SAAC,GAAD,IAAC,EAAD,EAAC,WAAD,EAAC,MAAsB/D,EAAvB,mCAChB,4BAAgBC,MAAO,CAACC,EAAD,eADzB,IAOA6D,WAGAA,UAGAA,QAGAA,SAGAA,eAEA,IAAM7D,EAASG,EAAA,SAAkB,CAC/BC,UAAW,CACT0D,MAAO,UAIX,O,iCCtGA,IAAMC,EAAQ,CACZC,aAAc,EACdC,OAAQ,EACRC,MAAO,EACPC,UAAW,EACXC,OAAQ,EACRC,IAAK,EAGPN,MAAc,SAAAO,GAEZ,IADA,IAAMC,EAAOC,OAAOD,KAAKR,GAChBU,EAAI,EAAGA,EAAIF,EAAKG,OAAQD,IAC/B,GAAIH,IAAUP,EAAMQ,EAAKE,IACvB,OAAOF,EAAKE,KAKHV,O,oBClBf,IAAIY,EAAgB,EAAQ,KAE5B,SAASC,EAAKC,EAAQC,EAAUC,GAoB9B,MAnBuB,qBAAZC,SAA2BA,QAAQC,KAC5CC,EAAOC,QAAUP,EAAOI,QAAQC,IAChCC,EAAOC,QAAiB,QAAID,EAAOC,QAASD,EAAOC,QAAQC,YAAa,IAExEF,EAAOC,QAAUP,EAAO,SAAcC,EAAQC,EAAUC,GACtD,IAAIM,EAAOV,EAAcE,EAAQC,GACjC,GAAKO,EAAL,CACA,IAAIC,EAAOd,OAAOe,yBAAyBF,EAAMP,GAEjD,OAAIQ,EAAKL,IACAK,EAAKL,IAAIO,KAAKT,GAGhBO,EAAKG,QAGdP,EAAOC,QAAiB,QAAID,EAAOC,QAASD,EAAOC,QAAQC,YAAa,GAGnER,EAAKC,EAAQC,EAAUC,GAAYF,GAG5CK,EAAOC,QAAUP,EACjBM,EAAOC,QAAiB,QAAID,EAAOC,QAASD,EAAOC,QAAQC,YAAa,G,wvCCfxE,SAASM,EAAeC,GACtB,MAAoB,QAAhBC,IAASC,GAAqBF,EAC3BG,YAAiBH,G,MAGCI,IAAnBC,iB,MAAY,G,EAEdC,EAAuB,CAC3BC,sBAAuB,CAAEC,iBAAkB,yBAC3CC,4BAA6B,CAC3BD,iBAAkB,gCAQtBH,EAAUK,wBAAV,OACKL,EAAUK,yBACVJ,GAKDD,EAAUM,eACZN,EAAUM,eAAeD,wBAAzB,OACKL,EAAUM,eAAeD,yBACzBJ,I,MAQHD,EAFFO,eAAgBC,O,MAAoB,a,IAElCR,EADFS,iBAAkBC,O,MAAsB,a,EAE1CV,EAAUO,eAAiB,SAACI,EAAKC,GAC/BC,IAAuBC,qBAAqBH,EAAKC,GACjDJ,EAAkBG,EAAKC,IAEzBZ,EAAUS,iBAAmB,WAC3BI,IAAuBE,yBACvBL,KAGF,IAAIM,EAAa,EACXC,EAAiB,GAEvB,SAASC,EAAcC,EAAOhF,GAG5B,YACYiF,IAAVD,IACCA,IAAU3C,OAAO2C,MAAY,eAAgBA,KACrC,yBAAThF,GACS,mBAATA,EAIJ,SAASkF,EAAaC,EAAOC,GAA4B,IAAhBC,EAAe,uDAAJ,GAC5CC,EAAG,KAAQD,GAejB,OAdAhD,OAAOD,KAAKgD,GAAYG,SAAQ,SAAAC,GAE9B,GAAIT,EADUI,EAAMK,GACKA,GAAM,CAC7B,IAAIlC,EAAQ6B,EAAMK,GACN,yBAARA,GAA0C,YAARA,EACpClC,EAAQmC,EAAyBN,EAAMK,IACtB,YAARA,GACY,kBAAVlC,IACTA,EAAQ,CAAEoC,IAAKpC,EAAOqC,KAAMrC,EAAOsC,OAAQtC,EAAOjF,MAAOiF,IAG7DgC,EAAIE,GAAOlC,MAGRgC,EAGT,SAASG,EAAyBI,GAKhC,OAJKC,MAAMC,QAAQF,KACjBA,EAAa,CAACA,IAGI,QAAhBpC,IAASC,GACJmC,EAAWG,KAAI,qBAAG3G,WAAuB4G,QAAO,SAAAC,GAAM,OAAIA,KAG5DL,EACJG,KACC,SAAAG,GAAS,OACPrB,EAAeqB,IACdA,EAAU9G,SAAW8G,EAAU9G,QAAQ+G,cACvC,KAEJH,QAAO,SAAApB,GAAU,OAAIA,EAAa,KAGvC,SAASwB,EAAkBlB,GACzB,IAAMmB,EAAU,SAAAC,GACd,OAAKT,MAAMC,QAAQQ,GAGZA,EAAKC,MAAK,SAAAC,GAAC,OAAIA,GAAmB,OAAdA,EAAEpH,WAFpBkH,GAAyB,OAAjBA,EAAKlH,SAIxB,OAAOiH,EAAQnB,EAAK,uBAA6BmB,EAAQnB,EAAK,SAGhE,IAAMuB,GAAmB,WACtB9E,IAAMG,MAAQ,WADQ,MAEtBH,IAAME,OAAS,YAFO,MAGtBF,IAAMI,UAAY,eAHI,MAItBJ,IAAMK,OAAS,eAJO,MAKtBL,IAAMM,IAAM,WALU,GAQV,SAASyE,EACtBC,GAKC,IAJDC,EAIA,uDAJY,GACZC,EAGA,uDAHS,GACTC,EAEA,uCADAC,EACA,uDADoB,GAEdC,EADN,gCAME,WAAY9B,GAAQ,IAAD,EAIjB,GAJiB,aACjB,cAAMA,IAWR+B,uBAAyB,SAAAC,GACnBA,EAAMC,YAAYvC,aAAe,EAAKuB,YACxC,EAAKjB,MAAMkC,gBAAkB,EAAKlC,MAAMkC,eAAeF,GAEvD,EAAKhC,MAAMpB,uBACT,EAAKoB,MAAMpB,sBAAsBoD,IAjBpB,EAqBnBG,6BAA+B,SAAAH,GAC7B,GAAIA,EAAMC,YAAYvC,aAAe,EAAKuB,YAAa,CACrD,EAAKjB,MAAMoC,sBACT,EAAKpC,MAAMoC,qBAAqBJ,GAElC,IAAMK,EAAiBd,EAAoBS,EAAMC,YAAYjF,OACnB,oBAA/B,EAAKgD,MAAMqC,IACpB,EAAKrC,MAAMqC,GAAgBL,QAG7B,EAAKhC,MAAMlB,6BACT,EAAKkB,MAAMlB,4BAA4BkD,IAhC1B,EAoCnBM,YAAc,SAAAjE,GACZ,EAAKkE,UAAYlE,EAEjB,IACQmE,EADMzI,IAAM0I,SAASC,KAAK,EAAK1C,MAAM2C,UACrCH,IACI,OAARA,IACiB,oBAARA,EACTA,EAAInE,GAEJmE,EAAItI,QAAUmE,IA7CD,EAkDnBuE,sBAAwB,SAAAC,GACtB,EAAKC,QAAUD,EAEftD,IAAuBwD,qBACrBtB,EACA,EAAKR,YACL4B,IAxDe,EA4DnBG,sBAAwB,SAAAC,GACtB,EAAKC,SAAWD,EAEhB1D,IAAuB4D,qBAAqB,EAAKlC,YAAagC,IA/D7C,EAkEnBG,sBAAwB,SAAAP,GACtB,EAAKC,QAAUD,EAEftD,IAAuB8D,qBAAqB,EAAKpC,YAAa4B,IAnE9D,EAAK5B,YAAcvB,IACnB,EAAKoD,QAAU,GACX9C,EAAMsD,GAAI,CACZ,QAAiCxD,IAA7BH,EAAeK,EAAMsD,IACvB,MAAM,IAAIC,MAAJ,oBAA8BvD,EAAMsD,GAApC,wBAER3D,EAAeK,EAAMsD,IAAM,EAAKrC,YARjB,SANrB,gDA8EE,WACE1B,IAAuBiE,mBAAmBC,KAAKxC,aAC3CwC,KAAKC,iBACPC,EAAeF,KAAKC,iBAElBD,KAAKzD,MAAMsD,WACN3D,EAAe8D,KAAKzD,MAAMsD,MApFvC,+BAwFE,WAAqB,IAAD,OACdpC,EAAkBuC,KAAKzD,SAOzByD,KAAKC,gBAAkBE,GAAa,WAClC,EAAKF,gBAAkB,KACvB,EAAKG,cAITJ,KAAKb,sBACH7C,EACE6B,EAAiBA,EAAe6B,KAAKzD,OAASyD,KAAKzD,MADzC,OAELyD,KAAKK,YAAYpC,WAAcG,GACpCF,IAGJ8B,KAAKT,sBAAsB5E,EAAeqF,KAAKlB,cA7GnD,gCAgHE,WACE,IAAMwB,EAAU3F,EAAeqF,KAAKlB,WAChCkB,KAAKP,WAAaa,GACpBN,KAAKT,sBAAsBe,GAE7BN,KAAKI,YArHT,qBAwHE,WACE,IAAMhB,EAAY9C,EAChB6B,EAAiBA,EAAe6B,KAAKzD,OAASyD,KAAKzD,MADvB,OAEvByD,KAAKK,YAAYpC,WAAcG,GACpCF,GAEGqC,IAAUP,KAAKX,QAASD,IAC3BY,KAAKL,sBAAsBP,KA/HjC,4BAmIE,SAAeoB,GACb,IAAMC,EAAW,OAAQT,KAAKzD,OAAUiE,GAClCpB,EAAY9C,EAChB6B,EAAiBA,EAAesC,GAAeA,EADnB,OAEvBT,KAAKK,YAAYpC,WAAcG,GACpCF,GAEF8B,KAAKL,sBAAsBP,KA1I/B,oBA6IE,WACE,IAAIsB,EAAsBV,KAAK1B,uBADxB,EAE2C0B,KAAKzD,MAA/CkC,EAFD,EAECA,eAAgBtD,EAFjB,EAEiBA,sBACxB,GAAIsD,GAA4C,oBAAnBA,EAA+B,CAI1D,GAAItD,EACF,MAAM,IAAI2E,MACR,2EAGJY,EAAsBV,KAAKzD,MAAMkC,oBAEjC,GACEtD,GACiC,oBAA1BA,EAEP,MAAM,IAAI2E,MACR,2EAKN,IAAIa,EAA2BX,KAAKtB,6BAxB7B,EAyBuDsB,KAAKzD,MAA3DoC,EAzBD,EAyBCA,qBAAsBtD,EAzBvB,EAyBuBA,4BAC9B,GAAIsD,GAAwD,oBAAzBA,EAAqC,CAItE,GAAItD,EACF,MAAM,IAAIyE,MACR,2EAGJa,EAA2BX,KAAKzD,MAAMoC,0BAEtC,GACEtD,GACuC,oBAAhCA,EAEP,MAAM,IAAIyE,MACR,2EAKN,IAAMc,EAAQtK,IAAM0I,SAASC,KAAKe,KAAKzD,MAAM2C,UACzC2B,EAAgBD,EAAMrE,MAAM2C,SAgBhC,OAdE4B,IAAUC,oBACVH,EAAMI,OACU,2BAAfJ,EAAMI,MACe,SAApBJ,EAAMI,KAAK5J,MACgB,SAA3BwJ,EAAMI,KAAKC,eAEbJ,EAAgBvK,IAAM0I,SAASkC,QAAQL,IACzBM,KACZL,IAAUM,gBAAgB,CACxBvL,MAAO,oBACPwL,QAAST,EAAMrE,MAAM8E,WAIpB/K,IAAMgL,aACXV,EACA,CACE7B,IAAKiB,KAAKnB,YACV0C,aAAa,EACbpG,sBAAuBuF,EACvBrF,4BAA6BsF,GAE/BE,OArNN,GACsBvK,IAAMkL,WAwN5B,OAxNMnD,EACG4C,YAAcjD,EADjBK,EAGGJ,UAAYA,EAqNdI,K,2EC9VT,6CAC6B,qBAAToD,MAAwBA,MAChCC,OACRC,EAAQC,SAASC,UAAUF,MAiB/B,SAASG,EAAQjC,EAAIkC,GACnB/B,KAAKgC,IAAMnC,EACXG,KAAKiC,SAAWF,EAflB3H,EAAQ8H,WAAa,WACnB,OAAO,IAAIJ,EAAQH,EAAMlH,KAAKyH,WAAYC,EAAOC,WAAYC,eAE/DjI,EAAQkI,YAAc,WACpB,OAAO,IAAIR,EAAQH,EAAMlH,KAAK6H,YAAaH,EAAOC,WAAYG,gBAEhEnI,EAAQiI,aACRjI,EAAQmI,cAAgB,SAASC,GAC3BA,GACFA,EAAQC,SAQZX,EAAQD,UAAUa,MAAQZ,EAAQD,UAAU9C,IAAM,aAClD+C,EAAQD,UAAUY,MAAQ,WACxBzC,KAAKiC,SAASxH,KAAK0H,EAAOnC,KAAKgC,MAIjC5H,EAAQuI,OAAS,SAASC,EAAMC,GAC9BR,aAAaO,EAAKE,gBAClBF,EAAKG,aAAeF,GAGtBzI,EAAQ4I,SAAW,SAASJ,GAC1BP,aAAaO,EAAKE,gBAClBF,EAAKG,cAAgB,GAGvB3I,EAAQ6I,aAAe7I,EAAQ8I,OAAS,SAASN,GAC/CP,aAAaO,EAAKE,gBAElB,IAAID,EAAQD,EAAKG,aACbF,GAAS,IACXD,EAAKE,eAAiBZ,YAAW,WAC3BU,EAAKO,YACPP,EAAKO,eACNN,KAKP,EAAQ,KAIRzI,EAAQ+F,aAAgC,qBAATsB,MAAwBA,KAAKtB,cAClB,qBAAXiD,GAA0BA,EAAOjD,cACxCH,MAAQA,KAAKG,aACrC/F,EAAQ8F,eAAkC,qBAATuB,MAAwBA,KAAKvB,gBAClB,qBAAXkD,GAA0BA,EAAOlD,gBACxCF,MAAQA,KAAKE,iB,yTClBxBmD,EAzCiB,CAC9BxD,GAAIyD,IAAUC,OACdC,YAAaF,IAAUG,OACvBC,QAASJ,IAAUK,KACnBC,QAASN,IAAUO,UAAU,CAC3BP,IAAUC,OACVD,IAAUQ,OACVR,IAAUS,QACRT,IAAUO,UAAU,CAACP,IAAUC,OAAQD,IAAUQ,YAGrDE,qBAAsBV,IAAUO,UAAU,CACxCP,IAAUC,OACVD,IAAUQ,OACVR,IAAUS,QACRT,IAAUO,UAAU,CAACP,IAAUC,OAAQD,IAAUQ,YAGrDG,wBAAyBX,IAAUK,KACnCtC,QAASiC,IAAUO,UAAU,CAC3BP,IAAUG,OACVH,IAAUY,MAAM,CACdnH,KAAMuG,IAAUG,OAChB3G,IAAKwG,IAAUG,OACfhO,MAAO6N,IAAUG,OACjBzG,OAAQsG,IAAUG,OAClBU,SAAUb,IAAUG,OACpBW,WAAYd,IAAUG,OACtB1K,MAAOuK,IAAUG,OACjBzN,OAAQsN,IAAUG,WAGtBhF,eAAgB6E,IAAUO,UAAU,CAACP,IAAUe,KAAMf,IAAUQ,SAC/DnF,qBAAsB2E,IAAUO,UAAU,CAACP,IAAUe,KAAMf,IAAUQ,SACrEQ,QAAShB,IAAUe,KACnBE,SAAUjB,IAAUe,KACpBG,YAAalB,IAAUe,KACvBI,YAAanB,IAAUe,KACvBK,QAASpB,IAAUe,M,ikBCpCrB,IAQeM,EARkB5G,YAAc,2BAAD,OACzCsF,GADyC,IAI5CuB,sBAAuBtB,IAAUK,KACjCkB,qBAAsBvB,IAAUK,Q,ikBCClC,IAAMmB,EAA8B,CAClC,KACA,cACA,UACA,UACA,uBACA,0BACA,UACA,iBACA,uBACA,UACA,WACA,cACA,cACA,UACA,wBACA,uBACA,wBACA,+BAGa,SAASC,EAAoBvD,GAAyB,IAAdtD,EAAa,uDAAJ,GACxD8G,EAAmB1O,IAAM2O,YAAW,SAAC1I,EAAOwC,GAEhD,IAAMmG,EAAsBzL,OAAOD,KAAK+C,GAAO4I,QAC7C,SAACzI,EAAKE,GAIJ,OAHkD,IAA9CkI,EAA4BM,QAAQxI,KACtCF,EAAIE,GAAOL,EAAMK,IAEZF,IALiB,KAOrBwB,IAEP,OACE,kBAAC,EAA6BgH,EAC5B,kBAAC1D,EAAD,OAAejF,EAAf,CAAsBwC,IAAKA,SAUjC,OALAiG,EAAiB/G,UAAjB,KACKuD,EAAUvD,WAEf+G,EAAiB/D,YAAcO,EAAUP,aAAe,mBAEjD+D,E,OCtDMlJ,EAAf,U,OCCeuJ,EAAf,ECsBejQ,IAAWkQ,OAAO,CAC/BjQ,UAAW,CAAEC,KAAM,KADrB,I,+gCCjBO,IAAMiQ,EAAYR,ECLVzO,IAAM2O,YAAW,SAAC1I,EAAOwC,GAAR,OAC9B,kBAACsG,EAAA,EAAD,KAAMtG,IAAKA,EAAKyG,kBAAkB,UAAajJ,ODIkB,CACjE0H,yBAAyB,EACzBW,uBAAuB,IAKZa,EAAb,gCAOE,WAAYlJ,GAAQ,IAAD,sBACjB,cAAMA,IAIRmJ,aAAe,YAAsB,IAAnBlH,EAAkB,EAAlBA,YACRjF,EAAmCiF,EAAnCjF,MAAOoM,EAA4BnH,EAA5BmH,SACTzC,EADqC1E,EAAlBoH,eACOrM,IAAUP,IAAMK,OAE5C6J,IAAW,EAAK2C,aAAe,EAAKtJ,MAAMuJ,qBAC5C,EAAKvJ,MAAMuJ,oBAAoB5C,GAI/ByC,IAAa3M,IAAMK,QACnBE,IAAUP,IAAMI,WAChB,EAAKyM,aACL,EAAKtJ,MAAM9E,SAEX,EAAK8E,MAAM9E,QAAQyL,GAGrB,EAAK2C,YAAc3C,GAtBF,EA6BnB6C,sBAAwB,SAAAC,GACtB,EAAKzJ,MAAMoC,sBAAwB,EAAKpC,MAAMoC,qBAAqBqH,GACnE,EAAKN,aAAaM,IA/BD,EAkCnBC,gBAAkB,SAAAD,GAChB,EAAKzJ,MAAMkC,gBAAkB,EAAKlC,MAAMkC,eAAeuH,GACvD,EAAKN,aAAaM,IAlClB,EAAKH,aAAc,EAFF,EAPrB,kCA8CE,WAAU,IAAD,EAC0B7F,KAAKzD,MAA9B2J,EADD,EACCA,YAAgBnR,EADjB,uBAGP,OACE,kBAACwQ,EAAD,KACEW,YAAaC,YAAaD,IACtBnR,EAFN,CAGE0J,eAAgBuB,KAAKiG,gBACrBtH,qBAAsBqB,KAAK+F,6BAtDnC,GAAgCzP,IAAMkL,WAAzBiE,EACJxH,U,OACFsH,EAAUtH,W,IACbxG,QAAS6L,IAAUe,KACnByB,oBAAqBxC,IAAUe,OAwDnC,IAAM+B,EAAqB7P,IAAS8P,wBAAwBZ,GAEtDa,EAAYlR,IAAWkQ,OAAO,CAClCiB,SAAU,CACRC,SAAU,WACVzJ,KAAM,EACNtH,MAAO,EACPuH,OAAQ,EACRF,IAAK,KAII2J,EAAb,gCAQE,WAAYlK,GAAQ,IAAD,sBACjB,cAAMA,IAIRmK,qBAAuB,SAAAxD,GACD,YAAhBrI,IAASC,IACX,EAAK6L,SAASC,SAAS1D,EAAS,EAAK3G,MAAMsK,cAAgB,GAG7D,EAAKtK,MAAMuJ,qBAAuB,EAAKvJ,MAAMuJ,oBAAoB5C,IARjE,EAAKyD,SAAW,IAAIpQ,IAASuQ,MAAM,GAFlB,EARrB,kCAqBE,WAAU,IAAD,EAC8B9G,KAAKzD,MAAlC2C,EADD,EACCA,SAAUlK,EADX,EACWA,MAAUD,EADrB,4BAGDgS,EAAgB3R,IAAW4R,QAAX,MAAmBhS,IAAS,IAElD,OACE,kBAAC,EAAD,OACMD,EADN,CAEEC,MAAO+R,EACPjB,oBAAqB9F,KAAK0G,uBAC1B,kBAACnQ,EAAA,EAAS8O,KAAV,CACErQ,MAAO,CACLsR,EAAUC,SACV,CACEU,QAASjH,KAAK2G,SACdO,gBAAiBlH,KAAKzD,MAAM4K,cAC5BC,aAAcL,EAAcK,aAC5BC,oBAAqBN,EAAcM,oBACnCC,qBAAsBP,EAAcO,qBACpCC,uBAAwBR,EAAcQ,uBACtCC,wBAAyBT,EAAcS,4BAI5CtI,OA7CT,GAAgC5I,IAAMkL,WAAzBiF,EACJxI,UAAYwH,EAAWxH,UADnBwI,EAGJgB,aAAe,CACpBZ,cAAe,KACfM,cAAe,SA8CZ,IAAMO,EAAb,gCAWE,WAAYnL,GAAQ,IAAD,sBACjB,cAAMA,IAIRmK,qBAAuB,SAAAxD,GACD,YAAhBrI,IAASC,IACX,EAAK6L,SAASC,SAAS1D,EAAS,EAAK3G,MAAMsK,cAAgB,GAG7D,EAAKtK,MAAMuJ,qBAAuB,EAAKvJ,MAAMuJ,oBAAoB5C,IARjE,EAAKyD,SAAW,IAAIpQ,IAASuQ,MAAM,GAFlB,EAXrB,kCAwBE,WAAU,IAAD,EAC8B9G,KAAKzD,MAAlC2C,EADD,EACCA,SAAUlK,EADX,EACWA,MAAUD,EADrB,4BAGP,OACE,kBAACqR,EAAD,OACMrR,EADN,CAEE+Q,oBAAqB9F,KAAK0G,qBAC1B1R,MAAO,CAACA,EAAuB,QAAhB6F,IAASC,IAAgB,CAAEmM,QAASjH,KAAK2G,aACvDzH,OAhCT,GAAsC5I,IAAMkL,WAA/BkG,EACJzJ,U,OACFwH,EAAWxH,W,IACd0J,WAAYrE,IAAUK,OAHb+D,EAMJD,aAAe,CACpBZ,cAAe,GACfc,YAAY,G,uCEvIHC,EAAa7C,E,MAAoB8C,EAAc,CAC1DhD,sBAAsB,IAGFE,EAAoB+C,IAAU,CAClD7D,yBAAyB,EACzBW,uBAAuB,EACvBC,sBAAsB,IAECE,EAAoBgD,KACVhD,EAAoBiD,IAAuB,CAC5EnD,sBAAsB,IAEJoD,UAAYD,IAAsBC,UAE/C,IAAMC,GAAW5R,IAAM2O,YAAW,SAAC1I,EAAOwC,GAAR,OACvC,kBAAC,IAAD,KACEA,IAAKA,GACDxC,EAFN,CAGE4L,sBAAuB,SAAAC,GAAW,OAAI,kBAAC,EAAeA,UC9B3C,IACb,0BACE,OAAO,I,k0BCKJ,IAAMC,GAAoBtK,YAC/B,oBAD4C,GAAC,MAGxCsF,GAHuC,IAI1CiF,cAAehF,IAAUG,OACzB8E,WAAYjF,IAAUG,OACtB+E,aAAclF,IAAUG,OACxBgF,UAAWnF,IAAUG,OACrBiF,UAAWpF,IAAUG,OACrBkF,QAASrF,IAAUG,OACnBD,YAAaF,IAAUG,SAEzB,IAaImF,IAV6B7K,YACjC,sBAD8C,GAAC,MAG1CsF,GAHyC,IAI5CwF,iBAAkBvF,IAAUG,OAC5BnM,UAAWgM,IAAUG,SAEvB,I,6RAIA,WACEqF,QAAQC,KACN,kO,oBAGJ,WACE,OAAO/I,KAAKzD,MAAM2C,a,GAPW5I,IAAMkL,aAYrCwH,IAAqBA,GAAkBC,oBACnClL,YACE,2BADW,GAAC,MAGPsF,GAHM,IAIT6F,SAAU5F,IAAUG,OACpB0F,SAAU7F,IAAUG,OACpB2F,qBAAsB9F,IAAUK,OAElC,IAEFiF,IAEmBK,oBACtBD,IAAqBA,GAAkBC,sBAAwB,EAE3BlL,YACrC,0BADkD,GAAC,MAG9CsF,GAH6C,IAIhDgG,cAAe/F,IAAUG,OACzBkF,QAASrF,IAAUG,SAErB,IAgKK,IAAM6F,GAAoBvL,YAC/B,oBAD4C,GAAC,MAGxCsF,GAHuC,IAI1CkG,cAAejG,IAAUO,UAAU,CACjCP,IAAUG,OACVH,IAAUS,QAAQT,IAAUG,UAE9B+F,cAAelG,IAAUO,UAAU,CACjCP,IAAUG,OACVH,IAAUS,QAAQT,IAAUG,UAE9BgG,YAAanG,IAAUO,UAAU,CAC/BP,IAAUG,OACVH,IAAUS,QAAQT,IAAUG,UAE9BiG,YAAapG,IAAUO,UAAU,CAC/BP,IAAUG,OACVH,IAAUS,QAAQT,IAAUG,UAE9BkG,QAASrG,IAAUG,OACnBmG,YAAatG,IAAUG,OACvBoG,aAAcvG,IAAUG,OACxBqG,aAAcxG,IAAUG,OACxBD,YAAaF,IAAUG,OACvBsG,YAAazG,IAAUG,OACvBuG,WAAY1G,IAAUK,OAExB,IAnCF,SAAwBpH,GAItB,OAhGF,SAAyCA,GACvC,IAAMG,EAAG,MAAQH,GAwFjB,YAvFwBF,IAApBE,EAAM0N,mBACDvN,EAAG,UACVA,EAAIwN,oBAAsB3N,EAAM0N,UAChCvN,EAAIyN,iBAAmB5N,EAAM0N,gBAEP5N,IAApBE,EAAMkM,mBACD/L,EAAG,UACVA,EAAI0N,kBAAoB7N,EAAMkM,UAC9B/L,EAAI2N,eAAiB9N,EAAMkM,gBAEJpM,IAArBE,EAAM+N,oBACD5N,EAAG,WACNH,EAAM+N,WAAa,EACrB5N,EAAIwN,mBAAqB3N,EAAM+N,WAE/B5N,EAAIyN,iBAAmB5N,EAAM+N,iBAITjO,IAApBE,EAAMgO,mBACD7N,EAAG,UACVA,EAAI8N,oBAAsBjO,EAAMgO,UAChC7N,EAAI+N,iBAAmBlO,EAAMgO,gBAEPlO,IAApBE,EAAMmM,mBACDhM,EAAG,UACVA,EAAIgO,kBAAoBnO,EAAMmM,UAC9BhM,EAAIiO,eAAiBpO,EAAMmM,gBAGJrM,IAArBE,EAAMqO,oBACDlO,EAAG,WACNH,EAAMqO,WAAa,EACrBlO,EAAI8N,mBAAqBjO,EAAMqO,WAE/BlO,EAAI+N,iBAAmBlO,EAAMqO,iBAILvO,IAAxBE,EAAMiN,uBACD9M,EAAG,cACNQ,MAAMC,QAAQZ,EAAMiN,gBACtB9M,EAAIwN,mBAAqB3N,EAAMiN,cAAc,GAC7C9M,EAAIyN,iBAAmB5N,EAAMiN,cAAc,IAClCjN,EAAMiN,cAAgB,EAC/B9M,EAAIwN,mBAAqB3N,EAAMiN,cAE/B9M,EAAIyN,iBAAmB5N,EAAMiN,oBAILnN,IAAxBE,EAAMgN,uBACD7M,EAAG,cACNQ,MAAMC,QAAQZ,EAAMgN,gBACtB7M,EAAI8N,mBAAqBjO,EAAMgN,cAAc,GAC7C7M,EAAI+N,iBAAmBlO,EAAMgN,cAAc,IAClChN,EAAMgN,cAAgB,EAC/B7M,EAAI8N,mBAAqBjO,EAAMgN,cAE/B7M,EAAI+N,iBAAmBlO,EAAMgN,oBAIPlN,IAAtBE,EAAMmN,qBACDhN,EAAG,YACNQ,MAAMC,QAAQZ,EAAMmN,cACtBhN,EAAI0N,iBAAmB7N,EAAMmN,YAAY,GACzChN,EAAI2N,eAAiB9N,EAAMmN,YAAY,IAC9BnN,EAAMmN,YAAc,EAC7BhN,EAAI0N,iBAAmB7N,EAAMmN,YAE7BhN,EAAI2N,eAAiB9N,EAAMmN,kBAILrN,IAAtBE,EAAMkN,qBACD/M,EAAG,YACNQ,MAAMC,QAAQZ,EAAMkN,cACtB/M,EAAIgO,iBAAmBnO,EAAMkN,YAAY,GACzC/M,EAAIiO,eAAiBpO,EAAMkN,YAAY,IAC9BlN,EAAMkN,YAAc,EAC7B/M,EAAIgO,iBAAmBnO,EAAMkN,YAE7B/M,EAAIiO,eAAiBpO,EAAMkN,aAIxB/M,EAOAmO,CAAgCtO,KAiCvC,CACEiO,oBAAoB,EACpBC,kBAAkB,EAClBP,oBAAoB,EACpBC,kBAAkB,EAClBO,kBAAkB,EAClBC,gBAAgB,EAChBP,kBAAkB,EAClBC,gBAAgB,IAGetM,YACjC,sBACAsF,EACA,IAEoCtF,YACpC,yBACAsF,EACA,I,2/BCpNA,WAAY9G,GAAkB,IAAD,eAC3B,cAAMA,IAgCRuO,qBAAuB,SAACvO,EAAiBhD,GAAsB,IACrDwR,EAAqDxO,EAArDwO,SAAUC,EAA2CzO,EAA3CyO,kBACVC,GADqD1O,EAAxB2O,oBAC0B3R,EAAvD0R,OAAOE,EAAgD5R,EAAhD4R,eAF6C,EAEG5R,EAAhC6R,iBAF6B,MAEjB,EAFiB,IAEG7R,EAAjB8R,gBAFc,MAEH,EAFG,IAGzB9R,EAA3B+R,mBAHoD,MAGtCD,EAHsC,EAItDE,EAAaC,KAAKC,IAAI,EAAGJ,EAAWC,GAJkB,EASxD/O,EAFFmP,qBAP0D,MAO1CN,EAAY,EAP8B,IASxD7O,EADFoP,sBAR0D,MAQzCJ,EAAa,EAR4B,EAWtDK,EAASrV,IAASsV,IACtBV,EACAF,EAAMa,YAAY,CAChB/U,WAAY,CAAC,EAAGgU,GAChB/T,YAAa,CAAC,EAAG,MAEnB8U,YAAY,CACZ/U,WAAY,EACTwU,GAAcI,EAAiB,EAAIX,IACnCO,EACDH,EACAA,GAAaM,EAAgB,EAAIV,IAEnChU,YAAa,EACVuU,GAAcI,GAAkBX,EAAoB,EAAI,EAAI,IAC5DO,EACDH,EACAA,GAAaM,GAAiBV,EAAoB,EAAI,EAAI,MAG9D,EAAKe,QAAUH,EACf,EAAKI,gBACHZ,EAAY,EACRQ,EAAOE,YAAY,CACjB/U,WAAY,EAAE,EAAG,EAAGqU,GACpBpU,YAAa,CAAC,EAAG,EAAG,KAEtB,IAAIT,IAASuQ,MAAM,GACzB,EAAKmF,qBAAuB,EAAKD,gBAAgBF,YAAY,CAC3D/U,WAAY,CAAC,EAAGmV,OAAOC,WACvBnV,YAAa,EAAE,IAAO,GACtBoV,YAAa,UAEf,EAAKC,iBACHd,EAAa,EACTK,EAAOE,YAAY,CACjB/U,WAAY,EAAEwU,EAAY,EAAG,GAC7BvU,YAAa,CAAC,EAAG,EAAG,KAEtB,IAAIT,IAASuQ,MAAM,GACzB,EAAKwF,sBAAwB,EAAKD,iBAAiBP,YAAY,CAC7D/U,WAAY,CAAC,EAAGmV,OAAOC,WACvBnV,YAAa,EAAE,IAAO,GACtBoV,YAAa,WAvFY,EA2F7BG,yBAA2B,YAAqB,EAAlB/N,YACZmH,WAAa3M,IAAMK,QACjC,EAAKoJ,SA7FoB,EAiG7BsD,sBAAwB,YAAsB,IAAnBvH,EAAkB,EAAlBA,YACrBA,EAAYmH,WAAa3M,IAAMK,QACjC,EAAKmT,eAAehO,IAnGK,EAuG7BgO,eAAiB,SAAAhO,GAAgB,IACvBiO,EAAmCjO,EAAnCiO,UAAyBxB,EAAUzM,EAAxBkO,aADW,EAEoB,EAAKnT,MAFzB,IAEtB6R,iBAFsB,MAEV,EAFU,MAEPC,gBAFO,MAEI,EAFJ,EAEOsB,EAFP,EAEOA,SAFP,EAGK,EAAKpT,MAAhC+R,YACFC,EAAaF,QAJW,MAGRA,EAHQ,KAS1B,EAAK9O,MAHPwO,EAN4B,EAM5BA,SAN4B,IAO5B6B,qBAP4B,MAOZxB,EAAY,EAPA,MAQ5ByB,sBAR4B,MAQXtB,EAAa,EARF,EAWxBuB,EAAe,EAAKC,iBAAmB9B,EAAQF,EAC/C2B,GAAgBzB,EAxKR,IAwK4BwB,GAAa1B,EAEnDrU,EAAU,EACG,IAAbiW,EACED,EAAeE,EACjBlW,EAAU0U,EACDsB,GAAgBG,IACzBnW,GAAW6U,GAES,IAAboB,EAELD,GAAgBE,IAClBlW,EAAU0U,GAIRsB,EAAeG,IACjBnW,GAAW6U,GAIf,EAAKyB,YAAYF,EAAcpW,EAAS+V,EAAY1B,IAxIzB,EA2I7BiC,YAAc,SAACC,EAAWvW,EAAS+V,GAAe,IAAD,EACb,EAAKlT,MAA/B0R,EADuC,EACvCA,MAAOE,EADgC,EAChCA,eACfF,EAAMrE,SAAS,GACfuE,EAAevE,SAASqG,GAExB,EAAKC,SAAS,CAAEP,SAAUnB,KAAK2B,KAAKzW,KACpCH,IAAS6W,OAAOjC,EAAhB,IACEkC,mBAAoB,IACpBC,0BAA2B,GAC3BC,SAAUd,EACVe,WAAY,EACZ9W,UACAE,gBAAiB,EAAK2F,MAAM2O,qBACzB,EAAK3O,MAAMkR,mBACbC,OAAM,YAAkB,EAAfC,WAEJjX,EAAU,GAAK,EAAK6F,MAAMqR,oBAC5B,EAAKrR,MAAMqR,sBACFlX,EAAU,GAAK,EAAK6F,MAAMsR,sBACnC,EAAKtR,MAAMsR,uBAGG,IAAZnX,EACF,EAAK6F,MAAMuR,kBAAoB,EAAKvR,MAAMuR,mBAE1C,EAAKvR,MAAMwR,iBAAmB,EAAKxR,MAAMwR,sBAI3CrX,EAAU,GAAK,EAAK6F,MAAMyR,wBAC5B,EAAKzR,MAAMyR,0BACFtX,EAAU,GAAK,EAAK6F,MAAM0R,0BACnC,EAAK1R,MAAM0R,2BAGG,IAAZvX,EACF,EAAK6F,MAAM2R,sBAAwB,EAAK3R,MAAM2R,uBAE9C,EAAK3R,MAAM4R,qBAAuB,EAAK5R,MAAM4R,uBAjLpB,EAqL7BC,aAAe,YAAsB,IAAnB5P,EAAkB,EAAlBA,YAChB,EAAK0O,SAAS,CAAE7B,SAAU7M,EAAY6P,OAAOtV,SAtLlB,EAyL7BgU,eAAiB,WAAO,IAAD,EAC6B,EAAKxT,MADlC,IACb6R,iBADa,MACD,EADC,MACEC,gBADF,MACa,EADb,EACgBsB,EADhB,EACgBA,SADhB,EAEc,EAAKpT,MAAhC+R,YAER,OAAiB,IAAbqB,EACKvB,GACgB,IAAduB,IAHQtB,QAHE,MAECA,EAFD,IASd,GAlMoB,EAqM7B5I,MAAQ,WACN,EAAKuK,YAAY,EAAKD,iBAAkB,IAtMb,EAyM7BuB,SAAW,WAAO,IAAD,EACW,EAAK/U,MAAvB6R,iBADO,MACK,EADL,EAEf,EAAK4B,YAAY,EAAKD,iBAAkB3B,IA3Mb,EA8M7BmD,UAAY,WAAO,IAAD,EACS,EAAKhV,MAAtB8R,gBADQ,MACG,EADH,IAEmB,EAAK9R,MAAhC+R,YACFC,EAAaF,QAHH,MAEMA,EAFN,GAIhB,EAAK2B,YAAY,EAAKD,kBAAmBxB,IAhNzC,IAAMN,EAAQ,IAAI1U,IAASuQ,MAAM,GAFN,OAG3B,EAAKvN,MAAQ,CACX0R,QACAE,eAAgB,IAAI5U,IAASuQ,MAAM,GACnC6F,SAAU,EACVvB,eAAW/O,EACXiP,iBAAajP,EACbgP,cAAUhP,GAEZ,EAAKyO,qBAAqBvO,EAAO,EAAKhD,OAEtC,EAAK0M,gBAAkB1P,IAASgI,MAC9B,CAAC,CAAEC,YAAa,CAAEkO,aAAczB,KAChC,CAAErU,gBAAiB2F,EAAM2O,sBAfA,E,sDAmB7B,SAA2B3O,EAAiBhD,GAExCyG,KAAKzD,MAAMwO,WAAaxO,EAAMwO,UAC9B/K,KAAKzD,MAAMmP,gBAAkBnP,EAAMmP,eACnC1L,KAAKzD,MAAMoP,iBAAmBpP,EAAMoP,gBACpC3L,KAAKzD,MAAMyO,oBAAsBzO,EAAMyO,mBACvChL,KAAKzG,MAAM6R,YAAc7R,EAAM6R,WAC/BpL,KAAKzG,MAAM+R,cAAgB/R,EAAM+R,aACjCtL,KAAKzG,MAAM8R,WAAa9R,EAAM8R,UAE9BrL,KAAK8K,qBAAqBvO,EAAOhD,K,oBAwLrC,WAAU,IAAD,OACCoT,EAAa3M,KAAKzG,MAAlBoT,SADD,EAEqD3M,KAAKzD,MAAzD2C,EAFD,EAECA,SAAUsP,EAFX,EAEWA,kBAAmBC,EAF9B,EAE8BA,mBAE/B1R,EAAOyR,GACX,kBAACjY,EAAA,EAAS8O,KAAV,CACErQ,MAAO,CACLC,GAAOyZ,YACP,CAAExX,UAAW,CAAC,CAAEyX,WAAY3O,KAAKiM,0BAElCuC,EAAkBxO,KAAKgM,gBAAiBhM,KAAK+L,SAC9C,kBAAC1G,EAAA,EAAD,CACEuJ,SAAU,gBAAGpQ,EAAH,EAAGA,YAAH,OACR,EAAK0O,SAAS,CAAE9B,UAAW5M,EAAY6P,OAAOQ,QAMhDpZ,EAAQgZ,GACZ,kBAAClY,EAAA,EAAS8O,KAAV,CACErQ,MAAO,CACLC,GAAO6Z,aACP,CAAE5X,UAAW,CAAC,CAAEyX,WAAY3O,KAAKsM,2BAElCmC,EAAmBzO,KAAKqM,iBAAkBrM,KAAK+L,SAChD,kBAAC1G,EAAA,EAAD,CACEuJ,SAAU,gBAAGpQ,EAAH,EAAGA,YAAH,OACR,EAAK0O,SAAS,CAAE5B,YAAa9M,EAAY6P,OAAOQ,QAMxD,OACE,kBAACvF,GAAD,KACEE,cAAe,EAAE,GAAI,KACjBxJ,KAAKzD,MAFX,CAGEkC,eAAgBuB,KAAKiG,gBACrBtH,qBAAsBqB,KAAK+F,wBAC3B,kBAACxP,EAAA,EAAS8O,KAAV,CACEuJ,SAAU5O,KAAKoO,aACfpZ,MAAO,CAACC,GAAOI,UAAW2K,KAAKzD,MAAMwS,iBACpChS,EACAtH,EACD,kBAAC4S,GAAD,CACE3E,QAAsB,IAAbiJ,EACThO,qBAAsBqB,KAAKuM,0BAC3B,kBAAChW,EAAA,EAAS8O,KAAV,CACExM,cAA4B,IAAb8T,EAAiB,OAAS,WACzC3X,MAAO,CACL,CACEkC,UAAW,CAAC,CAAEyX,WAAY3O,KAAK+L,WAEjC/L,KAAKzD,MAAMyS,yBAEZ9P,U,GA1RwBsC,cAC9BiG,aAAe,CACpBsD,SAAU,EACVC,kBAAmB,EACnBE,qBAAqB,GA+RzB,IAAMjW,GAASG,IAAWkQ,OAAO,CAC/BjQ,UAAW,CACT4Z,SAAU,UAEZP,YAAY,SACPtZ,IAAW8Z,oBADL,IAET3Z,cAAegC,IAAY4X,MAAO,cAAe,QAEnDL,aAAa,SACR1Z,IAAW8Z,oBADJ,IAEV3Z,cAAegC,IAAY4X,MAAQ,MAAQ,kB,y2BCzU/C,IAiDqBC,G,wLAuBnB,WAAY7S,EAAiB8S,GAAe,IAAD,eACzC,cAAM9S,EAAO8S,IANfC,0BAA4BhZ,IAAMiZ,YAKS,EAJ3CC,mBAAqBlZ,IAAMiZ,YAIgB,EAH3CE,mBAAqBnZ,IAAMiZ,YAGgB,EAF3CG,cAAe,EAE4B,EA4B3C5E,qBAAuB,SAACvO,EAAiBhD,GAAsB,IAErDoW,EAA4CpT,EAA5CoT,eAAgBC,EAA4BrT,EAA5BqT,YAAaC,EAAetT,EAAfsT,WAE5BC,EAILvW,EAJF0R,MACQ8E,EAGNxW,EAHFyW,OACAC,EAEE1W,EAFF0W,kBACAC,EACE3W,EADF2W,eAGEjF,EAAQ6E,EACRE,EAASD,EAEU,SAAnBJ,GAQF1E,EAAQ1U,IAAS4Z,SAAS,IAAI5Z,IAASuQ,OAAO,GAAIgJ,GAClDE,EAASzZ,IAASsV,IAChB,IAAItV,IAASuQ,MAAMoJ,GACnB3Z,IAAS4Z,SAAS,IAAI5Z,IAASuQ,OAAO,GAAIiJ,IAE5CA,EAAYnJ,SAASsJ,IAErBH,EAAYnJ,SAAS,GA2BvB,IAAI8F,EAAezB,EACnB,GAAmB,UAAf4E,EAAwB,CAC1B,IAKMO,EALiB7Z,IAASsV,IAC9BmE,EACAzZ,IAAS4Z,SAAS,IAAI5Z,IAASuQ,OAAO,GAAImE,IAGSa,YAAY,CAC/D/U,WAAY,CAAC6Y,EAAc,EAAGA,EAAaA,EAAc,GACzD5Y,YAAa,CAAC,EAAG,EAAG,KAEtB0V,EAAenW,IAASsV,IAAIZ,EAAOmF,GAGrC,EAAKC,WAAa9Z,IAASsV,IAAIa,EAAcuD,GAAmBnE,YAC9D,CACE/U,WAAY,CAAC,EAAG6Y,GAChB5Y,YAAa,CAAC,EAAG,GACjBoV,YAAa,UAIjB,EAAKnG,gBAAkB1P,IAASgI,MAC9B,CAAC,CAAEC,YAAa,CAAEkO,aAAcoD,EAAYjB,EAAGkB,KAC/C,CAAEnZ,gBAAiB2F,EAAM2O,uBA3Gc,EA+G3CoF,uBAAyB,YAAsB,IAAnB9R,EAAkB,EAAlBA,YAC1B,EAAK0O,SAAS,CAAEgD,eAAgB1R,EAAY6P,OAAOtV,SAhHV,EAmH3CwX,kBAAoB,SAACC,EAAkBC,GACrC,EAAKlU,MAAMmU,sBACT,EAAKnU,MAAMmU,qBAAqBF,EAAUC,IArHH,EAwH3CE,2BAA6B,YAAsB,IAAnBnS,EAAkB,EAAlBA,YAC1BA,EAAYmH,WAAa3M,IAAMK,OACjC,EAAKmT,eAAehO,GACXA,EAAYjF,QAAUP,IAAMK,SACrC,EAAKkX,kBAjMM,YAiMsB,GACM,YAAnC,EAAKhU,MAAMqU,qBACbC,KAASC,UAEP,EAAKvU,MAAMwU,eACbC,KAAUC,WAAU,EAAM,EAAK1U,MAAM2U,oBAAsB,WAjItB,EAsI3C3E,yBAA2B,YAAsB,IAAnB/N,EAAkB,EAAlBA,YAE1B,EAAKkR,cACLlR,EAAYmH,WAAa3M,IAAMK,QACD,gBAA9B,EAAKkD,MAAM4U,gBAEX,EAAKC,eA5IkC,EAgJ3C5E,eAAiB,SAAAhO,GAAgB,IAAD,EACsB,EAAKjC,MAAjDqT,EADsB,EACtBA,YAAaD,EADS,EACTA,eAAgBE,EADP,EACOA,WAC7BK,EAAmB,EAAK3W,MAAxB2W,eACYjF,EAAgCzM,EAA9CkO,aAAqBD,EAAyBjO,EAAzBiO,UAAcuD,EAAWxR,EAAdqQ,EAEf,SAAnBc,IAGF1E,GAASA,EACT+E,EAASE,EAAiBF,EAC1BvD,GAAaA,GAGf,IAAM4E,EAAgBrB,EAAS/E,EAC3BqG,EAAyB,EAEV,UAAfzB,IACFyB,EACED,EAAgBzB,EAAcyB,EAAgBzB,EAAc,GAGhE,IAAM9C,EACJ7B,EAAQqG,GAA0B,EAAK5B,aAAeE,EAAc,GAClD9C,EA/ON,IA+OiCL,EAEdmD,EAAc,EAG7C,EAAK2B,eAAezE,EAAc8C,EAAanD,GAE/C,EAAK8E,eAAezE,EAAc,EAAGL,IA9KE,EAkL3C+E,eAAiB,SAACC,GAChB,EAAK/B,aAAe+B,EACpB,EAAKnC,0BAA0B7Y,SAC7B,EAAK6Y,0BAA0B7Y,QAAQib,eAAe,CACpDC,yBAA0BF,IAE9B,EAAKjC,mBAAmB/Y,SACtB,EAAK+Y,mBAAmB/Y,QAAQib,eAAe,CAC7C7Y,cAAe4Y,EAAU,OAAS,SARD,MAUmB,EAAKlV,MAArDoT,EAV6B,EAU7BA,eAAgBiC,EAVa,EAUbA,iBAAkBC,EAVL,EAUKA,UACpCC,EAA8B,SAAnBnC,EAIXoC,GACHD,EAAW,GAAK,IAAM,EAAKpC,cAAgB,EAAI,GAI5CrO,EAAUyQ,EACZ,CAAE/U,KAAM,EAAGhE,MAAO0Y,OAAUpV,EAAYwV,GACxC,CAAEpc,MAAO,EAAGsD,MAAO0Y,OAAUpV,EAAYwV,GAC7C,EAAKpC,mBAAmBhZ,SACtB,EAAKgZ,mBAAmBhZ,QAAQib,eAAe,CAC7CrQ,UACAmI,cAAeuI,EAAqBH,KA5MC,EAgN3CL,eAAiB,SAACtE,EAAoBvW,EAAiB6W,GAMrD,GALA,EAAKhU,MAAM0R,MAAMrE,SAAS,GAC1B,EAAKrN,MAAMyW,OAAOpJ,SACc,SAA9B,EAAKrK,MAAMoT,eAA4B,EAAI,EAAKpW,MAAM2W,gBAGvC,MAAbjD,EAAmB,CACrB,IAAI+E,EAAoB/E,EACpB,EAAK1Q,MAAM2O,sBAKT+B,EAAYvW,GAAW6W,EAAW,EACpCyE,EAAoBxG,KAAKyG,IAAIhF,EAAYM,EAAW,GAAM7W,GACjDuW,EAAYvW,GAAW6W,EAAW,IAC3CyE,EAAoBxG,KAAKC,IAAIwB,EAAYM,EAAW,GAAM7W,KAG9D,EAAK6C,MAAM0W,kBAAkBrJ,SAASoL,GAGxC,IAAME,EAAuB,IAAZxb,EACjB,EAAK8a,eAAeU,GACpB,EAAK3B,kBA5SQ,WA4SoB2B,GAC7B,EAAK3V,MAAMwU,eACbC,KAAUC,UAAUiB,EAAU,EAAK3V,MAAM2U,oBAAsB,SAEjE3a,IAAS6W,OAAO,EAAK7T,MAAM0W,kBAAmB,CAC5C1C,WACAC,WAAY,EACZ9W,UACAE,gBAAiB,EAAK2F,MAAM2O,sBAC3BwC,OAAM,YAAkB,EAAfC,WAER,EAAK4C,kBAzTA,OAyTwB2B,GACzBA,EACF,EAAK3V,MAAM4V,cAAgB,EAAK5V,MAAM4V,eAEtC,EAAK5V,MAAM6V,eAAiB,EAAK7V,MAAM6V,qBAvPJ,EA6P3CC,WAAa,WAA6C,IAA5CC,EAA2C,uDAAP,GAChD,EAAKf,oBACHlV,EACA,EAAKE,MAAMqT,YACX0C,EAAQ/E,SAAW+E,EAAQ/E,SAAW,GAIxC,EAAKgF,eArQoC,EAwQ3CnB,YAAc,WAA6C,IAA5CkB,EAA2C,uDAAP,GACjD,EAAKf,oBAAelV,EAAW,EAAGiW,EAAQ/E,SAAW+E,EAAQ/E,SAAW,GAGxE,EAAKgF,eA5QoC,EA+Q3CC,eAAiB,WAEfC,KAAU,EAAKpC,WAAY,iBAC3B,IAKMqC,EAAuB,CAC3BzL,QANqB,EAAKoJ,WAAWvE,YAAY,CACjD/U,WAAY,CAAC,EAAG,GAChBC,YAAa,CAAC,EAAG,GACjBoV,YAAa,UAIblF,gBAAiB,EAAK3K,MAAMoW,cAG9B,OACE,kBAACtK,GAAD,CAAmB1J,qBAAsB,EAAK4N,0BAC5C,kBAAChW,EAAA,EAAS8O,KAAV,CACExM,cAAe,EAAK6W,aAAe,OAAS,OAC5C3Q,IAAK,EAAKyQ,mBACVxa,MAAO,CAACC,GAAO2d,QAASF,OAjSW,EAuS3CG,cAAgB,WAAO,IA2BjBC,EA3BgB,EAQhB,EAAKvW,MANPwW,EAFkB,EAElBA,sBACAnD,EAHkB,EAGlBA,YACAD,EAJkB,EAIlBA,eACAE,EALkB,EAKlBA,WACAmD,EANkB,EAMlBA,qBACAC,EAPkB,EAOlBA,sBAGInB,EAA8B,SAAnBnC,EACXuD,EAA6B,SAAfrD,EACdsD,EAAgC,UAAftD,EAMjBuD,EAA0B7b,IAAY4X,MAAQ2C,GAAYA,EAE1DuB,EAAsB,CAC1BnM,gBAAiB6L,EACjBha,MAAO6W,GAEH0D,EAAY,EAAKjD,YACvBoC,KAAUa,EAAW,iBAGjBH,KAMFL,EAAkB,CAChB5b,UAAW,CAAC,CAAEyX,WANY2E,EAAUxH,YAAY,CAChD/U,WAAY,CAAC,EAAG,GAChBC,YAAa8a,EAAW,CAAC,EAAGlC,GAAe,CAAC,GAAIA,GAChDxD,YAAa,cAOjB,IAAImH,EAAmB,EACvB,GAAIL,EAAa,CACf,IAAMM,EAAqB1B,GAAYlC,EAAcA,EACrD2D,EAAmBD,EAAUxH,YAAY,CACvC/U,WAAY,CAAC,EAAG,GAChBC,YAAa,CAACwc,EAAoB,GAClCpH,YAAa,UAGjB,IAAMqH,EAAe,CACnBvc,UAAW,CAAC,CAAEyX,WAAY4E,IAC1Bhe,cAAe6d,EAA0B,cAAgB,OAG3D,OACE,kBAAC7c,EAAA,EAAS8O,KAAV,CAAerQ,MAAOC,GAAOye,KAAM9E,SAAU,EAAK0B,wBAChD,kBAAC/Z,EAAA,EAAS8O,KAAV,CACErQ,MAAO,CACU,UAAf6a,EACI5a,GAAO0e,gBACP1e,GAAO2e,iBACXd,EACAG,GAEFY,0BACE,EAAKnE,aAAe,sBAAwB,OAEd,oBAAxB,EAAKnT,MAAM2C,SACf,EAAK3C,MAAM2C,SAAS,EAAKmR,YACzB,EAAK9T,MAAM2C,SACd,EAAKsT,kBAER,kBAACjc,EAAA,EAAS8O,KAAV,CACExM,cAAc,WACdkG,IAAK,EAAKuQ,0BACVqC,yBAA0B,EAAKjC,aAC/B1a,MAAO,CAACC,GAAO6e,gBAAiBL,EAAcT,IAC9C,kBAAC3N,EAAA,EAAD,CAAMrQ,MAAOqe,GACV,EAAK9W,MAAMwX,qBAAqB,EAAK1D,gBApXL,EA2X3C2D,kBAAoB,SAAAjV,GAClB,EAAK0Q,mBAAmBhZ,QAAUsI,EAClC,EAAKxC,MAAM0X,cAAgB,EAAK1X,MAAM0X,aAAalV,IA1XnD,IAAMkM,EAAQ,IAAI1U,IAASuQ,MAAM,GAC3BkJ,EAAS,IAAIzZ,IAASuQ,MAAM,GAC5BmJ,EAAoB,IAAI1Z,IAASuQ,MAAM,GALJ,OAOzC,EAAKvN,MAAQ,CACX0R,QACA+E,SACAC,oBACAC,eAAgB,GAGlB,EAAKpF,qBAAqBvO,EAAO,EAAKhD,OAdG,E,sDAiB3C,SAA2BgD,EAAiBhD,GAExCyG,KAAKzD,MAAMoT,iBAAmBpT,EAAMoT,gBACpC3P,KAAKzD,MAAMqT,cAAgBrT,EAAMqT,aACjC5P,KAAKzD,MAAMsT,aAAetT,EAAMsT,YAChC7P,KAAKzG,MAAM2W,iBAAmB3W,EAAM2W,gBAEpClQ,KAAK8K,qBAAqBvO,EAAOhD,K,oBAwWrC,WAAU,IAAD,EAMHyG,KAAKzD,MAJPoT,EAFK,EAELA,eACAwB,EAHK,EAGLA,eACAU,EAJK,EAILA,UACAD,EALK,EAKLA,iBAGIE,EAA8B,SAAnBnC,EAKXoC,GACHD,EAAW,GAAK,IAAM9R,KAAK0P,cAAgB,EAAI,GAK5CrO,EAAUyQ,EACZ,CAAE/U,KAAM,EAAGhE,MAAOiH,KAAK0P,kBAAerT,EAAYwV,GAClD,CAAEpc,MAAO,EAAGsD,MAAOiH,KAAK0P,kBAAerT,EAAYwV,GAEvD,OACE,kBAACvI,GAAD,CACEvK,IAAKiB,KAAKgU,kBACV3S,QAASA,EACTmI,cAAeuI,EAAqBH,EACpCnI,YAAa,EAAE,GAAI,IACnBhL,eAAgBuB,KAAKiG,gBACrBtH,qBAAsBqB,KAAK2Q,2BAC3BjN,QACqB,kBAAnByN,GAAyD,gBAAnBA,GAEvCnR,KAAK6S,qB,GAzb4BrR,aAArB4N,GACZ3H,aAAe,CACpBmI,YAAa,IACbD,eAAgB,OAChBzE,qBAAqB,EACrB2E,WAAY,QACZgC,UAAW,GACXD,iBAAkB,EAClBe,aAAc,qBACdxB,eAAgB,YATC/B,GAYZnH,UAAY,CACjBiM,KAAM,OACNC,MAAO,SAibX,IAAMlf,GAASG,IAAWkQ,OAAO,CAC/BwO,gBAAgB,SACX1e,IAAW8Z,oBADD,IAEbkF,OAAQ,KACR7e,cAAe,QAEjBqe,iBAAiB,SACZxe,IAAW8Z,oBADA,IAEdkF,OAAQ,OAEVT,gBAAgB,MACXve,IAAW8Z,oBAEhBwE,KAAM,CACJpe,KAAM,EACN8e,OAAQ,EACRnF,SAAU,UAEZ2D,QAAQ,SACHxd,IAAW8Z,oBADT,IAELkF,OAAQ,Q,OCzhBZ,E,k0BCUO,IAAMC,GACG,EADHA,GAEJ,EAFIA,GAGI,EAGXC,GAAkB,CAGtBC,WAAYjR,IAAUK,KACtB6Q,mBAAoBlR,IAAU1I,KAC9B6Z,kBAAmBnR,IAAUC,OAC7BlC,QAASiC,IAAUY,MAAM,CACvBpH,IAAKwG,IAAUG,OACf1G,KAAMuG,IAAUG,OAChBzG,OAAQsG,IAAUG,OAClBhO,MAAO6N,IAAUG,SAEnBjM,SAAU8L,IAAUK,KACpBlM,QAAS6L,IAAUe,KACnBqQ,UAAWpR,IAAUe,KACrBsQ,WAAYrR,IAAUe,KACtBuK,SAAUtL,IAAUe,KACpBuQ,YAAatR,IAAUe,KACvBwQ,SAAUvR,IAAUC,OACpBuR,OAAQxR,IAAUC,OAClBwR,aAAczR,IAAUG,OACxBuR,cAAe1R,IAAUG,OACzBwR,eAAgB3R,IAAUG,OAC1BmB,sBAAuBtB,IAAUK,KACjCkB,qBAAsBvB,IAAUK,MAG5BuR,GAAoB,CACxBC,iBAAkB7R,IAAUQ,OAC5BsR,cAAe9R,IAAUe,MAQNgR,G,0UAyBnBC,mBAAoB,E,EAEpB1P,eAAgB,E,EAGhB2P,MAAQlB,G,EA8FR5V,eAAiB,YAAyC,IAAvBmH,EAAsB,EAArCpH,YAAeoH,cAC7B,EAAKA,gBAAkBA,IACrBA,EACF,EAAK4P,WAEL,EAAKC,aAGT,EAAK7P,cAAgBA,G,EAGvBjH,qBAAuB,YAAsB,IACnCpF,EADkC,EAAlBiF,YAChBjF,MACR,GAAIA,IAAUP,IAAMI,WAAaG,IAAUP,IAAME,OAE/C,EAAKwc,YAAYrB,SACZ,GAIL9a,KAA2B,YAAhBsB,IAASC,GAAmB9B,IAAMK,OAASL,IAAMG,QAC5D,EAAKoc,QAAUlB,GAGf,EAAKsB,qBACA,GAAIpc,IAAUP,IAAMM,IAAK,CAC9B,IAAMsc,GACH,EAAKN,mBACN,EAAKC,QAAUlB,IACU,OAAzB,EAAKwB,gBACP,EAAKC,yBACDF,GAEF,EAAKrZ,MAAM9E,SAAW,EAAK8E,MAAM9E,Y,EAKvCse,oBAAsB,WACpB,EAAKT,mBAAoB,EACzB,EAAK/Y,MAAMqY,e,2CAlIb,WAAiB,IAAD,OASd,GARI5U,KAAKzD,MAAMwY,aACb/U,KAAKgW,eAAiB9T,YAAW,WAC/B,EAAKwT,YAAYrB,IACjB,EAAK2B,eAAiB,OACrBhW,KAAKzD,MAAMwY,cAEd/U,KAAK0V,YAAYrB,IAEfrU,KAAKzD,MAAMqY,YAAa,CAC1B,IAAMqB,GACHjW,KAAKzD,MAAMwY,cAAgB,IAAM/U,KAAKzD,MAAM0Y,gBAAkB,GACjEjV,KAAKkW,iBAAmBhU,WAAWlC,KAAK+V,oBAAqBE,M,+BAKjE,WAAqB,IAAD,OACdjW,KAAKzD,MAAMyY,cACbhV,KAAK6V,gBACH7V,KAAK6V,iBACL3T,YAAW,WACT,EAAKwT,YAAYrB,IACjB,EAAKwB,gBAAkB,OACtB7V,KAAKzD,MAAMyY,eAEhBhV,KAAK0V,YAAYrB,M,oCAKrB,WAA0B,IAAD,OACvBhS,aAAarC,KAAK6V,iBACd7V,KAAKzD,MAAMyY,cACbhV,KAAK6V,gBAAkB3T,YAAW,WAC5B,EAAKqT,QAAUlB,IACjB,EAAKqB,YAAYrB,IAEnB,EAAKqB,YAAYrB,IACjB,EAAKwB,gBAAkB,OACtB7V,KAAKzD,MAAMyY,gBAEVhV,KAAKuV,QAAUlB,IACjBrU,KAAK0V,YAAYrB,IAEnBrU,KAAK0V,YAAYrB,O,+BAIrB,WACErU,KAAKmW,U,mBAGP,WACEnW,KAAKsV,mBAAoB,EACzBtV,KAAK4F,eAAgB,EACrBvD,aAAarC,KAAKgW,gBAClB3T,aAAarC,KAAK6V,iBAClBxT,aAAarC,KAAKkW,kBAClBlW,KAAK6V,gBAAkB,KACvB7V,KAAKkW,iBAAmB,KACxBlW,KAAKgW,eAAiB,O,yBAIxB,SAAYxF,GACNA,IAAaxQ,KAAKuV,QAIlB/E,IAAa6D,GAEfrU,KAAKzD,MAAMmY,WAAa1U,KAAKzD,MAAMmY,YAC1BlE,IAAa6D,GAEtBrU,KAAKzD,MAAMoY,YAAc3U,KAAKzD,MAAMoY,aAC3BnE,IAAa6D,KAEtBrU,KAAKmW,QACDnW,KAAKuV,QAAUlB,IAEjBrU,KAAKzD,MAAMoY,YAAc3U,KAAKzD,MAAMoY,cAIxC3U,KAAKzD,MAAM6Y,eAAiBpV,KAAKzD,MAAM6Y,cAAcpV,KAAKuV,MAAO/E,GAEjExQ,KAAKuV,MAAQ/E,K,kCA8Cf,WAEExQ,KAAKmW,U,sBAGP,WACMnW,KAAKuV,QAAUlB,IAEjBrU,KAAK0V,YAAYrB,M,uBAIrB,WAEEhS,aAAarC,KAAKkW,kBAClBlW,KAAKkW,iBAAmB,KACpBlW,KAAKuV,QAAUlB,IACjBrU,KAAKoW,sB,oBAIT,WACE,IAAMC,EAAY,CAChB9B,YAAsC,IAA1BvU,KAAKzD,MAAMgY,WACvBC,mBAAoBxU,KAAKzD,MAAMiY,mBAC/BC,kBAAmBzU,KAAKzD,MAAMkY,kBAC9B6B,2BAA4BtW,KAAKzD,MAAM+Z,2BACvC9Q,kBAAmBxF,KAAKzD,MAAMiJ,kBAC9B+Q,oBAAqBvW,KAAKzD,MAAMga,oBAChCC,oBAAqBxW,KAAKzD,MAAMia,oBAChC3B,SAAU7U,KAAKzD,MAAMsY,SACrBjG,SAAU5O,KAAKzD,MAAMqS,SACrBvN,QAASrB,KAAKzD,MAAM8E,SAGtB,OACE,kBAAC,EAAD,KACErM,MAAOgL,KAAKzD,MAAMwS,eAClBpQ,qBACEqB,KAAKzD,MAAM/E,SAAW,KAAOwI,KAAKrB,qBAEpCF,eAAgBuB,KAAKvB,eACrB4C,QAASrB,KAAKzD,MAAM8E,QACpBuD,sBAAuB5E,KAAKzD,MAAMqI,sBAClCC,qBAAsB7E,KAAKzD,MAAMsI,qBACjCiQ,OAAQ9U,KAAKzD,MAAMuY,QACf9U,KAAKzD,MAAM4Y,kBACf,kBAAC5e,EAAA,EAAS8O,KAAV,OAAmBgR,EAAnB,CAA8BrhB,MAAOgL,KAAKzD,MAAMvH,QAC7CgL,KAAKzD,MAAM2C,e,GAvNwBsC,aAAzB6T,GACZoB,gBAAkBnC,GADNe,GAEZqB,kBAAoBxB,GAFRG,GAOZpX,U,SACFiX,IACAZ,IATce,GAYZ5N,aAAe,CACpBwN,eAAgB,IAChBE,iBAAkB,CAChBjP,YAAa,gBCnEnB,IAAMyQ,GAA2BrgB,IAAM2O,YAAW,SAAC1I,EAAOwC,GAAR,OAChD,kBAAC,GAAD,KAAkBA,IAAKA,GAASxC,OAGlCoa,GAAyBlP,aAAe4N,GAAiB5N,aAEzDkP,GAAyB1Y,UAAYoX,GAAiBoB,gBAEvCE,I,+0BCHMC,G,0UAanBC,gCAAkC,WAChC,IAAMC,EAAa1hB,IAAW4R,QAAQ,EAAKzK,MAAMvH,QAAU,GAC3D,OAA6B,MAAtB8hB,EAAW7P,QAAkB,EAAI6P,EAAW7P,S,EAGrDA,QAAU,IAAI1Q,IAASuQ,MAAM,EAAK+P,mC,EAElCE,aAAe,SAACrc,EAAO/D,GACrBJ,IAASygB,OAAO,EAAK/P,QAAS,CAC5BvQ,QAASgE,EACT/D,SAAUA,EACVsgB,OAAQC,KAAOC,MAAMD,KAAOE,MAC5BxgB,iBAAiB,IAChB8W,S,EAGL0H,cAAgB,SAACiC,EAAMC,GACjBA,IAAOjD,GACT,EAAK0C,aAAa,EAAKxa,MAAMsK,cAAe,GAE5CyQ,IAAOjD,IACPiD,IAAOjD,IAEP,EAAK0C,aAAa,EAAKF,kCAAmC,M,oCAI9D,WAAU,IAAD,EACyB7W,KAAKzD,MAD9B,IACCvH,aADD,MACS,GADT,EACgBD,EADhB,iBAEP,OACE,kBAAC,GAAD,OACMA,EADN,CAEEC,MAAO,CACLA,EACA,CACEiS,QAASjH,KAAKiH,UAGlBmO,cAAepV,KAAKoV,gBACnBpV,KAAKzD,MAAM2C,SAAWc,KAAKzD,MAAM2C,SAAW,kBAACmG,EAAA,EAAD,W,GApDP7D,a,k0BAAzBoV,GACZnP,a,SACF4N,GAAiB5N,c,IACpBZ,cAAe,KAHE+P,GAMZ3Y,U,SACFoX,GAAiBoB,iB,IACpBzhB,MAAOsO,IAAUiU,IACjB1Q,cAAevD,IAAUG,S,ICTR+T,G,wLAiBnB,WAAYjb,GAAQ,IAAD,sBACjB,cAAMA,IAQRkb,aAAe,WACR,EAAKC,oBAGV,EAAKxK,SAAS,CACZyK,gBAAiB,CACf1Q,QAAS,EAAK1K,MAAMsK,eAEtB+Q,mBAAoB,CAClB1Q,gBAAiB,EAAK3K,MAAM4K,iBAGhC,EAAK5K,MAAMsb,gBAAkB,EAAKtb,MAAMsb,mBArBvB,EAwBnBH,gBAAkB,kBAChB,EAAKnb,MAAM9E,SACX,EAAK8E,MAAMmY,WACX,EAAKnY,MAAMoY,YACX,EAAKpY,MAAMqY,aA5BM,EA8BnBkD,aAAe,WACb,EAAK5K,SAAS,CACZyK,gBAAiB,KACjBC,mBAAoB,OAEtB,EAAKrb,MAAMwb,gBAAkB,EAAKxb,MAAMwb,kBAnCvB,EAoDnB3C,cAAgB,SAACiC,EAAMC,GACjBA,IAAOjD,GACT,EAAKoD,eAELH,IAAOjD,IACPiD,IAAOjD,IAEP,EAAKyD,gBAzDP,EAAKve,MAAQ,CACXoe,gBAAiB,KACjBC,mBAAoB,MAJL,E,0CAsCnB,WACE,IAAK5X,KAAKzD,MAAM2C,SACd,OAAO,kBAACmG,EAAA,EAAD,MAGT,IAAMzE,EAAQtK,IAAM0I,SAASC,KAAKe,KAAKzD,MAAM2C,UAC7C,OAAO5I,IAAMgL,aAAaV,EAAO,CAC/B5L,MAAOI,IAAW4iB,QAChBpX,EAAMrE,MAAMvH,MACZgL,KAAKzG,MAAMoe,qB,oBAgBjB,WAAU,IAAD,EACyB3X,KAAKzD,MAD9B,IACCvH,aADD,MACS,GADT,EACgBD,EADhB,iBAEC6iB,EAAuB5X,KAAKzG,MAA5Bqe,mBACR,OACE,kBAAC,GAAD,OACM7iB,EADN,CAEEC,MAAO,CAACA,EAAO4iB,GACfxC,cAAepV,KAAKoV,gBACnBpV,KAAKiY,sB,GAxFkCzW,aAA3BgW,GACZ/P,a,SACF4N,GAAiB5N,c,IACpBZ,cAAe,IACfmO,cAAe,IACf7N,cAAe,UALEqQ,GAQZvZ,U,SACFoX,GAAiBoB,iB,IACpB5P,cAAevD,IAAUG,OACzB0D,cAAe7D,IAAUC,OACzBvO,MAAOsO,IAAUiU,IACjBM,eAAgBvU,IAAUe,KAC1B0T,eAAgBzU,IAAUe,Q,qDChB9B,SAAS6T,IAeP,OAdAA,EAAWze,OAAO0e,QAAU,SAAUre,GACpC,IAAK,IAAIJ,EAAI,EAAGA,EAAI0I,UAAUzI,OAAQD,IAAK,CACzC,IAAI0e,EAAShW,UAAU1I,GAEvB,IAAK,IAAIkD,KAAOwb,EACV3e,OAAOoI,UAAUwW,eAAe5d,KAAK2d,EAAQxb,KAC/C9C,EAAO8C,GAAOwb,EAAOxb,IAK3B,OAAO9C,IAGO6H,MAAM3B,KAAMoC,WAG9B,SAASkW,EAAeC,EAAUC,GAChCD,EAAS1W,UAAYpI,OAAO6L,OAAOkT,EAAW3W,WAC9C0W,EAAS1W,UAAUxB,YAAckY,EACjCA,EAASE,UAAYD,EAGvB,SAASE,EAAuBjX,GAC9B,QAAa,IAATA,EACF,MAAM,IAAIkX,eAAe,6DAG3B,OAAOlX,EAuCT,IAwCImX,EAxCAC,EA1ByB,oBAAlBpf,OAAO0e,OACP,SAAgBre,GACvB,QAAeuC,IAAXvC,GAAmC,OAAXA,EAC1B,MAAM,IAAIgf,UAAU,8CAKtB,IAFA,IAAIC,EAAStf,OAAOK,GAEXkf,EAAQ,EAAGA,EAAQ5W,UAAUzI,OAAQqf,IAAS,CACrD,IAAIZ,EAAShW,UAAU4W,GAEvB,QAAe3c,IAAX+b,GAAmC,OAAXA,EAC1B,IAAK,IAAIa,KAAWb,EACdA,EAAOC,eAAeY,KACxBF,EAAOE,GAAWb,EAAOa,IAMjC,OAAOF,GAGAtf,OAAO0e,OAKde,EAAkB,CAAC,GAAI,SAAU,MAAO,KAAM,KAAM,KACpDC,EAAmC,qBAAbC,SAA2B,CACnDpkB,MAAO,IACLokB,SAASC,cAAc,OAEvBC,EAAQ9N,KAAK8N,MACbC,EAAM/N,KAAK+N,IACXC,EAAMC,KAAKD,IAUf,SAASE,EAASC,EAAK5f,GAMrB,IALA,IAAI6f,EACAC,EACAC,EAAY/f,EAAS,GAAGggB,cAAgBhgB,EAASigB,MAAM,GACvDtgB,EAAI,EAEDA,EAAIwf,EAAgBvf,QAAQ,CAIjC,IAFAkgB,GADAD,EAASV,EAAgBxf,IACTkgB,EAASE,EAAY/f,KAEzB4f,EACV,OAAOE,EAGTngB,KAWFkf,EAFoB,qBAAXlX,OAEH,GAEAA,OAGR,IAAIuY,EAAwBP,EAASP,EAAankB,MAAO,eACrDklB,OAAgD7d,IAA1B4d,EAgB1B,IAOIE,EAtBJ,WACE,IAAKD,EACH,OAAO,EAGT,IAAIE,EAAW,GACXC,EAAczB,EAAI0B,KAAO1B,EAAI0B,IAAIC,SAMrC,MALA,CAAC,OAAQ,eAAgB,QAAS,QAAS,cAAe,QAAQ5d,SAAQ,SAAU6d,GAGlF,OAAOJ,EAASI,IAAOH,GAAczB,EAAI0B,IAAIC,SAAS,eAAgBC,MAEjEJ,EAUcK,GAGnBC,EAAgB,iBAAkB9B,EAClC+B,OAA2Dte,IAAlCqd,EAASd,EAAK,gBACvCgC,EAAqBF,GAHN,wCAGoCG,KAAKC,UAAUC,WAkBlEC,EAAW,CAAC,IAAK,KACjBC,EAAkB,CAAC,UAAW,WASlC,SAASC,EAAKvB,EAAKwB,EAAU9L,GAC3B,IAAI3V,EAEJ,GAAKigB,EAIL,GAAIA,EAAIhd,QACNgd,EAAIhd,QAAQwe,EAAU9L,QACjB,QAAmBhT,IAAfsd,EAAIhgB,OAGb,IAFAD,EAAI,EAEGA,EAAIigB,EAAIhgB,QACbwhB,EAAS1gB,KAAK4U,EAASsK,EAAIjgB,GAAIA,EAAGigB,GAClCjgB,SAGF,IAAKA,KAAKigB,EACRA,EAAItB,eAAe3e,IAAMyhB,EAAS1gB,KAAK4U,EAASsK,EAAIjgB,GAAIA,EAAGigB,GAcjE,SAASyB,EAASZ,EAAKa,GACrB,MArIkB,oBAqIPb,EACFA,EAAI7Y,MAAM0Z,GAAOA,EAAK,SAAkBhf,EAAWgf,GAGrDb,EAUT,SAASc,EAAMC,EAAKC,GAClB,OAAOD,EAAInW,QAAQoW,IAAS,EAgD9B,IAAIC,EAEJ,WACE,SAASA,EAAYC,EAAShhB,GAC5BsF,KAAK0b,QAAUA,EACf1b,KAAK2b,IAAIjhB,GASX,IAAIkhB,EAASH,EAAY5Z,UA4FzB,OA1FA+Z,EAAOD,IAAM,SAAajhB,GAxJD,YA0JnBA,IACFA,EAAQsF,KAAK6b,WAGX3B,GAAuBla,KAAK0b,QAAQI,QAAQ9mB,OAASmlB,EAAiBzf,KACxEsF,KAAK0b,QAAQI,QAAQ9mB,MAAMilB,GAAyBvf,GAGtDsF,KAAK+b,QAAUrhB,EAAMshB,cAAcC,QAQrCL,EAAOM,OAAS,WACdlc,KAAK2b,IAAI3b,KAAK0b,QAAQpJ,QAAQ6J,cAShCP,EAAOC,QAAU,WACf,IAAIE,EAAU,GAMd,OALAb,EAAKlb,KAAK0b,QAAQU,aAAa,SAAUC,GACnCjB,EAASiB,EAAW/J,QAAQgK,OAAQ,CAACD,MACvCN,EAAUA,EAAQQ,OAAOF,EAAWG,sBAtF5C,SAA2BT,GAEzB,GAAIT,EAAMS,EAhGY,QAiGpB,MAjGoB,OAoGtB,IAAIU,EAAUnB,EAAMS,EAnGG,SAoGnBW,EAAUpB,EAAMS,EAnGG,SAwGvB,OAAIU,GAAWC,EA1GO,OA+GlBD,GAAWC,EACND,EA/Gc,QACA,QAkHnBnB,EAAMS,EAtHoB,+BADR,OA0LbY,CAAkBZ,EAAQa,KAAK,OASxChB,EAAOiB,gBAAkB,SAAyBC,GAChD,IAAIC,EAAWD,EAAMC,SACjBzlB,EAAYwlB,EAAME,gBAEtB,GAAIhd,KAAK0b,QAAQuB,QAAQC,UACvBH,EAASI,qBADX,CAKA,IAAIpB,EAAU/b,KAAK+b,QACfqB,EAAU9B,EAAMS,EA1MA,UA0MgC5B,EAAkC,KAClFuC,EAAUpB,EAAMS,EAzMC,WAyMgC5B,EAzMhC,SA0MjBsC,EAAUnB,EAAMS,EA3MC,WA2MgC5B,EA3MhC,SA6MrB,GAAIiD,EAAS,CAEX,IAAIC,EAAyC,IAA1BP,EAAMQ,SAAS3jB,OAC9B4jB,EAAgBT,EAAMU,SAAW,EACjCC,EAAiBX,EAAMY,UAAY,IAEvC,GAAIL,GAAgBE,GAAiBE,EACnC,OAIJ,IAAIhB,IAAWC,EAKf,OAAIU,GAAWV,GAvMQiB,EAuMGrmB,GAAoCmlB,GAtMzCmB,GAsMoDtmB,EAChE0I,KAAK6d,WAAWd,QADzB,IAWFnB,EAAOiC,WAAa,SAAoBd,GACtC/c,KAAK0b,QAAQuB,QAAQC,WAAY,EACjCH,EAASI,kBAGJ1B,EAxGT,GAmHA,SAASqC,EAAUljB,EAAMmjB,GACvB,KAAOnjB,GAAM,CACX,GAAIA,IAASmjB,EACX,OAAO,EAGTnjB,EAAOA,EAAKojB,WAGd,OAAO,EAUT,SAASC,EAAUX,GACjB,IAAIY,EAAiBZ,EAAS3jB,OAE9B,GAAuB,IAAnBukB,EACF,MAAO,CACLrP,EAAGyK,EAAMgE,EAAS,GAAGa,SACrBC,EAAG9E,EAAMgE,EAAS,GAAGe,UAQzB,IAJA,IAAIxP,EAAI,EACJuP,EAAI,EACJ1kB,EAAI,EAEDA,EAAIwkB,GACTrP,GAAKyO,EAAS5jB,GAAGykB,QACjBC,GAAKd,EAAS5jB,GAAG2kB,QACjB3kB,IAGF,MAAO,CACLmV,EAAGyK,EAAMzK,EAAIqP,GACbE,EAAG9E,EAAM8E,EAAIF,IAWjB,SAASI,EAAqBxB,GAM5B,IAHA,IAAIQ,EAAW,GACX5jB,EAAI,EAEDA,EAAIojB,EAAMQ,SAAS3jB,QACxB2jB,EAAS5jB,GAAK,CACZykB,QAAS7E,EAAMwD,EAAMQ,SAAS5jB,GAAGykB,SACjCE,QAAS/E,EAAMwD,EAAMQ,SAAS5jB,GAAG2kB,UAEnC3kB,IAGF,MAAO,CACL6kB,UAAW/E,IACX8D,SAAUA,EACVkB,OAAQP,EAAUX,GAClBmB,OAAQ3B,EAAM2B,OACdC,OAAQ5B,EAAM4B,QAalB,SAASC,EAAYC,EAAIC,EAAItiB,GACtBA,IACHA,EAAQye,GAGV,IAAInM,EAAIgQ,EAAGtiB,EAAM,IAAMqiB,EAAGriB,EAAM,IAC5B6hB,EAAIS,EAAGtiB,EAAM,IAAMqiB,EAAGriB,EAAM,IAChC,OAAOiP,KAAKsT,KAAKjQ,EAAIA,EAAIuP,EAAIA,GAY/B,SAASW,EAASH,EAAIC,EAAItiB,GACnBA,IACHA,EAAQye,GAGV,IAAInM,EAAIgQ,EAAGtiB,EAAM,IAAMqiB,EAAGriB,EAAM,IAC5B6hB,EAAIS,EAAGtiB,EAAM,IAAMqiB,EAAGriB,EAAM,IAChC,OAA0B,IAAnBiP,KAAKwT,MAAMZ,EAAGvP,GAAWrD,KAAKyT,GAWvC,SAAS,EAAapQ,EAAGuP,GACvB,OAAIvP,IAAMuP,EAjWS,EAqWf7E,EAAI1K,IAAM0K,EAAI6E,GACTvP,EAAI,EArWM,EACC,EAuWbuP,EAAI,EAtWM,EACE,GAuYrB,SAASc,EAAYxB,EAAW7O,EAAGuP,GACjC,MAAO,CACLvP,EAAGA,EAAI6O,GAAa,EACpBU,EAAGA,EAAIV,GAAa,GA0ExB,SAASyB,EAAiBzD,EAASoB,GACjC,IAAIG,EAAUvB,EAAQuB,QAClBK,EAAWR,EAAMQ,SACjBY,EAAiBZ,EAAS3jB,OAEzBsjB,EAAQmC,aACXnC,EAAQmC,WAAad,EAAqBxB,IAIxCoB,EAAiB,IAAMjB,EAAQoC,cACjCpC,EAAQoC,cAAgBf,EAAqBxB,GACjB,IAAnBoB,IACTjB,EAAQoC,eAAgB,GAG1B,IAAID,EAAanC,EAAQmC,WACrBC,EAAgBpC,EAAQoC,cACxBC,EAAeD,EAAgBA,EAAcb,OAASY,EAAWZ,OACjEA,EAAS1B,EAAM0B,OAASP,EAAUX,GACtCR,EAAMyB,UAAY/E,IAClBsD,EAAMY,UAAYZ,EAAMyB,UAAYa,EAAWb,UAC/CzB,EAAMyC,MAAQR,EAASO,EAAcd,GACrC1B,EAAMU,SAAWmB,EAAYW,EAAcd,GAnI7C,SAAwBvB,EAASH,GAC/B,IAAI0B,EAAS1B,EAAM0B,OAGfgB,EAASvC,EAAQwC,aAAe,GAChCC,EAAYzC,EAAQyC,WAAa,GACjCC,EAAY1C,EAAQ0C,WAAa,GAtXrB,IAwXZ7C,EAAM8C,WAtXI,IAsXyBD,EAAUC,YAC/CF,EAAYzC,EAAQyC,UAAY,CAC9B7Q,EAAG8Q,EAAUlB,QAAU,EACvBL,EAAGuB,EAAUjB,QAAU,GAEzBc,EAASvC,EAAQwC,YAAc,CAC7B5Q,EAAG2P,EAAO3P,EACVuP,EAAGI,EAAOJ,IAIdtB,EAAM2B,OAASiB,EAAU7Q,GAAK2P,EAAO3P,EAAI2Q,EAAO3Q,GAChDiO,EAAM4B,OAASgB,EAAUtB,GAAKI,EAAOJ,EAAIoB,EAAOpB,GAgHhDyB,CAAe5C,EAASH,GACxBA,EAAME,gBAAkB,EAAaF,EAAM2B,OAAQ3B,EAAM4B,QACzD,IAvFgBhR,EAAOoS,EAuFnBC,EAAkBb,EAAYpC,EAAMY,UAAWZ,EAAM2B,OAAQ3B,EAAM4B,QACvE5B,EAAMkD,iBAAmBD,EAAgBlR,EACzCiO,EAAMmD,iBAAmBF,EAAgB3B,EACzCtB,EAAMiD,gBAAkBxG,EAAIwG,EAAgBlR,GAAK0K,EAAIwG,EAAgB3B,GAAK2B,EAAgBlR,EAAIkR,EAAgB3B,EAC9GtB,EAAMoD,MAAQb,GA3FE3R,EA2FuB2R,EAAc/B,SA1F9CqB,GADgBmB,EA2FwCxC,GA1FxC,GAAIwC,EAAI,GAAI7E,GAAmB0D,EAAYjR,EAAM,GAAIA,EAAM,GAAIuN,IA0FX,EAC3E6B,EAAMqD,SAAWd,EAhFnB,SAAqB3R,EAAOoS,GAC1B,OAAOf,EAASe,EAAI,GAAIA,EAAI,GAAI7E,GAAmB8D,EAASrR,EAAM,GAAIA,EAAM,GAAIuN,GA+E/CmF,CAAYf,EAAc/B,SAAUA,GAAY,EACjFR,EAAM/S,YAAekT,EAAQ0C,UAAoC7C,EAAMQ,SAAS3jB,OAASsjB,EAAQ0C,UAAU5V,YAAc+S,EAAMQ,SAAS3jB,OAASsjB,EAAQ0C,UAAU5V,YAA1H+S,EAAMQ,SAAS3jB,OAtE1D,SAAkCsjB,EAASH,GACzC,IAEIvP,EACAd,EACA4T,EACA/oB,EALAgpB,EAAOrD,EAAQsD,cAAgBzD,EAC/BY,EAAYZ,EAAMyB,UAAY+B,EAAK/B,UAMvC,GA3biB,IA2bbzB,EAAM8C,YAA+BlC,EA/bpB,SA+bsErhB,IAAlBikB,EAAK/S,UAAyB,CACrG,IAAIkR,EAAS3B,EAAM2B,OAAS6B,EAAK7B,OAC7BC,EAAS5B,EAAM4B,OAAS4B,EAAK5B,OAC7B8B,EAAItB,EAAYxB,EAAWe,EAAQC,GACvCjS,EAAY+T,EAAE3R,EACdwR,EAAYG,EAAEpC,EACd7Q,EAAWgM,EAAIiH,EAAE3R,GAAK0K,EAAIiH,EAAEpC,GAAKoC,EAAE3R,EAAI2R,EAAEpC,EACzC9mB,EAAY,EAAamnB,EAAQC,GACjCzB,EAAQsD,aAAezD,OAGvBvP,EAAW+S,EAAK/S,SAChBd,EAAY6T,EAAK7T,UACjB4T,EAAYC,EAAKD,UACjB/oB,EAAYgpB,EAAKhpB,UAGnBwlB,EAAMvP,SAAWA,EACjBuP,EAAMrQ,UAAYA,EAClBqQ,EAAMuD,UAAYA,EAClBvD,EAAMxlB,UAAYA,EA2ClBmpB,CAAyBxD,EAASH,GAElC,IAEI4D,EAFA5mB,EAAS4hB,EAAQI,QACjBiB,EAAWD,EAAMC,SAWjBe,EAPF4C,EADE3D,EAAS4D,aACM5D,EAAS4D,eAAe,GAChC5D,EAAS6D,KACD7D,EAAS6D,KAAK,GAEd7D,EAASjjB,OAGEA,KAC5BA,EAAS4mB,GAGX5D,EAAMhjB,OAASA,EAWjB,SAAS+mB,EAAanF,EAASkE,EAAW9C,GACxC,IAAIgE,EAAchE,EAAMQ,SAAS3jB,OAC7BonB,EAAqBjE,EAAMkE,gBAAgBrnB,OAC3CsnB,EA7hBY,EA6hBFrB,GAA2BkB,EAAcC,IAAuB,EAC1EG,EAAsB,GAAZtB,GAA0CkB,EAAcC,IAAuB,EAC7FjE,EAAMmE,UAAYA,EAClBnE,EAAMoE,UAAYA,EAEdD,IACFvF,EAAQuB,QAAU,IAKpBH,EAAM8C,UAAYA,EAElBT,EAAiBzD,EAASoB,GAE1BpB,EAAQyF,KAAK,eAAgBrE,GAC7BpB,EAAQ0F,UAAUtE,GAClBpB,EAAQuB,QAAQ0C,UAAY7C,EAS9B,SAASuE,EAAS9F,GAChB,OAAOA,EAAIU,OAAOqF,MAAM,QAW1B,SAASC,EAAkBznB,EAAQ0nB,EAAOC,GACxCvG,EAAKmG,EAASG,IAAQ,SAAUxgB,GAC9BlH,EAAO4nB,iBAAiB1gB,EAAMygB,GAAS,MAY3C,SAASE,EAAqB7nB,EAAQ0nB,EAAOC,GAC3CvG,EAAKmG,EAASG,IAAQ,SAAUxgB,GAC9BlH,EAAO8nB,oBAAoB5gB,EAAMygB,GAAS,MAU9C,SAASI,EAAoB/F,GAC3B,IAAIgG,EAAMhG,EAAQiG,eAAiBjG,EACnC,OAAOgG,EAAIE,aAAeF,EAAIG,cAAgBvgB,OAYhD,IAAIwgB,EAEJ,WACE,SAASA,EAAMxG,EAASyG,GACtB,IAAI1gB,EAAOzB,KACXA,KAAK0b,QAAUA,EACf1b,KAAKmiB,SAAWA,EAChBniB,KAAK8b,QAAUJ,EAAQI,QACvB9b,KAAKlG,OAAS4hB,EAAQpJ,QAAQ8P,YAG9BpiB,KAAKqiB,WAAa,SAAUC,GACtBlH,EAASM,EAAQpJ,QAAQgK,OAAQ,CAACZ,KACpCja,EAAKggB,QAAQa,IAIjBtiB,KAAKuiB,OASP,IAAI3G,EAASsG,EAAMrgB,UA0BnB,OAxBA+Z,EAAO6F,QAAU,aAOjB7F,EAAO2G,KAAO,WACZviB,KAAKwiB,MAAQjB,EAAkBvhB,KAAK8b,QAAS9b,KAAKwiB,KAAMxiB,KAAKqiB,YAC7DriB,KAAKyiB,UAAYlB,EAAkBvhB,KAAKlG,OAAQkG,KAAKyiB,SAAUziB,KAAKqiB,YACpEriB,KAAK0iB,OAASnB,EAAkBM,EAAoB7hB,KAAK8b,SAAU9b,KAAK0iB,MAAO1iB,KAAKqiB,aAQtFzG,EAAO+G,QAAU,WACf3iB,KAAKwiB,MAAQb,EAAqB3hB,KAAK8b,QAAS9b,KAAKwiB,KAAMxiB,KAAKqiB,YAChEriB,KAAKyiB,UAAYd,EAAqB3hB,KAAKlG,OAAQkG,KAAKyiB,SAAUziB,KAAKqiB,YACvEriB,KAAK0iB,OAASf,EAAqBE,EAAoB7hB,KAAK8b,SAAU9b,KAAK0iB,MAAO1iB,KAAKqiB,aAGlFH,EAlDT,GA6DA,SAASU,EAAQC,EAAKrH,EAAMsH,GAC1B,GAAID,EAAIzd,UAAY0d,EAClB,OAAOD,EAAIzd,QAAQoW,GAInB,IAFA,IAAI9hB,EAAI,EAEDA,EAAImpB,EAAIlpB,QAAQ,CACrB,GAAImpB,GAAaD,EAAInpB,GAAGopB,IAActH,IAASsH,GAAaD,EAAInpB,KAAO8hB,EAErE,OAAO9hB,EAGTA,IAGF,OAAQ,EAIZ,IAAIqpB,EAAoB,CACtBC,YA9rBgB,EA+rBhBC,YA9rBe,EA+rBfC,UA9rBc,EA+rBdC,cA9rBiB,EA+rBjBC,WA/rBiB,GAksBfC,EAAyB,CAC3BC,EA3sBqB,QA4sBrBC,EA3sBmB,MA4sBnBC,EA3sBqB,QA4sBrBC,EA3sBsB,UA8sBpBC,EAAyB,cACzBC,EAAwB,sCAExB/K,EAAIgL,iBAAmBhL,EAAIiL,eAC7BH,EAAyB,gBACzBC,EAAwB,6CAU1B,IAAIG,EAEJ,SAAUC,GAGR,SAASD,IACP,IAAIE,EAEAC,EAAQH,EAAkBjiB,UAK9B,OAJAoiB,EAAMzB,KAAOkB,EACbO,EAAMvB,MAAQiB,GACdK,EAAQD,EAAOpiB,MAAM3B,KAAMoC,YAAcpC,MACnCkkB,MAAQF,EAAMtI,QAAQuB,QAAQpkB,cAAgB,GAC7CmrB,EAkDT,OA5DA1L,EAAewL,EAAmBC,GAmBrBD,EAAkBjiB,UAExB4f,QAAU,SAAiBa,GAChC,IAAI4B,EAAQlkB,KAAKkkB,MACbC,GAAgB,EAChBC,EAAsB9B,EAAGthB,KAAKgb,cAAcqI,QAAQ,KAAM,IAC1DzE,EAAYmD,EAAkBqB,GAC9BE,EAAcjB,EAAuBf,EAAGgC,cAAgBhC,EAAGgC,YAC3DC,EA9vBe,UA8vBLD,EAEVE,EAAa5B,EAAQsB,EAAO5B,EAAGmC,UAAW,aA3vBhC,EA6vBV7E,IAA0C,IAAd0C,EAAGoC,QAAgBH,GAC7CC,EAAa,IACfN,EAAM/iB,KAAKmhB,GACXkC,EAAaN,EAAMvqB,OAAS,GAET,GAAZimB,IACTuE,GAAgB,GAIdK,EAAa,IAKjBN,EAAMM,GAAclC,EACpBtiB,KAAKmiB,SAASniB,KAAK0b,QAASkE,EAAW,CACrCtC,SAAU4G,EACVlD,gBAAiB,CAACsB,GAClBgC,YAAaA,EACbvH,SAAUuF,IAGR6B,GAEFD,EAAMS,OAAOH,EAAY,KAItBV,EA7DT,CA8DE5B,GAQF,SAAShhB,EAAQyY,GACf,OAAOzc,MAAM2E,UAAUmY,MAAMvf,KAAKkf,EAAK,GAYzC,SAASiL,EAAY/B,EAAKjmB,EAAKioB,GAK7B,IAJA,IAAIC,EAAU,GACVC,EAAS,GACTrrB,EAAI,EAEDA,EAAImpB,EAAIlpB,QAAQ,CACrB,IAAI6gB,EAAM5d,EAAMimB,EAAInpB,GAAGkD,GAAOimB,EAAInpB,GAE9BkpB,EAAQmC,EAAQvK,GAAO,GACzBsK,EAAQ3jB,KAAK0hB,EAAInpB,IAGnBqrB,EAAOrrB,GAAK8gB,EACZ9gB,IAaF,OAVImrB,IAIAC,EAHGloB,EAGOkoB,EAAQD,MAAK,SAAUG,EAAGC,GAClC,OAAOD,EAAEpoB,GAAOqoB,EAAEroB,MAHVkoB,EAAQD,QAQfC,EAGT,IAAII,EAAkB,CACpBC,WA90BgB,EA+0BhBC,UA90Be,EA+0BfC,SA90Bc,EA+0BdC,YA90BiB,GAw1BfC,EAEJ,SAAUxB,GAGR,SAASwB,IACP,IAAIvB,EAMJ,OAJAuB,EAAW1jB,UAAU4gB,SAhBC,6CAiBtBuB,EAAQD,EAAOpiB,MAAM3B,KAAMoC,YAAcpC,MACnCwlB,UAAY,GAEXxB,EAqBT,OA9BA1L,EAAeiN,EAAYxB,GAYdwB,EAAW1jB,UAEjB4f,QAAU,SAAiBa,GAChC,IAAIthB,EAAOkkB,EAAgB5C,EAAGthB,MAC1BykB,EAAUC,EAAWjrB,KAAKuF,KAAMsiB,EAAIthB,GAEnCykB,GAILzlB,KAAKmiB,SAASniB,KAAK0b,QAAS1a,EAAM,CAChCsc,SAAUmI,EAAQ,GAClBzE,gBAAiByE,EAAQ,GACzBnB,YA53BiB,QA63BjBvH,SAAUuF,KAIPiD,EA/BT,CAgCErD,GAEF,SAASwD,EAAWpD,EAAIthB,GACtB,IAQItH,EACAisB,EATAC,EAAa1kB,EAAQohB,EAAGmD,SACxBD,EAAYxlB,KAAKwlB,UAErB,GAAW,EAAPxkB,GAA2D,IAAtB4kB,EAAWjsB,OAElD,OADA6rB,EAAUI,EAAW,GAAGC,aAAc,EAC/B,CAACD,EAAYA,GAKtB,IAAIE,EAAiB5kB,EAAQohB,EAAGwD,gBAC5BC,EAAuB,GACvBjsB,EAASkG,KAAKlG,OAMlB,GAJA6rB,EAAgBC,EAAWvoB,QAAO,SAAU2oB,GAC1C,OAAOlI,EAAUkI,EAAMlsB,OAAQA,MA/4BjB,IAk5BZkH,EAGF,IAFAtH,EAAI,EAEGA,EAAIisB,EAAchsB,QACvB6rB,EAAUG,EAAcjsB,GAAGmsB,aAAc,EACzCnsB,IAOJ,IAFAA,EAAI,EAEGA,EAAIosB,EAAensB,QACpB6rB,EAAUM,EAAepsB,GAAGmsB,aAC9BE,EAAqB5kB,KAAK2kB,EAAepsB,IAIhC,GAAPsH,UACKwkB,EAAUM,EAAepsB,GAAGmsB,YAGrCnsB,IAGF,OAAKqsB,EAAqBpsB,OAInB,CACPirB,EAAYe,EAAcpJ,OAAOwJ,GAAuB,cAAc,GAAOA,QAL7E,EAQF,IAAIE,EAAkB,CACpBC,UAp7BgB,EAq7BhBC,UAp7Be,EAq7BfC,QAp7Bc,GA+7BZC,GAEJ,SAAUtC,GAGR,SAASsC,IACP,IAAIrC,EAEAC,EAAQoC,EAAWxkB,UAMvB,OALAoiB,EAAMzB,KAlBiB,YAmBvByB,EAAMvB,MAlBgB,qBAmBtBsB,EAAQD,EAAOpiB,MAAM3B,KAAMoC,YAAcpC,MACnCsmB,SAAU,EAETtC,EAuCT,OAlDA1L,EAAe+N,EAAYtC,GAoBdsC,EAAWxkB,UAEjB4f,QAAU,SAAiBa,GAChC,IAAI1C,EAAYqG,EAAgB3D,EAAGthB,MA39BrB,EA69BV4e,GAAyC,IAAd0C,EAAGoC,SAChC1kB,KAAKsmB,SAAU,GA79BJ,EAg+BT1G,GAAuC,IAAb0C,EAAGiE,QAC/B3G,EAh+BU,GAo+BP5f,KAAKsmB,UAp+BE,EAw+BR1G,IACF5f,KAAKsmB,SAAU,GAGjBtmB,KAAKmiB,SAASniB,KAAK0b,QAASkE,EAAW,CACrCtC,SAAU,CAACgF,GACXtB,gBAAiB,CAACsB,GAClBgC,YAp/BiB,QAq/BjBvH,SAAUuF,MAIP+D,EAnDT,CAoDEnE,GAgBF,SAASsE,GAAaC,GACpB,IACIT,EADwBS,EAAUzF,gBACJ,GAElC,GAAIgF,EAAMH,aAAe7lB,KAAK0mB,aAAc,CAC1C,IAAIC,EAAY,CACd9X,EAAGmX,EAAM7H,QACTC,EAAG4H,EAAM3H,SAEPuI,EAAM5mB,KAAK6mB,YACf7mB,KAAK6mB,YAAY1lB,KAAKwlB,GAUtBzkB,YARsB,WACpB,IAAIxI,EAAIktB,EAAIxhB,QAAQuhB,GAEhBjtB,GAAK,GACPktB,EAAIjC,OAAOjrB,EAAG,KAnBF,OA2BpB,SAASotB,GAAclH,EAAW6G,GA/hChB,EAgiCZ7G,GACF5f,KAAK0mB,aAAeD,EAAUzF,gBAAgB,GAAG6E,WACjDW,GAAa/rB,KAAKuF,KAAMymB,IACH,GAAZ7G,GACT4G,GAAa/rB,KAAKuF,KAAMymB,GAI5B,SAASM,GAAiBN,GAIxB,IAHA,IAAI5X,EAAI4X,EAAU1J,SAASoB,QACvBC,EAAIqI,EAAU1J,SAASsB,QAElB3kB,EAAI,EAAGA,EAAIsG,KAAK6mB,YAAYltB,OAAQD,IAAK,CAChD,IAAIstB,EAAIhnB,KAAK6mB,YAAYntB,GACrButB,EAAKzb,KAAK+N,IAAI1K,EAAImY,EAAEnY,GACpBqY,EAAK1b,KAAK+N,IAAI6E,EAAI4I,EAAE5I,GAExB,GAAI6I,GA5Ca,IA4CWC,GA5CX,GA6Cf,OAAO,EAIX,OAAO,EAGT,IAAIC,GAEJ,WA0DE,OAvDA,SAAUpD,GAGR,SAASoD,EAAgBC,EAAUjF,GACjC,IAAI6B,EA0BJ,OAxBAA,EAAQD,EAAOtpB,KAAKuF,KAAMonB,EAAUjF,IAAaniB,MAE3CyhB,QAAU,SAAU/F,EAAS2L,EAAYC,GAC7C,IAAI/C,EA5kCW,UA4kCD+C,EAAUhD,YACpBiD,EA3kCW,UA2kCDD,EAAUhD,YAExB,KAAIiD,GAAWD,EAAUE,oBAAsBF,EAAUE,mBAAmBC,kBAA5E,CAKA,GAAIlD,EACFuC,GAAcrsB,KAAKie,EAAuBA,EAAuBsL,IAASqD,EAAYC,QACjF,GAAIC,GAAWR,GAAiBtsB,KAAKie,EAAuBA,EAAuBsL,IAASsD,GACjG,OAGFtD,EAAM7B,SAASzG,EAAS2L,EAAYC,KAGtCtD,EAAMgC,MAAQ,IAAIT,EAAWvB,EAAMtI,QAASsI,EAAMvC,SAClDuC,EAAM0D,MAAQ,IAAIrB,GAAWrC,EAAMtI,QAASsI,EAAMvC,SAClDuC,EAAM0C,aAAe,KACrB1C,EAAM6C,YAAc,GACb7C,EAsBT,OAnDA1L,EAAe6O,EAAiBpD,GAwCnBoD,EAAgBtlB,UAMtB8gB,QAAU,WACf3iB,KAAKgmB,MAAMrD,UACX3iB,KAAK0nB,MAAM/E,WAGNwE,EApDT,CAqDEjF,GAxDJ,GAoGA,SAASyF,GAAeC,EAAKC,EAAIxY,GAC/B,QAAInS,MAAMC,QAAQyqB,KAChB1M,EAAK0M,EAAKvY,EAAQwY,GAAKxY,IAChB,GAMX,IAaIyY,GAAY,EAYhB,SAASC,GAA6BC,EAAiB3L,GACrD,IAAIX,EAAUW,EAAWX,QAEzB,OAAIA,EACKA,EAAQxhB,IAAI8tB,GAGdA,EAUT,SAASC,GAAS1uB,GAChB,OAtCoB,GAsChBA,EACK,SAzCO,EA0CLA,EACF,MA5CS,EA6CPA,EACF,OA/CO,EAgDLA,EACF,QAGF,GAwCT,IAAI2uB,GAEJ,WACE,SAASA,EAAW5V,QACF,IAAZA,IACFA,EAAU,IAGZtS,KAAKsS,QAAU4F,EAAS,CACtBoE,QAAQ,GACPhK,GACHtS,KAAKH,GAzFAioB,KA0FL9nB,KAAK0b,QAAU,KAEf1b,KAAKzG,MA3GY,EA4GjByG,KAAKmoB,aAAe,GACpBnoB,KAAKooB,YAAc,GAUrB,IAAIxM,EAASsM,EAAWrmB,UAwPxB,OAtPA+Z,EAAOD,IAAM,SAAarJ,GAIxB,OAHAuG,EAAS7Y,KAAKsS,QAASA,GAEvBtS,KAAK0b,SAAW1b,KAAK0b,QAAQS,YAAYD,SAClClc,MAUT4b,EAAOyM,cAAgB,SAAuBL,GAC5C,GAAIL,GAAeK,EAAiB,gBAAiBhoB,MACnD,OAAOA,KAGT,IAAImoB,EAAenoB,KAAKmoB,aAQxB,OALKA,GAFLH,EAAkBD,GAA6BC,EAAiBhoB,OAE9BH,MAChCsoB,EAAaH,EAAgBnoB,IAAMmoB,EACnCA,EAAgBK,cAAcroB,OAGzBA,MAUT4b,EAAO0M,kBAAoB,SAA2BN,GACpD,OAAIL,GAAeK,EAAiB,oBAAqBhoB,QAIzDgoB,EAAkBD,GAA6BC,EAAiBhoB,aACzDA,KAAKmoB,aAAaH,EAAgBnoB,KAJhCG,MAeX4b,EAAO2M,eAAiB,SAAwBP,GAC9C,GAAIL,GAAeK,EAAiB,iBAAkBhoB,MACpD,OAAOA,KAGT,IAAIooB,EAAcpoB,KAAKooB,YAQvB,OAL+C,IAA3CxF,EAAQwF,EAFZJ,EAAkBD,GAA6BC,EAAiBhoB,SAG9DooB,EAAYjnB,KAAK6mB,GACjBA,EAAgBO,eAAevoB,OAG1BA,MAUT4b,EAAO4M,mBAAqB,SAA4BR,GACtD,GAAIL,GAAeK,EAAiB,qBAAsBhoB,MACxD,OAAOA,KAGTgoB,EAAkBD,GAA6BC,EAAiBhoB,MAChE,IAAIgZ,EAAQ4J,EAAQ5iB,KAAKooB,YAAaJ,GAMtC,OAJIhP,GAAS,GACXhZ,KAAKooB,YAAYzD,OAAO3L,EAAO,GAG1BhZ,MAST4b,EAAO6M,mBAAqB,WAC1B,OAAOzoB,KAAKooB,YAAYzuB,OAAS,GAUnCiiB,EAAO8M,iBAAmB,SAA0BV,GAClD,QAAShoB,KAAKmoB,aAAaH,EAAgBnoB,KAU7C+b,EAAOuF,KAAO,SAAcrE,GAC1B,IAAIrb,EAAOzB,KACPzG,EAAQyG,KAAKzG,MAEjB,SAAS4nB,EAAK5iB,GACZkD,EAAKia,QAAQyF,KAAK5iB,EAAOue,GAIvBvjB,EAvPU,GAwPZ4nB,EAAK1f,EAAK6Q,QAAQ/T,MAAQ0pB,GAAS1uB,IAGrC4nB,EAAK1f,EAAK6Q,QAAQ/T,OAEdue,EAAM6L,iBAERxH,EAAKrE,EAAM6L,iBAITpvB,GAnQU,GAoQZ4nB,EAAK1f,EAAK6Q,QAAQ/T,MAAQ0pB,GAAS1uB,KAYvCqiB,EAAOgN,QAAU,SAAiB9L,GAChC,GAAI9c,KAAK6oB,UACP,OAAO7oB,KAAKmhB,KAAKrE,GAInB9c,KAAKzG,MAnRU,IA4RjBqiB,EAAOiN,QAAU,WAGf,IAFA,IAAInvB,EAAI,EAEDA,EAAIsG,KAAKooB,YAAYzuB,QAAQ,CAClC,KAAkC,GAA5BqG,KAAKooB,YAAY1uB,GAAGH,OACxB,OAAO,EAGTG,IAGF,OAAO,GASTkiB,EAAOwF,UAAY,SAAmBkG,GAGpC,IAAIwB,EAAiBjQ,EAAS,GAAIyO,GAElC,IAAKlM,EAASpb,KAAKsS,QAAQgK,OAAQ,CAACtc,KAAM8oB,IAGxC,OAFA9oB,KAAKmW,aACLnW,KAAKzG,MAvTQ,IA4TE,GAAbyG,KAAKzG,QACPyG,KAAKzG,MAnUU,GAsUjByG,KAAKzG,MAAQyG,KAAK+oB,QAAQD,GAGT,GAAb9oB,KAAKzG,OACPyG,KAAK4oB,QAAQE,IAejBlN,EAAOmN,QAAU,SAAiBzB,KAWlC1L,EAAOY,eAAiB,aASxBZ,EAAOzF,MAAQ,aAER+R,EAhRT,GA+RIc,GAEJ,SAAUC,GAGR,SAASD,EAAc1W,GACrB,IAAI0R,EAyBJ,YAvBgB,IAAZ1R,IACFA,EAAU,KAGZ0R,EAAQiF,EAAYxuB,KAAKuF,KAAMkY,EAAS,CACtC3Z,MAAO,MACP+e,SAAU,EACV4L,KAAM,EACNC,SAAU,IAEVlT,KAAM,IAENmT,UAAW,EAEXC,aAAc,IACb/W,KAAatS,MAGVspB,OAAQ,EACdtF,EAAMuF,SAAU,EAChBvF,EAAMwF,OAAS,KACfxF,EAAMyF,OAAS,KACfzF,EAAM0F,MAAQ,EACP1F,EA5BT1L,EAAe0Q,EAAeC,GA+B9B,IAAIrN,EAASoN,EAAcnnB,UAiF3B,OA/EA+Z,EAAOY,eAAiB,WACtB,MAAO,CA3lDqB,iBA8lD9BZ,EAAOmN,QAAU,SAAiBjM,GAChC,IAAI6M,EAAS3pB,KAETsS,EAAUtS,KAAKsS,QACfsX,EAAgB9M,EAAMQ,SAAS3jB,SAAW2Y,EAAQgL,SAClDuM,EAAgB/M,EAAMU,SAAWlL,EAAQ8W,UACzCU,EAAiBhN,EAAMY,UAAYpL,EAAQ2D,KAG/C,GAFAjW,KAAKmW,QArlDS,EAulDV2G,EAAM8C,WAA0C,IAAf5f,KAAK0pB,MACxC,OAAO1pB,KAAK+pB,cAKd,GAAIF,GAAiBC,GAAkBF,EAAe,CACpD,GA5lDU,IA4lDN9M,EAAM8C,UACR,OAAO5f,KAAK+pB,cAGd,IAAIC,GAAgBhqB,KAAKspB,OAAQxM,EAAMyB,UAAYve,KAAKspB,MAAQhX,EAAQ6W,SACpEc,GAAiBjqB,KAAKupB,SAAW5K,EAAY3e,KAAKupB,QAASzM,EAAM0B,QAAUlM,EAAQ+W,aAevF,GAdArpB,KAAKspB,MAAQxM,EAAMyB,UACnBve,KAAKupB,QAAUzM,EAAM0B,OAEhByL,GAAkBD,EAGrBhqB,KAAK0pB,OAAS,EAFd1pB,KAAK0pB,MAAQ,EAKf1pB,KAAKypB,OAAS3M,EAKG,IAFF9c,KAAK0pB,MAAQpX,EAAQ4W,KAKlC,OAAKlpB,KAAKyoB,sBAGRzoB,KAAKwpB,OAAStnB,YAAW,WACvBynB,EAAOpwB,MA9cD,EAgdNowB,EAAOf,YACNtW,EAAQ6W,UAndH,GAEA,EAudd,OApde,IAudjBvN,EAAOmO,YAAc,WACnB,IAAIG,EAASlqB,KAKb,OAHAA,KAAKwpB,OAAStnB,YAAW,WACvBgoB,EAAO3wB,MA3dM,KA4dZyG,KAAKsS,QAAQ6W,UA5dD,IAgejBvN,EAAOzF,MAAQ,WACb9T,aAAarC,KAAKwpB,SAGpB5N,EAAOuF,KAAO,WAveE,IAweVnhB,KAAKzG,QACPyG,KAAKypB,OAAOU,SAAWnqB,KAAK0pB,MAC5B1pB,KAAK0b,QAAQyF,KAAKnhB,KAAKsS,QAAQ/T,MAAOyB,KAAKypB,UAIxCT,EAjHT,CAkHEd,IASEkC,GAEJ,SAAUnB,GAGR,SAASmB,EAAe9X,GAKtB,YAJgB,IAAZA,IACFA,EAAU,IAGL2W,EAAYxuB,KAAKuF,KAAMkY,EAAS,CACrCoF,SAAU,GACThL,KAAatS,KATlBsY,EAAe8R,EAAgBnB,GAoB/B,IAAIrN,EAASwO,EAAevoB,UAoC5B,OAlCA+Z,EAAOyO,SAAW,SAAkBvN,GAClC,IAAIwN,EAAiBtqB,KAAKsS,QAAQgL,SAClC,OAA0B,IAAnBgN,GAAwBxN,EAAMQ,SAAS3jB,SAAW2wB,GAW3D1O,EAAOmN,QAAU,SAAiBjM,GAChC,IAAIvjB,EAAQyG,KAAKzG,MACbqmB,EAAY9C,EAAM8C,UAClB2K,EAAuB,EAARhxB,EACfixB,EAAUxqB,KAAKqqB,SAASvN,GAE5B,OAAIyN,IA5sDW,EA4sDM3K,IAA6B4K,GAliBhC,GAmiBTjxB,EACEgxB,GAAgBC,EA/sDf,EAgtDN5K,EAviBQ,EAwiBHrmB,EA1iBG,EA2iBCA,EA1iBC,EA8iBPA,EA/iBK,EAKC,IAgjBV6wB,EAzDT,CA0DElC,IASF,SAASuC,GAAanzB,GACpB,OAjuDmB,KAiuDfA,EACK,OAnuDQ,IAouDNA,EACF,KAvuDU,IAwuDRA,EACF,OAxuDW,IAyuDTA,EACF,QAGF,GAWT,IAAIozB,GAEJ,SAAUC,GAGR,SAASD,EAAcpY,GACrB,IAAI0R,EAcJ,YAZgB,IAAZ1R,IACFA,EAAU,KAGZ0R,EAAQ2G,EAAgBlwB,KAAKuF,KAAMkY,EAAS,CAC1C3Z,MAAO,MACP6qB,UAAW,GACX9L,SAAU,EACVhmB,UAnwDcszB,IAowDbtY,KAAatS,MACV6qB,GAAK,KACX7G,EAAM8G,GAAK,KACJ9G,EAjBT1L,EAAeoS,EAAeC,GAoB9B,IAAI/O,EAAS8O,EAAc7oB,UA0D3B,OAxDA+Z,EAAOY,eAAiB,WACtB,IAAIllB,EAAY0I,KAAKsS,QAAQhb,UACzBykB,EAAU,GAUd,OA1xDuB4B,EAkxDnBrmB,GACFykB,EAAQ5a,KAxyDW,SAsBAyc,GAqxDjBtmB,GACFykB,EAAQ5a,KA7yDW,SAgzDd4a,GAGTH,EAAOmP,cAAgB,SAAuBjO,GAC5C,IAAIxK,EAAUtS,KAAKsS,QACf0Y,GAAW,EACXxN,EAAWV,EAAMU,SACjBlmB,EAAYwlB,EAAMxlB,UAClBuX,EAAIiO,EAAM2B,OACVL,EAAItB,EAAM4B,OAed,OAbMpnB,EAAYgb,EAAQhb,YAryDHqmB,EAsyDjBrL,EAAQhb,WACVA,EAAkB,IAANuX,EA5yDC,EA4yD0BA,EAAI,EA3yD9B,EACC,EA2yDdmc,EAAWnc,IAAM7O,KAAK6qB,GACtBrN,EAAWhS,KAAK+N,IAAIuD,EAAM2B,UAE1BnnB,EAAkB,IAAN8mB,EAhzDC,EAgzD0BA,EAAI,EA7yDhC,EACE,GA6yDb4M,EAAW5M,IAAMpe,KAAK8qB,GACtBtN,EAAWhS,KAAK+N,IAAIuD,EAAM4B,UAI9B5B,EAAMxlB,UAAYA,EACX0zB,GAAYxN,EAAWlL,EAAQ8W,WAAa9xB,EAAYgb,EAAQhb,WAGzEskB,EAAOyO,SAAW,SAAkBvN,GAClC,OAAOsN,GAAevoB,UAAUwoB,SAAS5vB,KAAKuF,KAAM8c,KAtpBtC,EAupBd9c,KAAKzG,SAvpBS,EAupBgByG,KAAKzG,QAAwByG,KAAK+qB,cAAcjO,KAGhFlB,EAAOuF,KAAO,SAAcrE,GAC1B9c,KAAK6qB,GAAK/N,EAAM2B,OAChBze,KAAK8qB,GAAKhO,EAAM4B,OAChB,IAAIpnB,EAAYmzB,GAAa3N,EAAMxlB,WAE/BA,IACFwlB,EAAM6L,gBAAkB3oB,KAAKsS,QAAQ/T,MAAQjH,GAG/CqzB,EAAgB9oB,UAAUsf,KAAK1mB,KAAKuF,KAAM8c,IAGrC4N,EA/ET,CAgFEN,IAUEa,GAEJ,SAAUN,GAGR,SAASM,EAAgB3Y,GAKvB,YAJgB,IAAZA,IACFA,EAAU,IAGLqY,EAAgBlwB,KAAKuF,KAAMkY,EAAS,CACzC3Z,MAAO,QACP6qB,UAAW,GACX7b,SAAU,GACVjW,UAAWszB,GACXtN,SAAU,GACThL,KAAatS,KAblBsY,EAAe2S,EAAiBN,GAgBhC,IAAI/O,EAASqP,EAAgBppB,UA+B7B,OA7BA+Z,EAAOY,eAAiB,WACtB,OAAOkO,GAAc7oB,UAAU2a,eAAe/hB,KAAKuF,OAGrD4b,EAAOyO,SAAW,SAAkBvN,GAClC,IACIvP,EADAjW,EAAY0I,KAAKsS,QAAQhb,UAW7B,OARgB,GAAZA,EACFiW,EAAWuP,EAAMiD,gBA/2DIpC,EAg3DZrmB,EACTiW,EAAWuP,EAAMkD,iBAh3DEpC,GAi3DVtmB,IACTiW,EAAWuP,EAAMmD,kBAGZ0K,EAAgB9oB,UAAUwoB,SAAS5vB,KAAKuF,KAAM8c,IAAUxlB,EAAYwlB,EAAME,iBAAmBF,EAAMU,SAAWxd,KAAKsS,QAAQ8W,WAAatM,EAAM/S,cAAgB/J,KAAKsS,QAAQgL,UAAY/D,EAAIhM,GAAYvN,KAAKsS,QAAQ/E,UA73D/M,EA63D2NuP,EAAM8C,WAG/OhE,EAAOuF,KAAO,SAAcrE,GAC1B,IAAIxlB,EAAYmzB,GAAa3N,EAAME,iBAE/B1lB,GACF0I,KAAK0b,QAAQyF,KAAKnhB,KAAKsS,QAAQ/T,MAAQjH,EAAWwlB,GAGpD9c,KAAK0b,QAAQyF,KAAKnhB,KAAKsS,QAAQ/T,MAAOue,IAGjCmO,EAhDT,CAiDEb,IAUEc,GAEJ,SAAUP,GAGR,SAASO,EAAgB5Y,GAKvB,YAJgB,IAAZA,IACFA,EAAU,IAGLqY,EAAgBlwB,KAAKuF,KAAMkY,EAAS,CACzC3Z,MAAO,QACP6qB,UAAW,EACX9L,SAAU,GACThL,KAAatS,KAXlBsY,EAAe4S,EAAiBP,GAchC,IAAI/O,EAASsP,EAAgBrpB,UAmB7B,OAjBA+Z,EAAOY,eAAiB,WACtB,MAAO,CAz7Da,SA47DtBZ,EAAOyO,SAAW,SAAkBvN,GAClC,OAAO6N,EAAgB9oB,UAAUwoB,SAAS5vB,KAAKuF,KAAM8c,KAAWtR,KAAK+N,IAAIuD,EAAMoD,MAAQ,GAAKlgB,KAAKsS,QAAQ8W,WAtwB3F,EAswBwGppB,KAAKzG,QAG7HqiB,EAAOuF,KAAO,SAAcrE,GAC1B,GAAoB,IAAhBA,EAAMoD,MAAa,CACrB,IAAI/I,EAAQ2F,EAAMoD,MAAQ,EAAI,KAAO,MACrCpD,EAAM6L,gBAAkB3oB,KAAKsS,QAAQ/T,MAAQ4Y,EAG/CwT,EAAgB9oB,UAAUsf,KAAK1mB,KAAKuF,KAAM8c,IAGrCoO,EAlCT,CAmCEd,IAUEe,GAEJ,SAAUR,GAGR,SAASQ,EAAiB7Y,GAKxB,YAJgB,IAAZA,IACFA,EAAU,IAGLqY,EAAgBlwB,KAAKuF,KAAMkY,EAAS,CACzC3Z,MAAO,SACP6qB,UAAW,EACX9L,SAAU,GACThL,KAAatS,KAXlBsY,EAAe6S,EAAkBR,GAcjC,IAAI/O,EAASuP,EAAiBtpB,UAU9B,OARA+Z,EAAOY,eAAiB,WACtB,MAAO,CAx+Da,SA2+DtBZ,EAAOyO,SAAW,SAAkBvN,GAClC,OAAO6N,EAAgB9oB,UAAUwoB,SAAS5vB,KAAKuF,KAAM8c,KAAWtR,KAAK+N,IAAIuD,EAAMqD,UAAYngB,KAAKsS,QAAQ8W,WArzB1F,EAqzBuGppB,KAAKzG,QAGrH4xB,EAzBT,CA0BEf,IAUEgB,GAEJ,SAAUnC,GAGR,SAASmC,EAAgB9Y,GACvB,IAAI0R,EAeJ,YAbgB,IAAZ1R,IACFA,EAAU,KAGZ0R,EAAQiF,EAAYxuB,KAAKuF,KAAMkY,EAAS,CACtC3Z,MAAO,QACP+e,SAAU,EACVrH,KAAM,IAENmT,UAAW,GACV9W,KAAatS,MACVwpB,OAAS,KACfxF,EAAMyF,OAAS,KACRzF,EAlBT1L,EAAe8S,EAAiBnC,GAqBhC,IAAIrN,EAASwP,EAAgBvpB,UAiD7B,OA/CA+Z,EAAOY,eAAiB,WACtB,MAAO,CAxhEa,SA2hEtBZ,EAAOmN,QAAU,SAAiBjM,GAChC,IAAI6M,EAAS3pB,KAETsS,EAAUtS,KAAKsS,QACfsX,EAAgB9M,EAAMQ,SAAS3jB,SAAW2Y,EAAQgL,SAClDuM,EAAgB/M,EAAMU,SAAWlL,EAAQ8W,UACzCiC,EAAYvO,EAAMY,UAAYpL,EAAQ2D,KAI1C,GAHAjW,KAAKypB,OAAS3M,GAGT+M,IAAkBD,GAAmC,GAAlB9M,EAAM8C,YAA2CyL,EACvFrrB,KAAKmW,aACA,GAthEO,EAshEH2G,EAAM8C,UACf5f,KAAKmW,QACLnW,KAAKwpB,OAAStnB,YAAW,WACvBynB,EAAOpwB,MA92BG,EAg3BVowB,EAAOf,YACNtW,EAAQ2D,WACN,GA3hEK,EA2hED6G,EAAM8C,UACf,OAn3BY,EAs3Bd,OAn3Be,IAs3BjBhE,EAAOzF,MAAQ,WACb9T,aAAarC,KAAKwpB,SAGpB5N,EAAOuF,KAAO,SAAcrE,GA73BZ,IA83BV9c,KAAKzG,QAILujB,GA3iEQ,EA2iECA,EAAM8C,UACjB5f,KAAK0b,QAAQyF,KAAKnhB,KAAKsS,QAAQ/T,MAAQ,KAAMue,IAE7C9c,KAAKypB,OAAOlL,UAAY/E,IACxBxZ,KAAK0b,QAAQyF,KAAKnhB,KAAKsS,QAAQ/T,MAAOyB,KAAKypB,WAIxC2B,EAvET,CAwEElD,IAEEzrB,GAAW,CAQb6uB,WAAW,EASXnP,YA3lEyB,UAkmEzBG,QAAQ,EAUR8F,YAAa,KAQbmJ,WAAY,KAQZC,SAAU,CAORC,WAAY,OAQZC,YAAa,OAUbC,aAAc,OAQdC,eAAgB,OAQhBC,SAAU,OASVC,kBAAmB,kBAWnBC,GAAS,CAAC,CAACZ,GAAkB,CAC/B7O,QAAQ,IACN,CAAC4O,GAAiB,CACpB5O,QAAQ,GACP,CAAC,WAAY,CAAC2O,GAAiB,CAChC3zB,UAnqEyBqmB,IAoqEvB,CAAC+M,GAAe,CAClBpzB,UArqEyBqmB,GAsqExB,CAAC,UAAW,CAACqL,IAAgB,CAACA,GAAe,CAC9CzqB,MAAO,YACP2qB,KAAM,GACL,CAAC,QAAS,CAACkC,KAWd,SAASY,GAAetQ,EAAS7P,GAC/B,IAMIgO,EANAiC,EAAUJ,EAAQI,QAEjBA,EAAQ9mB,QAKbkmB,EAAKQ,EAAQpJ,QAAQkZ,UAAU,SAAU9wB,EAAOtD,GAC9CyiB,EAAOH,EAASoC,EAAQ9mB,MAAOoC,GAE3ByU,GACF6P,EAAQuQ,YAAYpS,GAAQiC,EAAQ9mB,MAAM6kB,GAC1CiC,EAAQ9mB,MAAM6kB,GAAQnf,GAEtBohB,EAAQ9mB,MAAM6kB,GAAQ6B,EAAQuQ,YAAYpS,IAAS,MAIlDhO,IACH6P,EAAQuQ,YAAc,KA0B1B,IAAIC,GAEJ,WACE,SAASA,EAAQpQ,EAASxJ,GACxB,IAAI0R,EAAQhkB,KAEZA,KAAKsS,QAAUuG,EAAS,GAAIpc,GAAU6V,GAAW,IACjDtS,KAAKsS,QAAQ8P,YAAcpiB,KAAKsS,QAAQ8P,aAAetG,EACvD9b,KAAKmsB,SAAW,GAChBnsB,KAAKid,QAAU,GACfjd,KAAKoc,YAAc,GACnBpc,KAAKisB,YAAc,GACnBjsB,KAAK8b,QAAUA,EACf9b,KAAK8c,MAxnCT,SAA6BpB,GAC3B,IAEI6P,EAAa7P,EAAQpJ,QAAQiZ,WAcjC,OAAO,IAZHA,IAEO5Q,EACFmJ,EACElJ,EACF2K,EACG7K,EAGHyM,GAFAd,KAKO3K,EAASmF,GAumCVuL,CAAoBpsB,MACjCA,KAAKmc,YAAc,IAAIV,EAAYzb,KAAMA,KAAKsS,QAAQ6J,aACtD6P,GAAehsB,MAAM,GACrBkb,EAAKlb,KAAKsS,QAAQ8J,aAAa,SAAUxZ,GACvC,IAAIyZ,EAAa2H,EAAMnY,IAAI,IAAIjJ,EAAK,GAAGA,EAAK,KAE5CA,EAAK,IAAMyZ,EAAWgM,cAAczlB,EAAK,IACzCA,EAAK,IAAMyZ,EAAWkM,eAAe3lB,EAAK,MACzC5C,MAUL,IAAI4b,EAASsQ,EAAQrqB,UAiQrB,OA/PA+Z,EAAOD,IAAM,SAAarJ,GAcxB,OAbAuG,EAAS7Y,KAAKsS,QAASA,GAEnBA,EAAQ6J,aACVnc,KAAKmc,YAAYD,SAGf5J,EAAQ8P,cAEVpiB,KAAK8c,MAAM6F,UACX3iB,KAAK8c,MAAMhjB,OAASwY,EAAQ8P,YAC5BpiB,KAAK8c,MAAMyF,QAGNviB,MAWT4b,EAAOyQ,KAAO,SAAcC,GAC1BtsB,KAAKid,QAAQsP,QAAUD,EAjHT,EADP,GA6HT1Q,EAAOwF,UAAY,SAAmBkG,GACpC,IAAIrK,EAAUjd,KAAKid,QAEnB,IAAIA,EAAQsP,QAAZ,CAMA,IAAIlQ,EADJrc,KAAKmc,YAAYU,gBAAgByK,GAEjC,IAAIlL,EAAcpc,KAAKoc,YAInBoQ,EAAgBvP,EAAQuP,gBAGvBA,GAAiBA,GAvpCR,EAupCyBA,EAAcjzB,SACnD0jB,EAAQuP,cAAgB,KACxBA,EAAgB,MAKlB,IAFA,IAAI9yB,EAAI,EAEDA,EAAI0iB,EAAYziB,QACrB0iB,EAAaD,EAAY1iB,GArJb,IA4JRujB,EAAQsP,SACXC,GAAiBnQ,IAAemQ,IACjCnQ,EAAWqM,iBAAiB8D,GAI1BnQ,EAAWlG,QAFXkG,EAAW+E,UAAUkG,IAOlBkF,GAAoC,GAAnBnQ,EAAW9iB,QAC/B0jB,EAAQuP,cAAgBnQ,EACxBmQ,EAAgBnQ,GAGlB3iB,MAWJkiB,EAAO1hB,IAAM,SAAamiB,GACxB,GAAIA,aAAsB6L,GACxB,OAAO7L,EAKT,IAFA,IAAID,EAAcpc,KAAKoc,YAEd1iB,EAAI,EAAGA,EAAI0iB,EAAYziB,OAAQD,IACtC,GAAI0iB,EAAY1iB,GAAG4Y,QAAQ/T,QAAU8d,EACnC,OAAOD,EAAY1iB,GAIvB,OAAO,MAUTkiB,EAAO/P,IAAM,SAAawQ,GACxB,GAAIsL,GAAetL,EAAY,MAAOrc,MACpC,OAAOA,KAIT,IAAIysB,EAAWzsB,KAAK9F,IAAImiB,EAAW/J,QAAQ/T,OAS3C,OAPIkuB,GACFzsB,KAAK0sB,OAAOD,GAGdzsB,KAAKoc,YAAYjb,KAAKkb,GACtBA,EAAWX,QAAU1b,KACrBA,KAAKmc,YAAYD,SACVG,GAUTT,EAAO8Q,OAAS,SAAgBrQ,GAC9B,GAAIsL,GAAetL,EAAY,SAAUrc,MACvC,OAAOA,KAGT,IAAI2sB,EAAmB3sB,KAAK9F,IAAImiB,GAEhC,GAAIA,EAAY,CACd,IAAID,EAAcpc,KAAKoc,YACnBpD,EAAQ4J,EAAQxG,EAAauQ,IAElB,IAAX3T,IACFoD,EAAYuI,OAAO3L,EAAO,GAC1BhZ,KAAKmc,YAAYD,UAIrB,OAAOlc,MAWT4b,EAAOgR,GAAK,SAAYC,EAAQpL,GAC9B,QAAeplB,IAAXwwB,QAAoCxwB,IAAZolB,EAC1B,OAAOzhB,KAGT,IAAImsB,EAAWnsB,KAAKmsB,SAKpB,OAJAjR,EAAKmG,EAASwL,IAAS,SAAUtuB,GAC/B4tB,EAAS5tB,GAAS4tB,EAAS5tB,IAAU,GACrC4tB,EAAS5tB,GAAO4C,KAAKsgB,MAEhBzhB,MAUT4b,EAAOkR,IAAM,SAAaD,EAAQpL,GAChC,QAAeplB,IAAXwwB,EACF,OAAO7sB,KAGT,IAAImsB,EAAWnsB,KAAKmsB,SAQpB,OAPAjR,EAAKmG,EAASwL,IAAS,SAAUtuB,GAC1BkjB,EAGH0K,EAAS5tB,IAAU4tB,EAAS5tB,GAAOomB,OAAO/B,EAAQuJ,EAAS5tB,GAAQkjB,GAAU,UAFtE0K,EAAS5tB,MAKbyB,MAST4b,EAAOuF,KAAO,SAAc5iB,EAAOwuB,GAE7B/sB,KAAKsS,QAAQgZ,WAxQrB,SAAyB/sB,EAAOwuB,GAC9B,IAAIC,EAAe5T,SAAS6T,YAAY,SACxCD,EAAaE,UAAU3uB,GAAO,GAAM,GACpCyuB,EAAaG,QAAUJ,EACvBA,EAAKjzB,OAAOszB,cAAcJ,GAqQtBK,CAAgB9uB,EAAOwuB,GAIzB,IAAIZ,EAAWnsB,KAAKmsB,SAAS5tB,IAAUyB,KAAKmsB,SAAS5tB,GAAOyb,QAE5D,GAAKmS,GAAaA,EAASxyB,OAA3B,CAIAozB,EAAK/rB,KAAOzC,EAEZwuB,EAAK5P,eAAiB,WACpB4P,EAAKhQ,SAASI,kBAKhB,IAFA,IAAIzjB,EAAI,EAEDA,EAAIyyB,EAASxyB,QAClBwyB,EAASzyB,GAAGqzB,GACZrzB,MAUJkiB,EAAO+G,QAAU,WACf3iB,KAAK8b,SAAWkQ,GAAehsB,MAAM,GACrCA,KAAKmsB,SAAW,GAChBnsB,KAAKid,QAAU,GACfjd,KAAK8c,MAAM6F,UACX3iB,KAAK8b,QAAU,MAGVoQ,EA9RT,GAiSIoB,GAAyB,CAC3BnI,WA/gFgB,EAghFhBC,UA/gFe,EAghFfC,SA/gFc,EAghFdC,YA/gFiB,GA0hFfiI,GAEJ,SAAUxJ,GAGR,SAASwJ,IACP,IAAIvJ,EAEAC,EAAQsJ,EAAiB1rB,UAK7B,OAJAoiB,EAAMxB,SAlBuB,aAmB7BwB,EAAMvB,MAlBuB,6CAmB7BsB,EAAQD,EAAOpiB,MAAM3B,KAAMoC,YAAcpC,MACnCwtB,SAAU,EACTxJ,EA8BT,OAxCA1L,EAAeiV,EAAkBxJ,GAapBwJ,EAAiB1rB,UAEvB4f,QAAU,SAAiBa,GAChC,IAAIthB,EAAOssB,GAAuBhL,EAAGthB,MAMrC,GAtjFc,IAkjFVA,IACFhB,KAAKwtB,SAAU,GAGZxtB,KAAKwtB,QAAV,CAIA,IAAI/H,EAAUgI,GAAuBhzB,KAAKuF,KAAMsiB,EAAIthB,GAEzC,GAAPA,GAAqCykB,EAAQ,GAAG9rB,OAAS8rB,EAAQ,GAAG9rB,SAAW,IACjFqG,KAAKwtB,SAAU,GAGjBxtB,KAAKmiB,SAASniB,KAAK0b,QAAS1a,EAAM,CAChCsc,SAAUmI,EAAQ,GAClBzE,gBAAiByE,EAAQ,GACzBnB,YAxkFiB,QAykFjBvH,SAAUuF,MAIPiL,EAzCT,CA0CErL,GAEF,SAASuL,GAAuBnL,EAAIthB,GAClC,IAAI0sB,EAAMxsB,EAAQohB,EAAGmD,SACjBkI,EAAUzsB,EAAQohB,EAAGwD,gBAMzB,OAJW,GAAP9kB,IACF0sB,EAAM9I,EAAY8I,EAAInR,OAAOoR,GAAU,cAAc,IAGhD,CAACD,EAAKC,GAWf,SAASC,GAAUC,EAAQz2B,EAAM02B,GAC/B,IAAIC,EAAqB,sBAAwB32B,EAAO,KAAO02B,EAAU,SACzE,OAAO,WACL,IAAI9nB,EAAI,IAAIlG,MAAM,mBACdkuB,EAAQhoB,GAAKA,EAAEgoB,MAAQhoB,EAAEgoB,MAAM3J,QAAQ,kBAAmB,IAAIA,QAAQ,cAAe,IAAIA,QAAQ,6BAA8B,kBAAoB,sBACnJ4J,EAAMvsB,OAAOoH,UAAYpH,OAAOoH,QAAQC,MAAQrH,OAAOoH,QAAQmlB,KAMnE,OAJIA,GACFA,EAAIxzB,KAAKiH,OAAOoH,QAASilB,EAAoBC,GAGxCH,EAAOlsB,MAAM3B,KAAMoC,YAc9B,IAAI8rB,GAASN,IAAU,SAAUO,EAAMtL,EAAKuL,GAI1C,IAHA,IAAI50B,EAAOC,OAAOD,KAAKqpB,GACnBnpB,EAAI,EAEDA,EAAIF,EAAKG,UACTy0B,GAASA,QAA2B/xB,IAAlB8xB,EAAK30B,EAAKE,OAC/By0B,EAAK30B,EAAKE,IAAMmpB,EAAIrpB,EAAKE,KAG3BA,IAGF,OAAOy0B,IACN,SAAU,iBAWTC,GAAQR,IAAU,SAAUO,EAAMtL,GACpC,OAAOqL,GAAOC,EAAMtL,GAAK,KACxB,QAAS,iBAUZ,SAASwL,GAAQztB,EAAOtG,EAAMg0B,GAC5B,IACIC,EADAC,EAAQl0B,EAAKuH,WAEjB0sB,EAAS3tB,EAAMiB,UAAYpI,OAAO6L,OAAOkpB,IAClCnuB,YAAcO,EACrB2tB,EAAOE,OAASD,EAEZF,GACFzV,EAAS0V,EAAQD,GAWrB,SAASI,GAAO7G,EAAIxY,GAClB,OAAO,WACL,OAAOwY,EAAGlmB,MAAM0N,EAASjN,YAY7B,I,YAAIusB,GAEJ,WACE,IAAIA,EAKJ,SAAgB7S,EAASxJ,GAKvB,YAJgB,IAAZA,IACFA,EAAU,IAGL,IAAI4Z,GAAQpQ,EAAS5D,EAAS,CACnCkE,YAAa2P,GAAOxP,UACnBjK,KA6DL,OA1DAqc,EAAOC,QAAU,YACjBD,EAAOE,cApsFWjE,GAqsFlB+D,EAAOG,eAxsFY,GAysFnBH,EAAOhR,eA5sFY,EA6sFnBgR,EAAOI,gBA5sFa,EA6sFpBJ,EAAO/Q,aA5sFU,EA6sFjB+Q,EAAO/D,qBA3sFkBjN,EA4sFzBgR,EAAOK,mBA3sFgBpR,GA4sFvB+Q,EAAOM,eAltFY,EAmtFnBN,EAAOG,eA/sFY,GAgtFnBH,EAAOO,YAxtFS,EAytFhBP,EAAOQ,WAxtFQ,EAytFfR,EAAOS,UAxtFO,EAytFdT,EAAOU,aAxtFU,EAytFjBV,EAAOW,eApjDY,EAqjDnBX,EAAOY,YApjDS,EAqjDhBZ,EAAOa,cApjDW,EAqjDlBb,EAAOc,YApjDS,EAqjDhBd,EAAOe,iBArjDS,EAsjDhBf,EAAOgB,gBApjDa,GAqjDpBhB,EAAOiB,aApjDU,GAqjDjBjB,EAAOzC,QAAUA,GACjByC,EAAOzM,MAAQA,EACfyM,EAAOlT,YAAcA,EACrBkT,EAAOpJ,WAAaA,EACpBoJ,EAAOtI,WAAaA,GACpBsI,EAAO7K,kBAAoBA,EAC3B6K,EAAOxH,gBAAkBA,GACzBwH,EAAOpB,iBAAmBA,GAC1BoB,EAAOzG,WAAaA,GACpByG,EAAOvE,eAAiBA,GACxBuE,EAAOkB,IAAM7G,GACb2F,EAAOmB,IAAMpF,GACbiE,EAAOoB,MAAQ9E,GACf0D,EAAOqB,MAAQ9E,GACfyD,EAAOsB,OAAS9E,GAChBwD,EAAOuB,MAAQ9E,GACfuD,EAAO/B,GAAKrL,EACZoN,EAAO7B,IAAMnL,EACbgN,EAAOzT,KAAOA,EACdyT,EAAOP,MAAQA,GACfO,EAAOT,OAASA,GAChBS,EAAOD,OAASA,GAChBC,EAAOxW,OAASU,EAChB8V,EAAON,QAAUA,GACjBM,EAAOD,OAASA,GAChBC,EAAOjV,SAAWA,EAClBiV,EAAOztB,QAAUA,EACjBytB,EAAO/L,QAAUA,EACjB+L,EAAO/J,YAAcA,EACrB+J,EAAOtN,SAAWA,EAClBsN,EAAOvT,SAAWA,EAClBuT,EAAO7Q,UAAYA,EACnB6Q,EAAOpN,kBAAoBA,EAC3BoN,EAAOhN,qBAAuBA,EAC9BgN,EAAOlyB,SAAWoc,EAAS,GAAIpc,GAAU,CACvCsvB,OAAQA,KAEH4C,EA1ET,GAiFe,IAFEA,GAAOlyB,SAET,I,UCr6FF0zB,GAAU3kB,KAAKyT,GAAK,IAGpBmR,IAAQ,aAClBzB,GAAOO,YAAcl2B,KAAMG,OADT,OAElBw1B,GAAOQ,WAAan2B,KAAMK,QAFR,OAGlBs1B,GAAOS,UAAYp2B,KAAMM,KAHP,OAIlBq1B,GAAOU,aAAer2B,KAAME,QAJV,IAORm3B,GAAY,CACvBC,MAAO,EACPC,KAAM,EACNC,GAAI,EACJC,KAAM,G,IAGiB,aACtB9B,GAAOI,gBAAkBsB,GAAUC,OADb,OAEtB3B,GAAOhR,eAAiB0S,GAAUE,MAFZ,OAGtB5B,GAAO/Q,aAAeyS,GAAUG,IAHV,OAItB7B,GAAOG,eAAiBuB,GAAUI,MAGR,aAC1B9B,GAAOO,YAAc,SADK,OAE1BP,GAAOQ,WAAa,QAFM,OAG1BR,GAAOS,UAAY,OAHO,OAI1BT,GAAOU,aAAe,UAEQ,aAC9BV,GAAO/D,qBAAuB,cADA,OAE9B+D,GAAO/Q,aAAe,MAFQ,OAG9B+Q,GAAOG,eAAiB,QAHM,OAI9BH,GAAOK,mBAAqB,YAJE,OAK9BL,GAAOM,eAAiB,QALM,OAM9BN,GAAOE,cAAgB,OANO,OAO9BF,GAAOI,gBAAkB,SAPK,OAQ9BJ,GAAOhR,eAAiB,Q,qaC9CpB,IAAM+S,GAAb,0B,EAAA,G,EAAA,E,yJACE,WAAYt5B,EAAMsD,EAAOi2B,GAAe,qDACVv5B,EADS,KACAsD,EADA,eACsBi2B,EADtB,KADzC,U,OAAA,GAAsC7wB,Q,2PCAtC,IAAI8wB,GAAW,GAER,SAASC,GAAWj1B,GACzB,GAAIA,KAAOg1B,GAAU,OAAOA,GAASh1B,GAErC,MAAM,IAAIkE,MAAM,sBAAwBlE,GAgBnC,SAASk1B,KACd,O,mWAAO,CAAP,GAAYF,I,01CCfd,IAAIG,GAAoB,EA2XxB,SAASC,GAAqB55B,EAAMy2B,EAAQtvB,GAC1C,GAAIsvB,EACF,GAAsB,oBAAXA,EACTA,EAAOtvB,QAGP,GACE,iBAAkBsvB,GACa,oBAAxBA,EAAOoD,aAGdD,GAAqB55B,EADLy2B,EAAOoD,eACa1yB,QAEpC,GAAI,iBAAkBsvB,EAAQ,CAAC,IACrBqD,EAAerD,EAAOsD,aAAtBD,WACR,GAAIh0B,MAAMC,QAAQ+zB,GAChB,IAAK,IAAMlY,KAASkY,EAAY,CAAC,IAAD,OACTA,EAAWlY,GADF,GACvBpc,EADuB,KAClBlC,EADkB,KAE9B,GAAIkC,KAAO2B,EAAMC,YAAa,CAC5B,IAAM4yB,EAAc7yB,EAAMC,YAAY5B,GAClClC,GAASA,EAAMkM,SAEjBlM,EAAMkM,SAASwqB,GAGfvD,EAAOsD,aAAaD,WAAWlY,GAAS,CAACpc,EAAKw0B,MAgEjDC,O,WA3bb,aAAe,IAAD,yBAtBdC,kBAAmB,EAsBL,KArBdC,kBAAmB,EAqBL,KApBdC,KAAO,KAoBO,KAnBdtzB,OAAS,GAmBK,KAlBduzB,OAAS,KAkBK,KAjBdC,gBAAkB,GAiBJ,KAhBd/rB,SAAW3M,KAAMC,aAgBH,KAfd04B,cAAgB34B,KAAMC,aAeR,KAdd24B,cAAgB,KAcF,KAkCdC,mBAAqB,WACnB,GAAI30B,MAAMC,QAAQ,EAAKe,OAAO0F,SAC5B,eAAsB,EAAK1F,OAAO0F,WAAlC,aAA2C,SACjCkuB,qBAAqB,EAAKjyB,MArC1B,KA6Dd8iB,QAAU,WACR,EAAKkP,qBAED,EAAKJ,SACP,EAAKA,OAAOpF,OACZ,EAAKoF,OAAO9O,WAEd,EAAK8O,OAAS,MApEF,KAuEdM,cAAgB,YAAe,IAAZljB,EAAW,EAAXA,EAAGuP,EAAQ,EAARA,EACd4T,EAAO,EAAKR,KAAKS,wBAGvB,OADEpjB,GAAKmjB,EAAKj1B,MAAQ8R,GAAKmjB,EAAKv8B,OAAS2oB,GAAK4T,EAAKl1B,KAAOshB,GAAK4T,EAAKh1B,QA1EtD,KAoHdk1B,UAAY,SAAA1zB,GAAgB,IAAD,EAIrB,EAAKO,IAAIxC,MAFkBoC,EAFN,EAEvBtD,4BACuBoD,EAHA,EAGvBtD,sBAGIoD,EAAQ,EAAK4zB,mBAAmB3zB,GAEtCwyB,GAAqB,iBAAkBvyB,EAAgBF,GACnD,EAAKqzB,gBAAkBrzB,EAAMC,YAAYjF,QAC3C,EAAKq4B,cAAgBrzB,EAAMC,YAAYjF,MACvCy3B,GAAqB,uBAAwBryB,EAAsBJ,KA/HzD,KAiRd6zB,KAAO,WACL,IAAMjF,EAAU,EAAKsE,OAAOv3B,IAAI,EAAK9C,MACrC,GAAK+1B,EAAL,CAEA,IAqEMkF,EAAS,EAAKC,kBACpBnF,EAAQxR,IAAR,SAAiB0W,GAAjB,IAAyB/V,OAtEV,SAACD,EAAYiL,GAC1B,IAAK,EAAKppB,OAAOwF,QAGf,OAFA,EAAK4tB,kBAAmB,EACxB,EAAKC,kBAAmB,GACjB,EAIT,IACGjK,IACAjL,EAAW/J,SACqB,qBAA1BgV,EAAUvd,YAEjB,OAAO,EAAKwoB,2BAGd,GAAI,EAAKhB,iBACP,OAAO,EAGT,IAAK,EAAKiB,WAAY,CACpB,GAAI,EAAKlB,iBACP,OAAO,EAMT,GAFA,EAAKmB,cAAgB,EAAKC,sBAEtB,EAAKD,cAAc94B,OAAQ,CAG7B,eAAsB,EAAK84B,iBAA3B,aAA0C,CAAC,IAAhCtF,EAA+B,QAExC,IAAKA,EAAQqF,YAAcrF,EAAQmE,iBAGjC,OAFA,EAAKC,kBAAmB,EACxB,EAAKD,kBAAmB,GACjB,EAIX,OAAO,GAKX,IAAK,EAAKqB,6BACR,OAAO,EAGT,IAAMC,EACoB,MAAxB,EAAKC,gBACD,EACAvL,EAAUnH,SAAW,EAAK0S,gBApDQ,EAqDZ,EAAKC,yBAC/B,EAAKC,YACL1W,EAF0B,SAIrBiL,GAJqB,IAKxBsL,mBALII,EArDgC,EAqDhCA,QAaR,OAlEwC,EAqDvBC,SAUf,EAAKC,oBAAoB5L,GACzB,EAAKiK,kBAAmB,GAEnByB,QAtVThzB,KAAKmzB,iBAAmBpC,K,6BAb1B,WACE,MAAM,GAAI/wB,KAAK5I,KAAO4I,KAAKmzB,mB,sBAG7B,WACE,OAAO,I,sCAGT,WACE,MAAM,IAAIrzB,MAAM,6D,uBAOlB,WACE,OAAOE,KAAK9B,S,4BAGd,SAAeivB,M,kCAEf,SAAqBttB,UACZG,KAAK0xB,gBAAgB7xB,K,+BAG9B,SAAkBstB,GAChBntB,KAAK0xB,gBAAgBvE,EAAQttB,IAAMstB,I,sCAGrC,WACE,MAAO,CAAE6F,SAAS,K,8BAGpB,SAAiBx0B,GACf,OAAOA,I,8BAGT,WACE,MAAM,IAAIsB,MAAM,qD,+CAGlB,SAAkC5B,GAChC,OAAO,I,iCAWT,YAAmD,IAAD,IAA5BwF,eAA4B,SAATnH,EAAS,oBAOhD,GANAyD,KAAK6xB,qBAEL7xB,KAAK9B,OA0VT,SAAsBA,GACpB,IAAM3B,EAAK,MAAQ2B,GAEf,YAAaA,IACf3B,EAAMoN,QAAUzL,EAAOyL,QACvBpN,EAAM62B,UAAY72B,EAAMoN,QAAUpN,EAAMoN,SAEtC,gBAAiBzL,IACnB3B,EAAMqN,YAAc1L,EAAO0L,YAC3BrN,EAAM82B,cAAgB92B,EAAMqN,YAAcrN,EAAMqN,aAE9C,YAAa1L,IACf3B,EAAMoM,QAAUzK,EAAOyK,QACvBpM,EAAM+2B,UAAYp1B,EAAOyK,QAAUzK,EAAOyK,SAG1CpM,EAAMqH,QADJ,YAAa1F,GAiCFxD,EAhCWwD,EAAO0F,QAiCjB,MAATlJ,EAAgB,GAAKwC,MAAMC,QAAQzC,GAASA,EAAQ,CAACA,IAhCvD0C,KAAI,mBAAqBm2B,GAArB,EAAG/1B,gBACPH,QAAO,SAAAmjB,GAAC,OAAIA,KAEC,KA4BpB,IAAiB9lB,EAHf,MAtBA,CACE,cACA,cACA,UACA,UACA,YACA,gBACA,YACA,cACA,mBACA,mBACA,iBACA,iBACA,qBACA,mBACA,qBACA,oBACAiC,SAAQ,SAAAkd,GACmB,qBAAhBtd,EAAMsd,KACftd,EAAMsd,GAAQ3N,OAAOsnB,QAGlBj3B,EAvYSk3B,CAAa,IAAE/vB,WAAYnH,IACzCyD,KAAK2yB,6BAA+B3yB,KAAK0zB,kCACvC1zB,KAAK9B,QAEHhB,MAAMC,QAAQ6C,KAAK9B,OAAO0F,SAC5B,eAAsB5D,KAAK9B,OAAO0F,WAAlC,aAA2C,SACjC+vB,kBAAkB3zB,MAO9B,OAHIA,KAAKyxB,QACPzxB,KAAKoyB,OAEApyB,KAAK9B,S,sBAoBd,SAAS8C,GACP,OAAOovB,GAASpvB,K,gCAGlB,SAAmBzC,GAAQ,IACjBqhB,EAA6CrhB,EAA7CqhB,UAAwB/W,EAAqBtK,EAAlCwL,YAEb6pB,EAAer1B,EAAMyiB,gBAAgB,GACrCpb,EAAgB5F,KAAK+xB,cAAc,CACvCljB,EAAG+kB,EAAazV,QAChBC,EAAGwV,EAAavV,UAGZ9kB,EAAQyG,KAAK6zB,SAASjU,GAM5B,OALIrmB,IAAUyG,KAAK2xB,gBACjB3xB,KAAK2F,SAAW3F,KAAK2xB,cACrB3xB,KAAK2xB,cAAgBp4B,GAGhB,CACLiF,YAAY,OACVqK,mBACAtP,QACAqM,iBACG5F,KAAK8zB,qBAAqBv1B,IAJpB,IAMTtC,WAAY+D,KAAK/D,WACjBnC,OAAQkG,KAAKjB,IACb4G,SAAU3F,KAAK2F,WAEjB4Y,UAAW9E,KAAKD,S,kCAIpB,SAAqBjb,GACnB,MAAO,K,mCAkBT,SAAsBA,GACpB,cAAsB9E,OAAOsrB,OAAO/kB,KAAK0xB,iBAAzC,eAA2D,CAAtD,IAAMvE,EAAO,KACZA,GAAWA,EAAQmE,mBACrBnE,EAAQoE,kBAAmB,EAC3BpE,EAAQ4G,YAAYx1B,O,mCAK1B,WACE,cAAsB9E,OAAOsrB,OAAO/kB,KAAK0xB,iBAAzC,eAA2D,CAAtD,IAAMvE,EAAO,KACZA,GACFA,EAAQ6G,eAAeh0B,S,4BAK7B,SAAezB,GACbyB,KAAKsxB,kBAAmB,EACxBtxB,KAAKi0B,sBAAsB11B,K,6BAG7B,SAAgBA,GACVyB,KAAKsxB,mBACPtxB,KAAKuxB,kBAAmB,EACxBvxB,KAAK+zB,YAAYx1B,M,yBAIrB,SAAYA,GACVyB,KAAKk0B,wBACLl0B,KAAKkyB,UAAL,SACK3zB,GADL,IAEEqhB,UAAW+O,GAAOU,aAClBnO,SAAS,KAEXlhB,KAAKm0B,eAAe51B,K,wBAGtB,YAAwB,EAAX0iB,UAETjhB,KAAKuxB,kBAAmB,K,qBAI5B,SAAQxyB,GAAM,IAAD,OACX,GAAW,MAAPA,EAGF,OAFAiB,KAAK2iB,eACL3iB,KAAKwxB,KAAO,MAIdxxB,KAAKjB,IAAMA,EAEXiB,KAAKwxB,KAAO72B,aAAeoE,GAC3BiB,KAAKyxB,OAAS,IAAI9C,GAAOzC,QAAQlsB,KAAKwxB,MAEtCxxB,KAAK2F,SAAW3M,KAAMC,aACtB+G,KAAK2xB,cAAgB34B,KAAMC,aAC3B+G,KAAK4xB,cAAgB,KAdV,IAiBLzE,EAAU,IAAIiH,EADWp0B,KAAvBo0B,oBAC+Bp0B,KAAKsyB,mBAC5CtyB,KAAKyxB,OAAO5lB,IAAIshB,GAEhBntB,KAAKyxB,OAAO7E,GAAG,gBAAgB,SAAAtK,GAC7B,IAAK,EAAKpkB,OAAOwF,QAGf,OAFA,EAAK6tB,kBAAmB,OACxB,EAAKD,kBAAmB,GAI1B,EAAK+C,WAAW/R,GAIa,OAAzB,EAAKuQ,iBAA4C,IAAhBvQ,EAAGnC,WACtC,EAAK0S,gBAAkBvQ,EAAGnC,UAExBmC,EAAGpB,SAELhf,YAAW,WACT,EAAK2wB,gBAAkB,KACvB,EAAKtB,kBAAmB,QAK9BvxB,KAAKs0B,cACLt0B,KAAKoyB,S,yBAGP,WAAe,IAAD,OACPpyB,KAAKwyB,aACRxyB,KAAKyxB,OAAO7E,GAAM5sB,KAAK5I,KAAvB,SAAoC,SAAAmH,GAAK,OAAI,EAAKg2B,QAAQh2B,MAC1DyB,KAAKyxB,OAAO7E,GAAM5sB,KAAK5I,KAAvB,OAAkC4I,KAAK5I,KAAvC,UAAqD,SAAAmH,GAAK,OACxD,EAAK41B,eAAe51B,OAGxByB,KAAKyxB,OAAO7E,GAAG5sB,KAAK5I,MAAM,SAAAkrB,GAAE,OAAI,EAAKkS,mBAAmBlS,Q,qBAG1D,YAAuC,IAA7B7D,EAA4B,EAA5BA,OAAQC,EAAoB,EAApBA,OAAQyB,EAAY,EAAZA,SAExBngB,KAAK2F,SAAW3M,KAAMC,aACtB+G,KAAK2xB,cAAgB34B,KAAMC,aAC3B+G,KAAK4xB,cAAgB,KAErB5xB,KAAKsxB,kBAAmB,EACxBtxB,KAAKy0B,WAAahW,EAClBze,KAAK00B,WAAahW,EAClB1e,KAAK6yB,gBAAkB1S,I,gCAGzB,SAAmBmC,GACjBtiB,KAAKkyB,UAAU5P,K,uBAGjB,c,iCAEA,WACE,OAAIplB,MAAMC,QAAQ6C,KAAK9B,OAAO0F,UAAY5D,KAAK9B,OAAO0F,QAAQjK,OAGvCqG,KAAK9B,OAAO0F,QAAQvG,QACvC,mBAA+C,IAA/C,EAAGk0B,oBAIA,K,6BAGT,WAKE,MAAO,CACLjU,SAJAtd,KAAK9B,OAAOsF,cAAgBxD,KAAK9B,OAAO6L,YACpC/J,KAAK9B,OAAOsF,YACZ,K,iCAmFR,SAAoB8jB,Q,gRChWPqN,G,0SA1Bb,WACE,OAAO,I,kCAGT,YAMI,IALFlW,EAKC,EALDA,OACAC,EAIC,EAJDA,OACAjS,EAGC,EAHDA,UACA4T,EAEC,EAFDA,UAEC,IADD7B,OAAU3P,EACT,EADSA,EAAGuP,EACZ,EADYA,EAEP4T,EAAOhyB,KAAKwxB,KAAKS,wBACjB2C,EAAQC,KAAW36B,MACzB,MAAO,CACLwS,aAAc+R,GAAUze,KAAKy0B,YAAc,GAC3CK,aAAcpW,GAAU1e,KAAK00B,YAAc,GAC3CK,UAAWlmB,EACXmmB,UAAW5W,EACX3R,UAAWA,EAAYmoB,EACvBvU,UAAWA,EAAYuU,EACvB/lB,EAAGA,EAAImjB,EAAKj1B,KACZqhB,EAAGA,EAAI4T,EAAKl1B,S,GAtBmBu0B,ICHxB4D,GAAQ,SAAAzU,GAAC,OAAItU,OAAOgpB,MAAM1U,IAE1B2U,GAAgB,SAAA3U,GAAC,MAAiB,kBAANA,IAAmBtU,OAAOgpB,MAAM1U,IAE5D4U,GAAsB,SAAC16B,EAAO26B,GAAR,OAChCJ,GAAMI,KACLA,EAAQ,GAAK36B,GAAS26B,GAAWA,GAAS,GAAK36B,GAAS26B,IAC/CC,GAAa,wEAAoB,GAApB,IAAGzmB,SAAH,MAAO,EAAP,MAAUuP,SAAV,MAAc,EAAd,SAA2BvP,EAAIA,EAAIuP,EAAIA,GACpDmX,GAAsB,SAAC76B,EAAO+Q,GAAR,OAChCwpB,GAAMxpB,KAAUA,EAAM,GAAK/Q,EAAQ+Q,GAASA,GAAO,GAAK/Q,EAAQ+Q,IAE5D,SAAS+pB,GAAkB3H,EAAQ1E,GACxC,OAAKA,EAIEjnB,YAAW,kBAAM2rB,MAAU1E,IAHhC0E,IACO,M,s0BC0HI4H,G,oRAhIb,WACE,MAAO,U,8BAGT,WACE,OAAO9G,GAAOoB,Q,gCAGhB,SAAmBxxB,GACjByB,KAAKkyB,UAAL,SACK3zB,GADL,IAEEqhB,UAAW+O,GAAOQ,WAClBjO,SAAS,EACTD,SAAS,KAEXjhB,KAAKsxB,kBAAmB,EACxBtxB,KAAKuxB,kBAAmB,EACxBvxB,KAAKkyB,UAAL,SACK3zB,GADL,IAEEqhB,UAAW+O,GAAOS,UAClBlO,SAAS,O,wBAIb,SAAWoB,GAAK,IAAD,OAEb,GADA,oDAAiBA,IACbtiB,KAAKuxB,iBAKT,GAAIjP,EAAGpB,QACLhf,YAAW,WACL,EAAKovB,kBACP,EAAKyC,YAAYzR,WAGhB,IAAKtiB,KAAKuxB,mBAAqBvxB,KAAKsxB,iBAAkB,CAE3D,IAAMnE,EAAUntB,KAAKyxB,OAAOv3B,IAAI8F,KAAK5I,MACjC+1B,EAAQ7a,QAAQgK,OAAO6Q,EAAS7K,KAClCtiB,KAAKu0B,QAAQjS,GACbtiB,KAAKkyB,UAAU5P,O,6BAKrB,WACE,MAAO,CACLhF,SAAUtd,KAAK9B,OAAO2K,iBACtBvR,UAAW0I,KAAK01B,kB,iCAIpB,SAAoBp+B,GAClB,IAAMq+B,EAAa,GAcnB,OAbIr+B,EAAY+4B,GAAUC,OACxBqF,EAAWx0B,KAAKwtB,GAAOI,iBAErBz3B,EAAY+4B,GAAUE,MACxBoF,EAAWx0B,KAAKwtB,GAAOhR,gBAErBrmB,EAAY+4B,GAAUG,IACxBmF,EAAWx0B,KAAKwtB,GAAO/Q,cAErBtmB,EAAY+4B,GAAUI,MACxBkF,EAAWx0B,KAAKwtB,GAAOG,gBAGlB6G,I,0BAGT,WAAgB,IACNr+B,EAAc0I,KAAK+yB,YAAnBz7B,UAEJq+B,EAAa,GAejB,OAdIr+B,EAAY+4B,GAAUC,OACxBqF,EAAWx0B,KAAKwtB,GAAO/D,sBAErBtzB,EAAY+4B,GAAUE,MACxBoF,EAAWx0B,KAAKwtB,GAAO/D,sBAErBtzB,EAAY+4B,GAAUG,IACxBmF,EAAWx0B,KAAKwtB,GAAOK,oBAErB13B,EAAY+4B,GAAUI,MACxBkF,EAAWx0B,KAAKwtB,GAAOK,oBAIC,KAF1B2G,EAAU,KAAO,IAAIC,IAAID,KAEVh8B,OAAqBg1B,GAAOM,eACjB,IAAtB0G,EAAWh8B,OAAqBg8B,EAAW,GACxChH,GAAOE,gB,sCAGhB,WAWExS,EAXF,GAaE,EAXE7Y,YAWF,EAVEuG,YAUD,IATClB,EASF,EATEA,iBAQagtB,GACf,EAREltB,QAQF,EAPEF,UAOF,EANEC,UAMF,EALE4qB,UAKF,EAJErvB,wBAIF,EADE8F,aAEI+rB,GADN,EAD8BrX,OAC9B,EAD0CC,OAC1C,0CAC0BmX,IAAkBhtB,GAC5C,OAAKitB,GAAqB91B,KAAKsxB,iBACtB,CAAE2B,QAAQ,GAEZ,CAAED,QAAS8C,K,iCAGpB,YAAoE,IAAD,IAA7CjtB,wBAA6C,MAA1B,EAA0B,EAAvBvR,EAAuB,EAAvBA,UAAciF,EAAS,yCACjE,GAAI04B,GAAM39B,IAAmC,kBAAdA,EAC7B,MAAM,IAAIo5B,GAAiB,YAAap5B,EAAW,UAErD,OAAO,iEACLuR,mBACAvR,aACGiF,Q,GA5HyBo4B,I,s0BC4DnBoB,G,0RA/Db,WACE,OAAO,I,sCAGT,WACE,OAAO,I,2CAGT,cAGG,IAFClnB,EAEF,EAFEA,EAAGuP,EAEL,EAFKA,EAAGK,EAER,EAFQA,OAAQC,EAEhB,EAFgBA,OACdjW,EACF,EADEA,UAAWC,EACb,EADaA,UAAW4qB,EACxB,EADwBA,UAExB,SADA,EADmCrvB,yBAG5BjE,KAAK+xB,cAAc,CAAEljB,IAAGuP,SAK7BmX,GAAoB/pB,KAAK+N,IAAIkF,GAAShW,IACtC8sB,GAAoB/pB,KAAK+N,IAAImF,GAAShW,IACtC6sB,GAAoB/pB,KAAK+N,IAAImF,EAASA,EAASD,EAASA,GAAS6U,M,kCAIrE,YAA4C,IAAD,IAApB9U,OAAU3P,EAAU,EAAVA,EAAGuP,EAAO,EAAPA,EAC5B4T,EAAOhyB,KAAKwxB,KAAKS,wBAEvB,MAAO,CACL8C,UAAWlmB,EACXmmB,UAAW5W,EACXvP,EAAGA,EAAImjB,EAAKj1B,KACZqhB,EAAGA,EAAI4T,EAAKl1B,O,sCAIhB,WAEEuf,EAFF,GAIG,IAHC7Y,EAGF,EAHEA,YAAauG,EAGf,EAHeA,YAAsBtB,GAGrC,EAH4BE,QAG5B,EAHqCF,WAAWC,EAGhD,EAHgDA,UAAW4qB,EAG3D,EAH2DA,UAAWrvB,EAGtE,EAHsEA,wBAEvD4xB,EACf,EADE9rB,YAA4ByU,EAC9B,EAD8BA,OAAQC,EACtC,EADsCA,OAAQC,EAC9C,EAD8CA,OAExCoX,GADN,mDAC0BD,GAAiBryB,GAAeqyB,GAAiB9rB,GAE3E,OACE/J,KAAKg2B,8BAAL,SACOxX,GADP,IACeC,SAAQC,WACrB,CACEjW,YACAC,YACA4qB,YACArvB,8BAKF6xB,GAAqB91B,KAAKsxB,iBAErB,CAAE2B,QAAQ,GAGZ,CAAED,QAAS8C,O,GA5DezE,I,s0BCkJtB4E,G,+UA1HbC,oBAAqB,E,iCAhBrB,WACE,MAAO,U,yBAGT,WACE,OAAOjB,GAAMj1B,KAAK9B,OAAOmL,eAAiB,EAAIrJ,KAAK9B,OAAOmL,gB,mBAG5D,WACE,OAAO4rB,GAAMj1B,KAAK9B,OAAOyK,SAAW,EAAI3I,KAAK9B,OAAOyK,U,8BAGtD,WACE,OAAOgmB,GAAOuB,Q,iCAKhB,SAAoB5I,GAElBtnB,KAAKuxB,kBAAmB,EACxBvxB,KAAK+zB,YAAYzM,K,+CAGnB,YAA2E,IAAvCrjB,EAAsC,EAAtCA,wBAAyBqvB,EAAa,EAAbA,UAC3D,OAAOrvB,IAA4BkxB,GAAc7B,K,sBAGnD,SAAStyB,GAAO,IAAD,EACb,OAAO,WACJ2tB,GAAOO,YAAcl2B,KAAMG,OADvB,MAEJw1B,GAAOQ,WAAan2B,KAAMK,QAFtB,MAGJs1B,GAAOS,UAAYp2B,KAAMM,KAHrB,MAIJq1B,GAAOU,aAAer2B,KAAMI,WAJxB,GAKL4H,K,uBAGJ,WACE,OAAKhB,KAAK2yB,6BAQH3yB,KAAK9B,OALH,CACL+F,yBAAyB,EACzBqvB,UAAW,M,6BAMjB,WACE,OAAO,SAAP,+DAGErd,KAAMjW,KAAKqJ,kB,gCAIf,SAAmBiZ,GACjBtiB,KAAKm2B,eAAe7T,K,sCAGtB,YAA2C,IAAhBgC,EAAe,EAAfA,YAEzB,OAAOtkB,KAAKk2B,oBAAsC,UAAhB5R,I,4BAGpC,SAAehC,GAAK,IAAD,OACjBtiB,KAAKsxB,kBAAmB,EACxBjvB,aAAarC,KAAKo2B,qBAClBp2B,KAAKq2B,aAAe/T,EACpBtiB,KAAKo2B,oBAAsBZ,IAAkB,WAC3C,EAAKc,wBAAwB,EAAKD,cAClC,EAAKA,aAAe,OACnBr2B,KAAKu2B,yBAAyBjU,IRhFA,O,qCQmFnC,SAAwBA,GACtBjgB,aAAarC,KAAKo2B,qBAClBp2B,KAAKo2B,oBAAsB,KAC3Bp2B,KAAKkyB,UAAL,SACK5P,GADL,IAEE1C,UAAW+O,GAAOQ,WAClBlO,SAAS,O,6BAIb,SAAgB1iB,GACd,yDAAsBA,GACtB8D,aAAarC,KAAKo2B,qBAClBp2B,KAAKo2B,oBAAsB,KAC3Bp2B,KAAKq2B,aAAe,O,wBAGtB,SAAW/T,GAAK,IAGR9f,EAHO,QACb,oDAAiB8f,GACbA,EAAGpB,SAAWlhB,KAAKsxB,oBAEjBtxB,KAAKo2B,sBAIP5zB,ER3G2C,GQ4G3CxC,KAAKs2B,wBAAwBt2B,KAAKq2B,cAClCr2B,KAAKq2B,aAAe,MAEtBb,IAAkB,WAChB,EAAKtD,UAAL,SACK5P,GADL,IAEE1C,UAAW+O,GAAOS,UAClBlO,SAAS,KAEX,EAAKiT,mBACJ3xB,M,iCAIP,YASI,IAAD,IARDoC,6BAQC,aAPDC,4BAOC,aANDZ,+BAMC,aALDoF,qBAKC,MALe6C,OAAOsnB,IAKtB,MAJD7qB,eAIC,MAJSuD,OAAOsnB,IAIhB,MAHDhwB,mBAGC,MAHa,EAGb,MAFDuG,mBAEC,MAFa,EAEb,EADExN,EACF,yIACD,OAAO,iEACLqI,wBACAC,uBACAZ,0BACAoF,gBACAV,UACAnF,cACAuG,eACGxN,Q,GAvIyBw5B,I,s0BCuCnBS,G,6RA1Cb,WACE,OAAOvB,GAAMj1B,KAAK9B,OAAOmL,eAAiB,IAAMrJ,KAAK9B,OAAOmL,gB,mBAG9D,WACE,OAAO4rB,GAAMj1B,KAAK9B,OAAOyK,SAAW,EAAI3I,KAAK9B,OAAOyK,U,+CAGtD,YAAkD,IAAd2qB,EAAa,EAAbA,UAClC,OAAQ6B,GAAc7B,K,uBAGxB,WACE,OAAKtzB,KAAK2yB,6BAQH3yB,KAAK9B,OALH,CACL+F,yBAAyB,EACzBqvB,UAAW,M,6BAMjB,WACE,OAAO,SAAP,+DAGErd,KAAMjW,KAAKqJ,kB,sBAIf,SAASrI,GAAO,IAAD,EACb,OAAO,WACJ2tB,GAAOO,YAAcl2B,KAAMK,QADvB,MAEJs1B,GAAOQ,WAAan2B,KAAMK,QAFtB,MAGJs1B,GAAOS,UAAYp2B,KAAMM,KAHrB,MAIJq1B,GAAOU,aAAer2B,KAAME,QAJxB,GAKL8H,O,GAvCgCi1B,I,shCC+BvBtxB,G,4RA/Bb,SAAW2d,GAAK,IAAD,OAEb,GADA,oDAAiBA,IACZA,EAAGpB,SAEFkU,GAAoBE,GAAW,CAAEzmB,EAAGyT,EAAG7D,OAAQL,EAAGkE,EAAG5D,SAAW,KAC9D1e,KAAK9B,OAAO2G,qBAgBd,IAfA,IAeA,OAfiBpL,OAAOsrB,OAAOwO,MAAwBl2B,QAAO,SAAA8vB,GAAY,IAChElxB,EAAuCkxB,EAAvClxB,WAAYu1B,EAA2BrE,EAA3BqE,KAAMF,EAAqBnE,EAArBmE,iBAC1B,OAEEr1B,IAAe,EAAKA,YAEpBq1B,GAEAnE,aAAmB4I,IAEnBvE,GACA,EAAKA,KAAKiF,SAASjF,SAIvB,aAAgC,SAEtBkF,gBAAgBpU,Q,GAxBG2T,I,k0BC2OxB3sB,O,oRArOb,WACE,MAAO,Q,8BAGT,WACE,OAAOqlB,GAAOmB,M,6BAGhB,WACE,OAAO,SAAP,+DAEEx4B,UAAW0I,KAAK01B,mB,sBAIpB,SAAS10B,GACP,IAAM21B,EAAS,kDAAkB31B,GAEjC,OACEhB,KAAK2xB,gBAAkB34B,KAAMC,cAC7B09B,IAAc39B,KAAMK,OAEbL,KAAMG,MAERw9B,I,0BAGT,WACE,IAAMz4B,EAAS8B,KAAK+yB,YAElB7oB,EAKEhM,EALFgM,mBACAC,EAIEjM,EAJFiM,iBACAK,EAGEtM,EAHFsM,mBACAC,EAEEvM,EAFFuM,iBACAd,EACEzL,EADFyL,QAEEgsB,EAAa,GACbiB,EAAuB,GAE3B,IAAK3B,GAAMtrB,GACT,OAAOglB,GAAOE,cAGXoG,GAAM/qB,IACT0sB,EAAqBz1B,KAAKwtB,GAAOhR,gBAC9BsX,GAAM9qB,IACTysB,EAAqBz1B,KAAKwtB,GAAOI,iBACC,IAAhC6H,EAAqBj9B,SACvBi9B,EAAuB,CAACjI,GAAO/D,uBAEjC+K,EAAaA,EAAWpZ,OAAOqa,GAC/B,IAAIC,EAAqB,GAYzB,OAVK5B,GAAMzqB,IACTqsB,EAAmB11B,KAAKwtB,GAAO/Q,cAC5BqX,GAAMxqB,IACTosB,EAAmB11B,KAAKwtB,GAAOG,gBAEC,IAA9B+H,EAAmBl9B,SACrBk9B,EAAqB,CAAClI,GAAOK,sBAE/B2G,EAAaA,EAAWpZ,OAAOsa,IAEfl9B,OAIdg8B,EAAW,KAAOhH,GAAO/D,sBACzB+K,EAAW,KAAOhH,GAAOK,oBAIvB4H,EAAqBj9B,QAAUk9B,EAAmBl9B,OAF7Cg1B,GAAOE,cAMT8G,EAAW,GAZThH,GAAOM,iB,uBAelB,WACE,OAAKjvB,KAAK2yB,6BAOH3yB,KAAK9B,OAJH,CACLk1B,UAAW,M,2CAMjB,WAAkD0D,GAAW,IAA7BrY,EAA4B,EAA5BA,OAAQC,EAAoB,EAApBA,OACtC,OACIuW,GAAM6B,EAAS1sB,mBACfqU,EAASqY,EAAS1sB,mBAClB6qB,GAAM6B,EAASzsB,iBAAmBoU,EAASqY,EAASzsB,iBACpD4qB,GAAM6B,EAASpsB,mBACfgU,EAASoY,EAASpsB,mBAClBuqB,GAAM6B,EAASnsB,iBAAmB+T,EAASoY,EAASnsB,iB,+CAI1D,WAAgEmsB,GAAW,IAAvCrY,EAAsC,EAAtCA,OAAQC,EAA8B,EAA9BA,OAAQnR,EAAsB,EAAtBA,SAClD,OACI0nB,GAAM6B,EAAS5sB,qBACfuU,EAASqY,EAAS5sB,qBAClB+qB,GAAM6B,EAAS3sB,mBACfsU,EAASqY,EAAS3sB,mBAClB8qB,GAAM6B,EAAStsB,qBACfkU,EAASoY,EAAStsB,qBAClByqB,GAAM6B,EAASrsB,mBACfiU,EAASoY,EAASrsB,kBACpB2qB,GACEE,GAAW,CAAEzmB,EAAG4P,EAAQL,EAAGM,IAC3BoY,EAAS1D,YAEXgC,GAAoB7nB,EAASsB,EAAGioB,EAASjtB,eACzCurB,GAAoB7nB,EAAS6Q,EAAG0Y,EAAShtB,eACzCsrB,GAAoBE,GAAW/nB,GAAWupB,EAASzD,iB,sCAIvD,YAAmE,IAAxCwC,EAAuC,EAAvCA,cAAe3V,EAAwB,EAAxBA,MAAO0S,EAAiB,EAAjBA,cAC/C,GAAIiD,GAAiB,EACnB,OAAO,EAIT,IAAMkB,EAAavrB,KAAK+N,IAAI2G,EAAQ,GAC9B8W,EAAmBxrB,KAAK+N,IAAIqZ,GAClC,OAAImE,EXtI4C,IW2I5CC,EX1I+C,I,+CWmJrD,SAAkCF,GAChC,OACE3B,GAAc2B,EAAS1D,YACvB+B,GAAc2B,EAASjtB,eACvBsrB,GAAc2B,EAAShtB,eACvBqrB,GAAc2B,EAASzD,gBACvB8B,GAAc2B,EAAS5sB,qBACvBirB,GAAc2B,EAAS3sB,mBACvBgrB,GAAc2B,EAAStsB,qBACvB2qB,GAAc2B,EAASrsB,oB,sCAI3B,SAAyBlO,EAAO8f,EAAYiL,GAC1C,GAAItnB,KAAKg2B,8BAA8B1O,EAAW/qB,GAChD,MAAO,CAAE02B,QAAQ,GAGnB,IAAM1lB,EAAW,CAAEsB,EAAGyY,EAAU7a,UAAW2R,EAAGkJ,EAAUjH,WACxD,OACErgB,KAAK2yB,8BACL3yB,KAAKi3B,kCACH,CAAExY,OAAQ6I,EAAU7I,OAAQC,OAAQ4I,EAAU5I,OAAQnR,YACtDhR,GAIAyD,KAAKk3B,yBAAyB,CAC5BrB,cAAevO,EAAUvd,YACzBmW,MAAOoH,EAAUpH,MACjB0S,cAAetL,EAAUsL,gBAGpB,CACLK,QAAQ,GAGL,CAAED,SAAS,GAEb,CAAEA,SAAS,O,GAvLU2B,I,geCsBjBwC,G,0SA1Bb,WACE,OAAO,I,iCAGT,YAAqE,IAAD,IAA9C3zB,mBAA8C,MAAhC,EAAgC,MAA7BuG,mBAA6B,MAAf,EAAe,EAATxN,EAAS,sCAClE,OAAO,6D,mWAAA,EACLiH,cACAuG,eACGxN,M,sCAIP,WAEE8f,EAFF,GAIG,IAHC7Y,EAGF,EAHEA,YAAauG,EAGf,EAHeA,YAEA8rB,EACf,EADE9rB,YAEF,OAAI8rB,EAAgB9rB,EACX,CAAEkpB,QAAQ,GAGZ,CACLD,QAFwB6C,GAAiBryB,O,GArBR6tB,I,iQCkBxB+F,G,oRAlBb,WACE,MAAO,U,8BAGT,WACE,OAAOzI,GAAOqB,Q,kCAGhB,YAAmD,IAA5B9P,EAA2B,EAA3BA,MAAO3S,EAAoB,EAApBA,SAAUiR,EAAU,EAAVA,OACtC,MAAO,CACL6Y,OAAQ7Y,EAAO3P,EACfyoB,OAAQ9Y,EAAOJ,EACf7Q,WACA2S,a,GAd4BiX,I,mkCCM5BI,GAAW,CACfjuB,qBACAkuB,uB,oRCNA,WACE,MAAO,W,8BAGT,WACE,OAAO7I,GAAOsB,S,kCAGhB,YAAsD,IAA/B9P,EAA8B,EAA9BA,SAAU5S,EAAoB,EAApBA,SAAUiR,EAAU,EAAVA,OACzC,MAAO,CACL2B,UAAWA,EAAWngB,KAAK6yB,iBAAmB1C,GAC9CsH,QAASjZ,EAAO3P,EAChB6oB,QAASlZ,EAAOJ,EAChB7Q,gB,GAd+B4pB,IDQnCC,uBACA/uB,kB,+UEgBAsvB,gBAAkB,SAAArV,GACZ,EAAKoQ,sBAAsB/4B,OAC7B,EAAKi+B,oBAAsBtV,GAGzBA,EAAG1C,YAAc+O,GAAOS,WAC1B,EAAK8C,UAAL,SAAoB5P,GAApB,IAAwB1C,UAAW+O,GAAOQ,cAG5C,EAAK+C,UAAL,SAAoB5P,GAApB,IAAwBpB,SAAS,KACjC,EAAKiT,eAAe7R,K,iCAlCtB,WACE,MAAO,Q,8BAGT,WACE,OAAOqM,GAAOkB,M,sBAGhB,WACE,OAAOoF,GAAMj1B,KAAK9B,OAAOqK,YAAc,IAAMvI,KAAK9B,OAAOqK,a,iCAG3D,SAAoB+e,GACdtnB,KAAKsxB,kBACPtxB,KAAK+zB,YAAYzM,K,gCAIrB,SAAmBhF,GACbtiB,KAAKsxB,kBACPtxB,KAAK23B,gBAAgBrV,K,wBAiBzB,SAAWA,GAAK,IAAD,OAIb,GAHA,oDAAiBA,IAIdtiB,KAAKuxB,mBACLvxB,KAAKsxB,mBAELhP,EAAGpB,QACJ,CAEA,IAAMiM,EAAUntB,KAAKyxB,OAAOv3B,IAAI8F,KAAK5I,MACjC+1B,EAAQ7a,QAAQgK,OAAO6Q,EAAS7K,KAClCjgB,aAAarC,KAAK63B,gBAElB73B,KAAKu0B,QAAQjS,GACbtiB,KAAKkyB,UAAU5P,IAanB,GAVIA,EAAGpB,SAAWoB,EAAGvY,YAAc,GACjC7H,YAAW,WAGL,EAAKovB,kBACP,EAAKyC,YAAYzR,OAKnBtiB,KAAKuxB,iBAKT,GAAIjP,EAAGpB,QAGDoB,EAAGvY,YAAc,GACnB7H,YAAW,WACL,EAAKovB,kBACP,EAAKyC,YAAYzR,MAMvBjgB,aAAarC,KAAKwpB,QAElBxpB,KAAKwpB,OAAStnB,YAAW,WACvB,EAAKqvB,kBAAmB,EACxB,EAAKwC,YAAYzR,KAChBtiB,KAAKuI,iBACH,IAAKvI,KAAKuxB,mBAAqBvxB,KAAKsxB,iBAAkB,CAE3D,IAAMnE,EAAUntB,KAAKyxB,OAAOv3B,IAAI8F,KAAK5I,MACjC+1B,EAAQ7a,QAAQgK,OAAO6Q,EAAS7K,KAClCjgB,aAAarC,KAAK63B,gBAElB73B,KAAKu0B,QAAQjS,GACbtiB,KAAKkyB,UAAU5P,O,6BAKrB,WACE,OAAO,SAAP,+DAEE/jB,MAAOyB,KAAK5I,KACZ8xB,KAAM+L,GAAMj1B,KAAK9B,OAAOsK,cAAgB,EAAIxI,KAAK9B,OAAOsK,aACxD2gB,SAAUnpB,KAAKuI,WACf0N,KACEgf,GAAMj1B,KAAK9B,OAAOoK,gBAA+C,MAA7BtI,KAAK9B,OAAOoK,cAC5C,IACAtI,KAAK9B,OAAOoK,kB,iCAItB,YAYI,IAAD,IAXDrE,+BAWC,aAVDwE,iBAUC,MAVWyD,OAAOsnB,IAUlB,MATD9qB,iBASC,MATWwD,OAAOsnB,IASlB,MARDhrB,oBAQC,MARc,EAQd,MAPDa,qBAOC,MAPe,IAOf,MANDd,kBAMC,MANY2D,OAAOsnB,IAMnB,MALDlrB,cAKC,eALe4D,OAAOsnB,IAKtB,EAJD7qB,gBAIC,MAJS,EAIT,MAHDnF,mBAGC,MAHa,EAGb,MAFDuG,mBAEC,MAFa,EAEb,EADExN,EACF,8JACD,OAAO,iEACL0H,0BACAuE,eACAC,YACAC,YACAW,gBACAd,aACAI,UACAnF,cACAuG,eACGxN,M,4BAIP,WAA0B,IAAD,EACvB8F,aAAarC,KAAKwpB,QADK,2BAAPjtB,EAAO,yBAAPA,EAAO,iBAEvB,4EAAwBA,M,4BAG1B,SAAe4wB,GACTntB,KAAK43B,sBACP53B,KAAK23B,gBAAgB33B,KAAK43B,qBAC1B53B,KAAK43B,oBAAsB,U,GAtJD7B,IFU9BpxB,4BACA6xB,2BACAf,wBAIa,KACbpF,aACAt0B,qBAFa,SAEQH,EAAKC,GACxBiN,QAAQC,KAAK,yBAA0BnN,EAAKC,IAE9CG,uBALa,WAMX8M,QAAQC,KAAK,6BAEfzJ,qBARa,SAQQtB,EAAa/B,EAAYiC,GAC5C,KAAMF,KAAeu5B,IACnB,MAAM,IAAIz3B,MAAJ,iCAA2C9B,EAA3C,8BZvBL,SAA8B/B,EAAYwlB,GAC/C,GAAIxlB,KAAc20B,GAChB,MAAM,IAAI9wB,MAAM,oBAAsB7D,EAAa,mBAErD20B,GAAS30B,GAAcwlB,EACvBmP,GAAS30B,GAAYA,WAAaA,EYoBhCs3B,CAAiCt3B,EAAY,IAAI67B,EAD5BP,GAASv5B,KAE9BgC,KAAKJ,qBAAqB3D,EAAYiC,IAExCwB,qBAfa,SAeQzD,EAAY87B,GAC/BxE,GAAuBt3B,GAAY+7B,QAAQD,IAE7Cn4B,qBAlBa,SAkBQ3D,EAAYmD,GAC/Bm0B,GAAuBt3B,GAAYg8B,oBAAoB74B,IAEzD84B,sBArBa,SAqBSj8B,GACpB,OAAOs3B,GAAuBt3B,IAEhC8D,mBAxBa,SAwBM9D,IZ7Bd,SAA4BA,GACjC40B,GAAW50B,GAAY0mB,iBAChBiO,GAAS30B,GY4Bds3B,CAA+Bt3B,M,qBG9CnC,6BACI,aAEA,IAAImH,EAAOjD,aAAX,CAIA,IAIIg4B,EAJAC,EAAa,EACbC,EAAgB,GAChBC,GAAwB,EACxBxW,EAAM1e,EAAOgW,SAoJbmf,EAAW9+B,OAAO++B,gBAAkB/+B,OAAO++B,eAAep1B,GAC9Dm1B,EAAWA,GAAYA,EAASr2B,WAAaq2B,EAAWn1B,EAGf,qBAArC,GAAGq1B,SAASh+B,KAAK2I,EAAO2lB,SApFxBoP,EAAoB,SAAS76B,GACzByrB,EAAQ2P,UAAS,WAAcC,EAAar7B,OAIpD,WAGI,GAAI8F,EAAOw1B,cAAgBx1B,EAAOy1B,cAAe,CAC7C,IAAIC,GAA4B,EAC5BC,EAAe31B,EAAO41B,UAM1B,OALA51B,EAAO41B,UAAY,WACfF,GAA4B,GAEhC11B,EAAOw1B,YAAY,GAAI,KACvBx1B,EAAO41B,UAAYD,EACZD,GAwEJG,GApEX,WAKI,IAAIC,EAAgB,gBAAkB1tB,KAAK2tB,SAAW,IAClDC,EAAkB,SAAS76B,GACvBA,EAAM6Z,SAAWhV,GACK,kBAAf7E,EAAMwuB,MACyB,IAAtCxuB,EAAMwuB,KAAK3nB,QAAQ8zB,IACnBP,GAAcp6B,EAAMwuB,KAAK/S,MAAMkf,EAAcv/B,UAIjDyJ,EAAOse,iBACPte,EAAOse,iBAAiB,UAAW0X,GAAiB,GAEpDh2B,EAAOi2B,YAAY,YAAaD,GAGpCjB,EAAoB,SAAS76B,GACzB8F,EAAOw1B,YAAYM,EAAgB57B,EAAQ,MAiD/Cg8B,GAEOl2B,EAAOm2B,eA/ClB,WACI,IAAIC,EAAU,IAAID,eAClBC,EAAQC,MAAMT,UAAY,SAASz6B,GAE/Bo6B,EADap6B,EAAMwuB,OAIvBoL,EAAoB,SAAS76B,GACzBk8B,EAAQE,MAAMd,YAAYt7B,IAyC9Bq8B,GAEO7X,GAAO,uBAAwBA,EAAIzI,cAAc,UAvC5D,WACI,IAAIugB,EAAO9X,EAAI+X,gBACf1B,EAAoB,SAAS76B,GAGzB,IAAIw8B,EAAShY,EAAIzI,cAAc,UAC/BygB,EAAOC,mBAAqB,WACxBpB,EAAar7B,GACbw8B,EAAOC,mBAAqB,KAC5BH,EAAKI,YAAYF,GACjBA,EAAS,MAEbF,EAAKK,YAAYH,IA6BrBI,GAxBA/B,EAAoB,SAAS76B,GACzB4E,WAAWy2B,EAAc,EAAGr7B,IA8BpCi7B,EAASp4B,aA1KT,SAAsBgiB,GAEI,oBAAbA,IACTA,EAAW,IAAIvgB,SAAS,GAAKugB,IAI/B,IADA,IAAI9G,EAAO,IAAIne,MAAMkF,UAAUzI,OAAS,GAC/BD,EAAI,EAAGA,EAAI2hB,EAAK1hB,OAAQD,IAC7B2hB,EAAK3hB,GAAK0I,UAAU1I,EAAI,GAG5B,IAAIygC,EAAO,CAAEhY,SAAUA,EAAU9G,KAAMA,GAGvC,OAFAgd,EAAcD,GAAc+B,EAC5BhC,EAAkBC,GACXA,KA6JTG,EAASr4B,eAAiBA,EA1J1B,SAASA,EAAe5C,UACb+6B,EAAc/6B,GAyBzB,SAASq7B,EAAar7B,GAGlB,GAAIg7B,EAGAp2B,WAAWy2B,EAAc,EAAGr7B,OACzB,CACH,IAAI68B,EAAO9B,EAAc/6B,GACzB,GAAI68B,EAAM,CACN7B,GAAwB,EACxB,KAjCZ,SAAa6B,GACT,IAAIhY,EAAWgY,EAAKhY,SAChB9G,EAAO8e,EAAK9e,KAChB,OAAQA,EAAK1hB,QACb,KAAK,EACDwoB,IACA,MACJ,KAAK,EACDA,EAAS9G,EAAK,IACd,MACJ,KAAK,EACD8G,EAAS9G,EAAK,GAAIA,EAAK,IACvB,MACJ,KAAK,EACD8G,EAAS9G,EAAK,GAAIA,EAAK,GAAIA,EAAK,IAChC,MACJ,QACI8G,EAASxgB,WAnDrB,EAmDsC0Z,IAiBlB+e,CAAID,GACN,QACEj6B,EAAe5C,GACfg7B,GAAwB,MAvE5C,CAyLkB,qBAAT72B,KAAyC,qBAAX2B,EAAyBpD,KAAOoD,EAAS3B,Q,0DC/KhF,IAAI44B,EAAa,GACbC,EAAa,GA+GjBngC,EAAOC,QArGP,SAAkB4qB,EAAGC,GACnB,IAAIsV,EAASF,EAAW1gC,OAAS0gC,EAAWG,MAAQ,GAChDC,EAASH,EAAW3gC,OAAS2gC,EAAWE,MAAQ,GAChDE,EAQN,SAASC,EAAG3V,EAAGC,EAAGsV,EAAQE,GACxB,GAAIzV,IAAMC,EAER,OAAa,IAAND,GAAW,EAAIA,GAAK,EAAIC,EAGjC,GAAS,MAALD,GAAkB,MAALC,EAEf,OAAO,EAGT,GAAgB,iBAALD,GAA6B,iBAALC,EACjC,OAAO,EAGT,IAAI2V,EAAWnhC,OAAOoI,UAAU42B,SAC5BoC,EAAYD,EAASngC,KAAKuqB,GAE9B,GAAI6V,GAAaD,EAASngC,KAAKwqB,GAC7B,OAAO,EAGT,OAAQ4V,GACN,IAAK,kBACH,OAAO7V,GAAK8V,OAAO7V,GAErB,IAAK,kBACH,OAAOiQ,MAAMlQ,KAAMkQ,MAAMjQ,IAAaD,GAAK9Y,OAAO+Y,GAEpD,IAAK,gBACL,IAAK,mBACH,OAAQD,IAAMC,EAEhB,IAAK,kBACH,OAAOD,EAAE5M,QAAU6M,EAAE7M,QAAU4M,EAAE5hB,QAAU6hB,EAAE7hB,QAAU4hB,EAAE+V,WAAa9V,EAAE8V,WAAa/V,EAAEgW,YAAc/V,EAAE+V,WAI3G,IAAIrhC,EAAS4gC,EAAO5gC,OAEpB,KAAOA,KACL,GAAI4gC,EAAO5gC,IAAWqrB,EACpB,OAAOyV,EAAO9gC,IAAWsrB,EAI7BsV,EAAOp5B,KAAK6jB,GACZyV,EAAOt5B,KAAK8jB,GACZ,IAAI5tB,EAAO,EAEX,GAAkB,mBAAdwjC,EAAgC,CAGlC,IAFAxjC,EAAO2tB,EAAErrB,UAEIsrB,EAAEtrB,OACb,OAAO,EAIT,KAAOtC,KACL,IAAKsjC,EAAG3V,EAAE3tB,GAAO4tB,EAAE5tB,GAAOkjC,EAAQE,GAChC,OAAO,MAGN,CACL,GAAIzV,EAAE3kB,cAAgB4kB,EAAE5kB,YACtB,OAAO,EAGT,GAAI2kB,EAAE3M,eAAe,YAAc4M,EAAE5M,eAAe,WAClD,OAAO2M,EAAEiW,WAAahW,EAAEgW,UAG1B,IAAIzhC,EAAOC,OAAOD,KAAKwrB,GAEvB,GAAIxrB,EAAKG,QAAUF,OAAOD,KAAKyrB,GAAGtrB,OAChC,OAAO,EAGT,IAAK,IAAID,EAAI,EAAGA,EAAIF,EAAKG,OAAQD,IAC/B,IAAKihC,EAAG3V,EAAExrB,EAAKE,IAAKurB,EAAEzrB,EAAKE,IAAK6gC,EAAQE,GACtC,OAAO,EAOb,OAFAF,EAAOC,MACPC,EAAOD,OACA,EA/FMG,CAAG3V,EAAGC,EAAGsV,EAAQE,GAK9B,OAJAF,EAAO5gC,OAAS,EAChB8gC,EAAO9gC,OAAS,EAChB0gC,EAAWl5B,KAAKo5B,GAChBD,EAAWn5B,KAAKs5B,GACTC,I,oBC7BT,IAAIlC,EAAiB,EAAQ,IAW7Br+B,EAAOC,QATP,SAAwB0J,EAAQ/J,GAC9B,MAAQN,OAAOoI,UAAUwW,eAAe5d,KAAKqJ,EAAQ/J,IAEpC,QADf+J,EAAS00B,EAAe10B,MAI1B,OAAOA,GAIT3J,EAAOC,QAAiB,QAAID,EAAOC,QAASD,EAAOC,QAAQC,YAAa","file":"static/js/1.f002a00b.chunk.js","sourcesContent":["import * as React from 'react';\nimport { StyleSheet, StyleProp, ViewStyle } from 'react-native';\nimport Text from '../Typography/Text';\nimport TouchableRipple from '../TouchableRipple/TouchableRipple';\nimport type { $RemoveChildren } from '../../types';\n\ntype Props = $RemoveChildren<typeof TouchableRipple> & {\n  /**\n   * Content of the `DataTableCell`.\n   */\n  children: React.ReactNode;\n  /**\n   * Align the text to the right. Generally monetary or number fields are aligned to right.\n   */\n  numeric?: boolean;\n  /**\n   * Function to execute on press.\n   */\n  onPress?: () => void;\n  style?: StyleProp<ViewStyle>;\n};\n\n/**\n * A component to show a single cell inside of a table.\n *\n * <div class=\"screenshots\">\n *   <figure>\n *     <img class=\"medium\" src=\"screenshots/data-table-row-cell.png\" />\n *   </figure>\n * </div>\n *\n *\n * ## Usage\n * ```js\n * import * as React from 'react';\n * import { DataTable } from 'react-native-paper';\n *\n * const MyComponent = () => (\n *      <DataTable.Row>\n *        <DataTable.Cell numeric>1</DataTable.Cell>\n *        <DataTable.Cell numeric>2</DataTable.Cell>\n *        <DataTable.Cell numeric>3</DataTable.Cell>\n *        <DataTable.Cell numeric>4</DataTable.Cell>\n *      </DataTable.Row>\n * );\n *\n * export default MyComponent;\n * ```\n *\n * If you want to support multiline text, please use View instead, as multiline text doesn't comply with\n * MD Guidelines (https://github.com/callstack/react-native-paper/issues/2381).\n */\n\nconst DataTableCell = ({ children, style, numeric, ...rest }: Props) => (\n  <TouchableRipple\n    {...rest}\n    style={[styles.container, numeric && styles.right, style]}\n  >\n    <Text numberOfLines={1}>{children}</Text>\n  </TouchableRipple>\n);\n\nDataTableCell.displayName = 'DataTable.Cell';\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    flexDirection: 'row',\n    alignItems: 'center',\n  },\n\n  right: {\n    justifyContent: 'flex-end',\n  },\n});\n\nexport default DataTableCell;\n","import * as React from 'react';\nimport color from 'color';\nimport { StyleSheet, StyleProp, View, ViewStyle } from 'react-native';\nimport { black, white } from '../../styles/colors';\nimport { withTheme } from '../../core/theming';\n\ntype Props = React.ComponentPropsWithRef<typeof View> & {\n  /**\n   * Content of the `DataTableHeader`.\n   */\n  children: React.ReactNode;\n  style?: StyleProp<ViewStyle>;\n  /**\n   * @optional\n   */\n  theme: ReactNativePaper.Theme;\n};\n\n/**\n * A component to display title in table header.\n *\n * <div class=\"screenshots\">\n *   <figure>\n *     <img class=\"medium\" src=\"screenshots/data-table-header.png\" />\n *   </figure>\n * </div>\n *\n *\n * ## Usage\n * ```js\n * import * as React from 'react';\n * import { DataTable } from 'react-native-paper';\n *\n * const MyComponent = () => (\n *       <DataTable>\n *         <DataTable.Header>\n *           <DataTable.Title\n *             sortDirection='descending'\n *           >\n *             Dessert\n *           </DataTable.Title>\n *           <DataTable.Title numeric>Calories</DataTable.Title>\n *           <DataTable.Title numeric>Fat (g)</DataTable.Title>\n *         </DataTable.Header>\n *       </DataTable>\n * );\n *\n * export default MyComponent;\n * ```\n */\n\nconst DataTableHeader = ({ children, style, theme, ...rest }: Props) => {\n  const borderBottomColor = color(theme.dark ? white : black)\n    .alpha(0.12)\n    .rgb()\n    .string();\n\n  return (\n    <View {...rest} style={[styles.header, { borderBottomColor }, style]}>\n      {children}\n    </View>\n  );\n};\n\nDataTableHeader.displayName = 'DataTable.Header';\n\nconst styles = StyleSheet.create({\n  header: {\n    flexDirection: 'row',\n    height: 48,\n    paddingHorizontal: 16,\n    borderBottomWidth: StyleSheet.hairlineWidth * 2,\n  },\n});\n\nexport default withTheme(DataTableHeader);\n\n// @component-docs ignore-next-line\nexport { DataTableHeader };\n","import * as React from 'react';\nimport {\n  Animated,\n  StyleProp,\n  StyleSheet,\n  TouchableWithoutFeedback,\n  View,\n  ViewStyle,\n  I18nManager,\n} from 'react-native';\nimport color from 'color';\nimport MaterialCommunityIcon from '../MaterialCommunityIcon';\nimport Text from '../Typography/Text';\nimport { withTheme } from '../../core/theming';\n\ntype Props = React.ComponentPropsWithRef<typeof TouchableWithoutFeedback> & {\n  /**\n   * Text content of the `DataTableTitle`.\n   */\n  children: React.ReactNode;\n  /**\n   * Align the text to the right. Generally monetary or number fields are aligned to right.\n   */\n  numeric?: boolean;\n  /**\n   * Direction of sorting. An arrow indicating the direction is displayed when this is given.\n   */\n  sortDirection?: 'ascending' | 'descending';\n  /**\n   * The number of lines to show.\n   */\n  numberOfLines?: number;\n  /**\n   * Function to execute on press.\n   */\n  onPress?: () => void;\n  style?: StyleProp<ViewStyle>;\n  /**\n   * @optional\n   */\n  theme: ReactNativePaper.Theme;\n};\n\n/**\n * A component to display title in table header.\n *\n * <div class=\"screenshots\">\n *   <figure>\n *     <img class=\"medium\" src=\"screenshots/data-table-header.png\" />\n *   </figure>\n * </div>\n *\n *\n * ## Usage\n * ```js\n * import * as React from 'react';\n * import { DataTable } from 'react-native-paper';\n *\n * const MyComponent = () => (\n *       <DataTable>\n *         <DataTable.Header>\n *           <DataTable.Title\n *             sortDirection='descending'\n *           >\n *             Dessert\n *           </DataTable.Title>\n *           <DataTable.Title numeric>Calories</DataTable.Title>\n *           <DataTable.Title numeric>Fat (g)</DataTable.Title>\n *         </DataTable.Header>\n *       </DataTable>\n * );\n *\n * export default MyComponent;\n * ```\n */\n\nconst DataTableTitle = ({\n  numeric,\n  children,\n  onPress,\n  sortDirection,\n  theme,\n  style,\n  numberOfLines = 1,\n  ...rest\n}: Props) => {\n  const { current: spinAnim } = React.useRef<Animated.Value>(\n    new Animated.Value(sortDirection === 'ascending' ? 0 : 1)\n  );\n\n  React.useEffect(() => {\n    Animated.timing(spinAnim, {\n      toValue: sortDirection === 'ascending' ? 0 : 1,\n      duration: 150,\n      useNativeDriver: true,\n    }).start();\n  }, [sortDirection, spinAnim]);\n\n  const textColor = color(theme.colors.text).alpha(0.6).rgb().string();\n\n  const spin = spinAnim.interpolate({\n    inputRange: [0, 1],\n    outputRange: ['0deg', '180deg'],\n  });\n\n  const icon = sortDirection ? (\n    <Animated.View style={[styles.icon, { transform: [{ rotate: spin }] }]}>\n      <MaterialCommunityIcon\n        name=\"arrow-up\"\n        size={16}\n        color={theme.colors.text}\n        direction={I18nManager.isRTL ? 'rtl' : 'ltr'}\n      />\n    </Animated.View>\n  ) : null;\n\n  return (\n    <TouchableWithoutFeedback disabled={!onPress} onPress={onPress} {...rest}>\n      <View style={[styles.container, numeric && styles.right, style]}>\n        {icon}\n\n        <Text\n          style={[\n            styles.cell,\n            sortDirection ? styles.sorted : { color: textColor },\n          ]}\n          numberOfLines={numberOfLines}\n        >\n          {children}\n        </Text>\n      </View>\n    </TouchableWithoutFeedback>\n  );\n};\n\nDataTableTitle.displayName = 'DataTable.Title';\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    flexDirection: 'row',\n    alignContent: 'center',\n    paddingVertical: 12,\n  },\n\n  right: {\n    justifyContent: 'flex-end',\n  },\n\n  cell: {\n    height: 24,\n    lineHeight: 24,\n    fontSize: 12,\n    fontWeight: '500',\n    alignItems: 'center',\n  },\n\n  sorted: {\n    marginLeft: 8,\n  },\n\n  icon: {\n    height: 24,\n    justifyContent: 'center',\n  },\n});\n\nexport default withTheme(DataTableTitle);\n\n// @component-docs ignore-next-line\nexport { DataTableTitle };\n","import * as React from 'react';\nimport {\n  StyleSheet,\n  StyleProp,\n  View,\n  ViewStyle,\n  I18nManager,\n} from 'react-native';\nimport color from 'color';\nimport IconButton from '../IconButton';\nimport Text from '../Typography/Text';\nimport { withTheme } from '../../core/theming';\nimport MaterialCommunityIcon from '../MaterialCommunityIcon';\n\ntype Props = React.ComponentPropsWithRef<typeof View> & {\n  /**\n   * The currently visible page (starting with 0).\n   */\n  page: number;\n  /**\n   * The total number of pages.\n   */\n  numberOfPages: number;\n  /**\n   * Label text to display\n   */\n  label?: React.ReactNode;\n  /**\n   * Function to execute on page change.\n   */\n  onPageChange: (page: number) => void;\n  style?: StyleProp<ViewStyle>;\n  /**\n   * @optional\n   */\n  theme: ReactNativePaper.Theme;\n};\n\n/**\n * A component to show pagination for data table.\n *\n * <div class=\"screenshots\">\n *   <figure>\n *     <img class=\"medium\" src=\"screenshots/data-table-pagination.png\" />\n *   </figure>\n * </div>\n *\n *\n * ## Usage\n * ```js\n * import * as React from 'react';\n * import { DataTable } from 'react-native-paper';\n *\n * const itemsPerPage = 2;\n *\n * const items = [\n *   {\n *     key: 1,\n *     name: 'Page 1',\n *   },\n *   {\n *     key: 2,\n *     name: 'Page 2',\n *   },\n *   {\n *     key: 3,\n *     name: 'Page 3',\n *   },\n * ];\n *\n * const MyComponent = () => {\n *   const [page, setPage] = React.useState(0);\n *   const from = page * itemsPerPage;\n *   const to = (page + 1) * itemsPerPage;\n *\n *   return (\n *     <DataTable>\n *       <DataTable.Pagination\n *         page={page}\n *         numberOfPages={Math.floor(items.length / itemsPerPage)}\n *         onPageChange={page => setPage(page)}\n *         label={`${from + 1}-${to} of ${items.length}`}\n *       />\n *     </DataTable>\n *   );\n * };\n *\n * export default MyComponent;\n * ```\n */\n\nconst DataTablePagination = ({\n  label,\n  page,\n  numberOfPages,\n  onPageChange,\n  style,\n  theme,\n  ...rest\n}: Props) => {\n  const labelColor = color(theme.colors.text).alpha(0.6).rgb().string();\n\n  return (\n    <View {...rest} style={[styles.container, style]}>\n      <Text style={[styles.label, { color: labelColor }]} numberOfLines={1}>\n        {label}\n      </Text>\n      <IconButton\n        icon={({ size, color }) => (\n          <MaterialCommunityIcon\n            name=\"chevron-left\"\n            color={color}\n            size={size}\n            direction={I18nManager.isRTL ? 'rtl' : 'ltr'}\n          />\n        )}\n        color={theme.colors.text}\n        disabled={page === 0}\n        onPress={() => onPageChange(page - 1)}\n      />\n      <IconButton\n        icon={({ size, color }) => (\n          <MaterialCommunityIcon\n            name=\"chevron-right\"\n            color={color}\n            size={size}\n            direction={I18nManager.isRTL ? 'rtl' : 'ltr'}\n          />\n        )}\n        color={theme.colors.text}\n        disabled={numberOfPages === 0 || page === numberOfPages - 1}\n        onPress={() => onPageChange(page + 1)}\n      />\n    </View>\n  );\n};\n\nDataTablePagination.displayName = 'DataTable.Pagination';\n\nconst styles = StyleSheet.create({\n  container: {\n    justifyContent: 'flex-end',\n    flexDirection: 'row',\n    alignItems: 'center',\n    paddingLeft: 16,\n  },\n\n  label: {\n    fontSize: 12,\n    marginRight: 44,\n  },\n});\n\nexport default withTheme(DataTablePagination);\n\n// @component-docs ignore-next-line\nexport { DataTablePagination };\n","import * as React from 'react';\nimport color from 'color';\nimport {\n  StyleSheet,\n  StyleProp,\n  View,\n  ViewStyle,\n  ViewProps,\n} from 'react-native';\nimport TouchableRipple from '../TouchableRipple/TouchableRipple';\nimport { black, white } from '../../styles/colors';\nimport { withTheme } from '../../core/theming';\nimport type { $RemoveChildren } from '../../types';\n\ntype Props = $RemoveChildren<typeof TouchableRipple> & {\n  /**\n   * Content of the `DataTableRow`.\n   */\n  children: React.ReactNode;\n  /**\n   * Function to execute on press.\n   */\n  onPress?: () => void;\n  style?: StyleProp<ViewStyle>;\n  /**\n   * @optional\n   */\n  theme: ReactNativePaper.Theme;\n  /**\n   * `pointerEvents` passed to the `View` container, which is wrapping children within `TouchableRipple`.\n   */\n  pointerEvents?: ViewProps['pointerEvents'];\n};\n\n/**\n * A component to show a single row inside of a table.\n *\n * <div class=\"screenshots\">\n *   <figure>\n *     <img class=\"medium\" src=\"screenshots/data-table-row-cell.png\" />\n *   </figure>\n * </div>\n *\n *\n * ## Usage\n * ```js\n * import * as React from 'react';\n * import { DataTable } from 'react-native-paper';\n *\n * const MyComponent = () => (\n *      <DataTable.Row>\n *        <DataTable.Cell numeric>1</DataTable.Cell>\n *        <DataTable.Cell numeric>2</DataTable.Cell>\n *        <DataTable.Cell numeric>3</DataTable.Cell>\n *        <DataTable.Cell numeric>4</DataTable.Cell>\n *      </DataTable.Row>\n * );\n *\n * export default MyComponent;\n * ```\n */\n\nconst DataTableRow = ({\n  onPress,\n  style,\n  theme,\n  children,\n  pointerEvents,\n  ...rest\n}: Props) => {\n  const borderBottomColor = color(theme.dark ? white : black)\n    .alpha(0.12)\n    .rgb()\n    .string();\n\n  return (\n    <TouchableRipple\n      {...rest}\n      onPress={onPress}\n      style={[styles.container, { borderBottomColor }, style]}\n    >\n      <View style={styles.content} pointerEvents={pointerEvents}>\n        {children}\n      </View>\n    </TouchableRipple>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: {\n    borderStyle: 'solid',\n    borderBottomWidth: StyleSheet.hairlineWidth,\n    minHeight: 48,\n    paddingHorizontal: 16,\n  },\n  content: {\n    flex: 1,\n    flexDirection: 'row',\n  },\n});\n\nexport default withTheme(DataTableRow);\n\n// @component-docs ignore-next-line\nexport { DataTableRow };\n","import * as React from 'react';\nimport { StyleSheet, StyleProp, View, ViewStyle } from 'react-native';\nimport DataTableCell from './DataTableCell';\nimport DataTableHeader, {\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  DataTableHeader as _DataTableHeader,\n} from './DataTableHeader';\nimport DataTableTitle, {\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  DataTableTitle as _DataTableTitle,\n} from './DataTableTitle';\nimport DataTablePagination, {\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  DataTablePagination as _DataTablePagination,\n} from './DataTablePagination';\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nimport DataTableRow, { DataTableRow as _DataTableRow } from './DataTableRow';\n\ntype Props = React.ComponentPropsWithRef<typeof View> & {\n  /**\n   * Content of the `DataTable`.\n   */\n  children: React.ReactNode;\n  style?: StyleProp<ViewStyle>;\n};\n\n/**\n * Data tables allow displaying sets of data.\n *\n * <div class=\"screenshots\">\n *   <figure>\n *     <img src=\"screenshots/data-table.png\" />\n *     <figcaption>Data table</figcaption>\n *   </figure>\n * </div>\n *\n * ## Usage\n * ```js\n * import * as React from 'react';\n * import { DataTable } from 'react-native-paper';\n *\n * const MyComponent = () => (\n *   <DataTable>\n *     <DataTable.Header>\n *       <DataTable.Title>Dessert</DataTable.Title>\n *       <DataTable.Title numeric>Calories</DataTable.Title>\n *       <DataTable.Title numeric>Fat</DataTable.Title>\n *     </DataTable.Header>\n *\n *     <DataTable.Row>\n *       <DataTable.Cell>Frozen yogurt</DataTable.Cell>\n *       <DataTable.Cell numeric>159</DataTable.Cell>\n *       <DataTable.Cell numeric>6.0</DataTable.Cell>\n *     </DataTable.Row>\n *\n *     <DataTable.Row>\n *       <DataTable.Cell>Ice cream sandwich</DataTable.Cell>\n *       <DataTable.Cell numeric>237</DataTable.Cell>\n *       <DataTable.Cell numeric>8.0</DataTable.Cell>\n *     </DataTable.Row>\n *\n *     <DataTable.Pagination\n *       page={1}\n *       numberOfPages={3}\n *       onPageChange={page => {\n *         console.log(page);\n *       }}\n *       label=\"1-2 of 6\"\n *     />\n *   </DataTable>\n * );\n *\n * export default MyComponent;\n * ```\n */\nconst DataTable = ({ children, style, ...rest }: Props) => (\n  <View {...rest} style={[styles.container, style]}>\n    {children}\n  </View>\n);\n\n// @component ./DataTableHeader.tsx\nDataTable.Header = DataTableHeader;\n\n// @component ./DataTableTitle.tsx\nDataTable.Title = DataTableTitle;\n\n// @component ./DataTableRow.tsx\nDataTable.Row = DataTableRow;\n\n// @component ./DataTableCell.tsx\nDataTable.Cell = DataTableCell;\n\n// @component ./DataTablePagination.tsx\nDataTable.Pagination = DataTablePagination;\n\nconst styles = StyleSheet.create({\n  container: {\n    width: '100%',\n  },\n});\n\nexport default DataTable;\n","const State = {\n  UNDETERMINED: 0,\n  FAILED: 1,\n  BEGAN: 2,\n  CANCELLED: 3,\n  ACTIVE: 4,\n  END: 5,\n};\n\nState.print = state => {\n  const keys = Object.keys(State);\n  for (let i = 0; i < keys.length; i++) {\n    if (state === State[keys[i]]) {\n      return keys[i];\n    }\n  }\n};\n\nexport default State;\n","var superPropBase = require(\"./superPropBase.js\");\n\nfunction _get(target, property, receiver) {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    module.exports = _get = Reflect.get;\n    module.exports[\"default\"] = module.exports, module.exports.__esModule = true;\n  } else {\n    module.exports = _get = function _get(target, property, receiver) {\n      var base = superPropBase(target, property);\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n\n      if (desc.get) {\n        return desc.get.call(receiver);\n      }\n\n      return desc.value;\n    };\n\n    module.exports[\"default\"] = module.exports, module.exports.__esModule = true;\n  }\n\n  return _get(target, property, receiver || target);\n}\n\nmodule.exports = _get;\nmodule.exports[\"default\"] = module.exports, module.exports.__esModule = true;","import React from 'react';\nimport {\n  findNodeHandle as findNodeHandleRN,\n  NativeModules,\n  Touchable,\n  Platform,\n} from 'react-native';\nimport deepEqual from 'fbjs/lib/areEqual';\nimport RNGestureHandlerModule from './RNGestureHandlerModule';\nimport State from './State';\n\nfunction findNodeHandle(node) {\n  if (Platform.OS === 'web') return node;\n  return findNodeHandleRN(node);\n}\n\nconst { UIManager = {} } = NativeModules;\n\nconst customGHEventsConfig = {\n  onGestureHandlerEvent: { registrationName: 'onGestureHandlerEvent' },\n  onGestureHandlerStateChange: {\n    registrationName: 'onGestureHandlerStateChange',\n  },\n};\n\n// Add gesture specific events to genericDirectEventTypes object exported from UIManager\n// native module.\n// Once new event types are registered with react it is possible to dispatch these\n// events to all kind of native views.\nUIManager.genericDirectEventTypes = {\n  ...UIManager.genericDirectEventTypes,\n  ...customGHEventsConfig,\n};\n// In newer versions of RN the `genericDirectEventTypes` is located in the object\n// returned by UIManager.getConstants(), we need to add it there as well to make\n// it compatible with RN 61+\nif (UIManager.getConstants) {\n  UIManager.getConstants().genericDirectEventTypes = {\n    ...UIManager.getConstants().genericDirectEventTypes,\n    ...customGHEventsConfig,\n  };\n}\n\n// Wrap JS responder calls and notify gesture handler manager\nconst {\n  setJSResponder: oldSetJSResponder = () => {},\n  clearJSResponder: oldClearJSResponder = () => {},\n} = UIManager;\nUIManager.setJSResponder = (tag, blockNativeResponder) => {\n  RNGestureHandlerModule.handleSetJSResponder(tag, blockNativeResponder);\n  oldSetJSResponder(tag, blockNativeResponder);\n};\nUIManager.clearJSResponder = () => {\n  RNGestureHandlerModule.handleClearJSResponder();\n  oldClearJSResponder();\n};\n\nlet handlerTag = 1;\nconst handlerIDToTag = {};\n\nfunction isConfigParam(param, name) {\n  // param !== Object(param) returns false if `param` is a function\n  // or an object and returns true if `param` is null\n  return (\n    param !== undefined &&\n    (param !== Object(param) || !('__isNative' in param)) &&\n    name !== 'onHandlerStateChange' &&\n    name !== 'onGestureEvent'\n  );\n}\n\nfunction filterConfig(props, validProps, defaults = {}) {\n  const res = { ...defaults };\n  Object.keys(validProps).forEach(key => {\n    const value = props[key];\n    if (isConfigParam(value, key)) {\n      let value = props[key];\n      if (key === 'simultaneousHandlers' || key === 'waitFor') {\n        value = transformIntoHandlerTags(props[key]);\n      } else if (key === 'hitSlop') {\n        if (typeof value !== 'object') {\n          value = { top: value, left: value, bottom: value, right: value };\n        }\n      }\n      res[key] = value;\n    }\n  });\n  return res;\n}\n\nfunction transformIntoHandlerTags(handlerIDs) {\n  if (!Array.isArray(handlerIDs)) {\n    handlerIDs = [handlerIDs];\n  }\n\n  if (Platform.OS === 'web') {\n    return handlerIDs.map(({ current }) => current).filter(handle => handle);\n  }\n  // converts handler string IDs into their numeric tags\n  return handlerIDs\n    .map(\n      handlerID =>\n        handlerIDToTag[handlerID] ||\n        (handlerID.current && handlerID.current._handlerTag) ||\n        -1\n    )\n    .filter(handlerTag => handlerTag > 0);\n}\n\nfunction hasUnresolvedRefs(props) {\n  const extract = refs => {\n    if (!Array.isArray(refs)) {\n      return refs && refs.current === null;\n    }\n    return refs.some(r => r && r.current === null);\n  };\n  return extract(props['simultaneousHandlers']) || extract(props['waitFor']);\n}\n\nconst stateToPropMappings = {\n  [State.BEGAN]: 'onBegan',\n  [State.FAILED]: 'onFailed',\n  [State.CANCELLED]: 'onCancelled',\n  [State.ACTIVE]: 'onActivated',\n  [State.END]: 'onEnded',\n};\n\nexport default function createHandler(\n  handlerName,\n  propTypes = {},\n  config = {},\n  transformProps,\n  customNativeProps = {}\n) {\n  class Handler extends React.Component {\n    static displayName = handlerName;\n\n    static propTypes = propTypes;\n\n    constructor(props) {\n      super(props);\n      this._handlerTag = handlerTag++;\n      this._config = {};\n      if (props.id) {\n        if (handlerIDToTag[props.id] !== undefined) {\n          throw new Error(`Handler with ID \"${props.id}\" already registered`);\n        }\n        handlerIDToTag[props.id] = this._handlerTag;\n      }\n    }\n\n    _onGestureHandlerEvent = event => {\n      if (event.nativeEvent.handlerTag === this._handlerTag) {\n        this.props.onGestureEvent && this.props.onGestureEvent(event);\n      } else {\n        this.props.onGestureHandlerEvent &&\n          this.props.onGestureHandlerEvent(event);\n      }\n    };\n\n    _onGestureHandlerStateChange = event => {\n      if (event.nativeEvent.handlerTag === this._handlerTag) {\n        this.props.onHandlerStateChange &&\n          this.props.onHandlerStateChange(event);\n\n        const stateEventName = stateToPropMappings[event.nativeEvent.state];\n        if (typeof this.props[stateEventName] === 'function') {\n          this.props[stateEventName](event);\n        }\n      } else {\n        this.props.onGestureHandlerStateChange &&\n          this.props.onGestureHandlerStateChange(event);\n      }\n    };\n\n    _refHandler = node => {\n      this._viewNode = node;\n\n      const child = React.Children.only(this.props.children);\n      const { ref } = child;\n      if (ref !== null) {\n        if (typeof ref === 'function') {\n          ref(node);\n        } else {\n          ref.current = node;\n        }\n      }\n    };\n\n    _createGestureHandler = newConfig => {\n      this._config = newConfig;\n\n      RNGestureHandlerModule.createGestureHandler(\n        handlerName,\n        this._handlerTag,\n        newConfig\n      );\n    };\n\n    _attachGestureHandler = newViewTag => {\n      this._viewTag = newViewTag;\n\n      RNGestureHandlerModule.attachGestureHandler(this._handlerTag, newViewTag);\n    };\n\n    _updateGestureHandler = newConfig => {\n      this._config = newConfig;\n\n      RNGestureHandlerModule.updateGestureHandler(this._handlerTag, newConfig);\n    };\n\n    componentWillUnmount() {\n      RNGestureHandlerModule.dropGestureHandler(this._handlerTag);\n      if (this._updateEnqueued) {\n        clearImmediate(this._updateEnqueued);\n      }\n      if (this.props.id) {\n        delete handlerIDToTag[this.props.id];\n      }\n    }\n\n    componentDidMount() {\n      if (hasUnresolvedRefs(this.props)) {\n        // If there are unresolved refs (e.g. \".current\" has not yet been set)\n        // passed as `simultaneousHandlers` or `waitFor`, we enqueue a call to\n        // _update method that will try to update native handler props using\n        // setImmediate. This makes it so _update function gets called after all\n        // react components are mounted and we expect the missing ref object to\n        // be resolved by then.\n        this._updateEnqueued = setImmediate(() => {\n          this._updateEnqueued = null;\n          this._update();\n        });\n      }\n\n      this._createGestureHandler(\n        filterConfig(\n          transformProps ? transformProps(this.props) : this.props,\n          { ...this.constructor.propTypes, ...customNativeProps },\n          config\n        )\n      );\n      this._attachGestureHandler(findNodeHandle(this._viewNode));\n    }\n\n    componentDidUpdate() {\n      const viewTag = findNodeHandle(this._viewNode);\n      if (this._viewTag !== viewTag) {\n        this._attachGestureHandler(viewTag);\n      }\n      this._update();\n    }\n\n    _update() {\n      const newConfig = filterConfig(\n        transformProps ? transformProps(this.props) : this.props,\n        { ...this.constructor.propTypes, ...customNativeProps },\n        config\n      );\n      if (!deepEqual(this._config, newConfig)) {\n        this._updateGestureHandler(newConfig);\n      }\n    }\n\n    setNativeProps(updates) {\n      const mergedProps = { ...this.props, ...updates };\n      const newConfig = filterConfig(\n        transformProps ? transformProps(mergedProps) : mergedProps,\n        { ...this.constructor.propTypes, ...customNativeProps },\n        config\n      );\n      this._updateGestureHandler(newConfig);\n    }\n\n    render() {\n      let gestureEventHandler = this._onGestureHandlerEvent;\n      const { onGestureEvent, onGestureHandlerEvent } = this.props;\n      if (onGestureEvent && typeof onGestureEvent !== 'function') {\n        // If it's not a method it should be an native Animated.event\n        // object. We set it directly as the handler for the view\n        // In this case nested handlers are not going to be supported\n        if (onGestureHandlerEvent) {\n          throw new Error(\n            'Nesting touch handlers with native animated driver is not supported yet'\n          );\n        }\n        gestureEventHandler = this.props.onGestureEvent;\n      } else {\n        if (\n          onGestureHandlerEvent &&\n          typeof onGestureHandlerEvent !== 'function'\n        ) {\n          throw new Error(\n            'Nesting touch handlers with native animated driver is not supported yet'\n          );\n        }\n      }\n\n      let gestureStateEventHandler = this._onGestureHandlerStateChange;\n      const { onHandlerStateChange, onGestureHandlerStateChange } = this.props;\n      if (onHandlerStateChange && typeof onHandlerStateChange !== 'function') {\n        // If it's not a method it should be an native Animated.event\n        // object. We set it directly as the handler for the view\n        // In this case nested handlers are not going to be supported\n        if (onGestureHandlerStateChange) {\n          throw new Error(\n            'Nesting touch handlers with native animated driver is not supported yet'\n          );\n        }\n        gestureStateEventHandler = this.props.onHandlerStateChange;\n      } else {\n        if (\n          onGestureHandlerStateChange &&\n          typeof onGestureHandlerStateChange !== 'function'\n        ) {\n          throw new Error(\n            'Nesting touch handlers with native animated driver is not supported yet'\n          );\n        }\n      }\n\n      const child = React.Children.only(this.props.children);\n      let grandChildren = child.props.children;\n      if (\n        Touchable.TOUCH_TARGET_DEBUG &&\n        child.type &&\n        (child.type === 'RNGestureHandlerButton' ||\n          child.type.name === 'View' ||\n          child.type.displayName === 'View')\n      ) {\n        grandChildren = React.Children.toArray(grandChildren);\n        grandChildren.push(\n          Touchable.renderDebugView({\n            color: 'mediumspringgreen',\n            hitSlop: child.props.hitSlop,\n          })\n        );\n      }\n      return React.cloneElement(\n        child,\n        {\n          ref: this._refHandler,\n          collapsable: false,\n          onGestureHandlerEvent: gestureEventHandler,\n          onGestureHandlerStateChange: gestureStateEventHandler,\n        },\n        grandChildren\n      );\n    }\n  }\n  return Handler;\n}\n","var scope = (typeof global !== \"undefined\" && global) ||\n            (typeof self !== \"undefined\" && self) ||\n            window;\nvar apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(scope, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\nrequire(\"setimmediate\");\n// On some exotic environments, it's not clear which object `setimmediate` was\n// able to install onto.  Search each possibility in the same order as the\n// `setimmediate` library.\nexports.setImmediate = (typeof self !== \"undefined\" && self.setImmediate) ||\n                       (typeof global !== \"undefined\" && global.setImmediate) ||\n                       (this && this.setImmediate);\nexports.clearImmediate = (typeof self !== \"undefined\" && self.clearImmediate) ||\n                         (typeof global !== \"undefined\" && global.clearImmediate) ||\n                         (this && this.clearImmediate);\n","import PropTypes from 'prop-types';\n\n// If changed, add changes to NATIVE_WRAPPER_PROPS_FILTER as well\nconst GestureHandlerPropTypes = {\n  id: PropTypes.string,\n  minPointers: PropTypes.number,\n  enabled: PropTypes.bool,\n  waitFor: PropTypes.oneOfType([\n    PropTypes.string,\n    PropTypes.object,\n    PropTypes.arrayOf(\n      PropTypes.oneOfType([PropTypes.string, PropTypes.object])\n    ),\n  ]),\n  simultaneousHandlers: PropTypes.oneOfType([\n    PropTypes.string,\n    PropTypes.object,\n    PropTypes.arrayOf(\n      PropTypes.oneOfType([PropTypes.string, PropTypes.object])\n    ),\n  ]),\n  shouldCancelWhenOutside: PropTypes.bool,\n  hitSlop: PropTypes.oneOfType([\n    PropTypes.number,\n    PropTypes.shape({\n      left: PropTypes.number,\n      top: PropTypes.number,\n      right: PropTypes.number,\n      bottom: PropTypes.number,\n      vertical: PropTypes.number,\n      horizontal: PropTypes.number,\n      width: PropTypes.number,\n      height: PropTypes.number,\n    }),\n  ]),\n  onGestureEvent: PropTypes.oneOfType([PropTypes.func, PropTypes.object]),\n  onHandlerStateChange: PropTypes.oneOfType([PropTypes.func, PropTypes.object]),\n  onBegan: PropTypes.func,\n  onFailed: PropTypes.func,\n  onCancelled: PropTypes.func,\n  onActivated: PropTypes.func,\n  onEnded: PropTypes.func,\n};\n\nexport default GestureHandlerPropTypes;\n","import PropTypes from 'prop-types';\n\nimport createHandler from './createHandler';\nimport GestureHandlerPropTypes from './GestureHandlerPropTypes';\n\nconst NativeViewGestureHandler = createHandler('NativeViewGestureHandler', {\n  ...GestureHandlerPropTypes,\n\n  // If changed, add changes to NATIVE_WRAPPER_PROPS_FILTER as well\n  shouldActivateOnStart: PropTypes.bool,\n  disallowInterruption: PropTypes.bool,\n});\n\nexport default NativeViewGestureHandler;\n","import React from 'react';\n\nimport NativeViewGestureHandler from './NativeViewGestureHandler';\n\n/*\n * This array should consist of:\n *   - All keys in propTypes from NativeGestureHandler\n *     (and all keys in GestureHandlerPropTypes)\n *   - 'onGestureHandlerEvent'\n *   - 'onGestureHandlerStateChange'\n */\nconst NATIVE_WRAPPER_PROPS_FILTER = [\n  'id',\n  'minPointers',\n  'enabled',\n  'waitFor',\n  'simultaneousHandlers',\n  'shouldCancelWhenOutside',\n  'hitSlop',\n  'onGestureEvent',\n  'onHandlerStateChange',\n  'onBegan',\n  'onFailed',\n  'onCancelled',\n  'onActivated',\n  'onEnded',\n  'shouldActivateOnStart',\n  'disallowInterruption',\n  'onGestureHandlerEvent',\n  'onGestureHandlerStateChange',\n];\n\nexport default function createNativeWrapper(Component, config = {}) {\n  const ComponentWrapper = React.forwardRef((props, ref) => {\n    // filter out props that should be passed to gesture handler wrapper\n    const gestureHandlerProps = Object.keys(props).reduce(\n      (res, key) => {\n        if (NATIVE_WRAPPER_PROPS_FILTER.indexOf(key) !== -1) {\n          res[key] = props[key];\n        }\n        return res;\n      },\n      { ...config } // watch out not to modify config\n    );\n    return (\n      <NativeViewGestureHandler {...gestureHandlerProps}>\n        <Component {...props} ref={ref} />\n      </NativeViewGestureHandler>\n    );\n  });\n\n  ComponentWrapper.propTypes = {\n    ...Component.propTypes,\n  };\n  ComponentWrapper.displayName = Component.displayName || 'ComponentWrapper';\n\n  return ComponentWrapper;\n}\n","import RNGestureHandlerModule from './RNGestureHandlerModule';\n\nexport default RNGestureHandlerModule.Direction;\n","import React from 'react';\nimport { View } from 'react-native';\n\nexport default View;\n","import React from 'react';\nimport { StyleSheet } from 'react-native';\nimport hoistNonReactStatics from 'hoist-non-react-statics';\nimport GestureHandlerRootView from './GestureHandlerRootView';\n\nexport default function gestureHandlerRootHOC(\n  Component,\n  containerStyles = undefined\n) {\n  function Wrapper(props) {\n    return (\n      <GestureHandlerRootView style={[styles.container, containerStyles]}>\n        <Component {...props} />\n      </GestureHandlerRootView>\n    );\n  }\n\n  Wrapper.displayName = `gestureHandlerRootHOC(${Component.displayName ||\n    Component.name})`;\n\n  hoistNonReactStatics(Wrapper, Component);\n\n  return Wrapper;\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1 },\n});\n","import PropTypes from 'prop-types';\nimport React from 'react';\nimport { Animated, Platform, processColor, StyleSheet } from 'react-native';\n\nimport createNativeWrapper from './createNativeWrapper';\nimport GestureHandlerButton from './GestureHandlerButton';\nimport State from './State';\n\nexport const RawButton = createNativeWrapper(GestureHandlerButton, {\n  shouldCancelWhenOutside: false,\n  shouldActivateOnStart: false,\n});\n\n/* Buttons */\n\nexport class BaseButton extends React.Component {\n  static propTypes = {\n    ...RawButton.propTypes,\n    onPress: PropTypes.func,\n    onActiveStateChange: PropTypes.func,\n  };\n\n  constructor(props) {\n    super(props);\n    this._lastActive = false;\n  }\n\n  _handleEvent = ({ nativeEvent }) => {\n    const { state, oldState, pointerInside } = nativeEvent;\n    const active = pointerInside && state === State.ACTIVE;\n\n    if (active !== this._lastActive && this.props.onActiveStateChange) {\n      this.props.onActiveStateChange(active);\n    }\n\n    if (\n      oldState === State.ACTIVE &&\n      state !== State.CANCELLED &&\n      this._lastActive &&\n      this.props.onPress\n    ) {\n      this.props.onPress(active);\n    }\n\n    this._lastActive = active;\n  };\n\n  // Normally, the parent would execute it's handler first,\n  // then forward the event to listeners. However, here our handler\n  // is virtually only forwarding events to listeners, so we reverse the order\n  // to keep the proper order of the callbacks (from \"raw\" ones to \"processed\").\n  _onHandlerStateChange = e => {\n    this.props.onHandlerStateChange && this.props.onHandlerStateChange(e);\n    this._handleEvent(e);\n  };\n\n  _onGestureEvent = e => {\n    this.props.onGestureEvent && this.props.onGestureEvent(e);\n    this._handleEvent(e);\n  };\n\n  render() {\n    const { rippleColor, ...rest } = this.props;\n\n    return (\n      <RawButton\n        rippleColor={processColor(rippleColor)}\n        {...rest}\n        onGestureEvent={this._onGestureEvent}\n        onHandlerStateChange={this._onHandlerStateChange}\n      />\n    );\n  }\n}\n\nconst AnimatedBaseButton = Animated.createAnimatedComponent(BaseButton);\n\nconst btnStyles = StyleSheet.create({\n  underlay: {\n    position: 'absolute',\n    left: 0,\n    right: 0,\n    bottom: 0,\n    top: 0,\n  },\n});\n\nexport class RectButton extends React.Component {\n  static propTypes = BaseButton.propTypes;\n\n  static defaultProps = {\n    activeOpacity: 0.105,\n    underlayColor: 'black',\n  };\n\n  constructor(props) {\n    super(props);\n    this._opacity = new Animated.Value(0);\n  }\n\n  _onActiveStateChange = active => {\n    if (Platform.OS !== 'android') {\n      this._opacity.setValue(active ? this.props.activeOpacity : 0);\n    }\n\n    this.props.onActiveStateChange && this.props.onActiveStateChange(active);\n  };\n\n  render() {\n    const { children, style, ...rest } = this.props;\n\n    const resolvedStyle = StyleSheet.flatten(style ?? {});\n\n    return (\n      <BaseButton\n        {...rest}\n        style={resolvedStyle}\n        onActiveStateChange={this._onActiveStateChange}>\n        <Animated.View\n          style={[\n            btnStyles.underlay,\n            {\n              opacity: this._opacity,\n              backgroundColor: this.props.underlayColor,\n              borderRadius: resolvedStyle.borderRadius,\n              borderTopLeftRadius: resolvedStyle.borderTopLeftRadius,\n              borderTopRightRadius: resolvedStyle.borderTopRightRadius,\n              borderBottomLeftRadius: resolvedStyle.borderBottomLeftRadius,\n              borderBottomRightRadius: resolvedStyle.borderBottomRightRadius,\n            },\n          ]}\n        />\n        {children}\n      </BaseButton>\n    );\n  }\n}\n\nexport class BorderlessButton extends React.Component {\n  static propTypes = {\n    ...BaseButton.propTypes,\n    borderless: PropTypes.bool,\n  };\n\n  static defaultProps = {\n    activeOpacity: 0.3,\n    borderless: true,\n  };\n\n  constructor(props) {\n    super(props);\n    this._opacity = new Animated.Value(1);\n  }\n\n  _onActiveStateChange = active => {\n    if (Platform.OS !== 'android') {\n      this._opacity.setValue(active ? this.props.activeOpacity : 1);\n    }\n\n    this.props.onActiveStateChange && this.props.onActiveStateChange(active);\n  };\n\n  render() {\n    const { children, style, ...rest } = this.props;\n\n    return (\n      <AnimatedBaseButton\n        {...rest}\n        onActiveStateChange={this._onActiveStateChange}\n        style={[style, Platform.OS === 'ios' && { opacity: this._opacity }]}>\n        {children}\n      </AnimatedBaseButton>\n    );\n  }\n}\n\nexport { default as PureNativeButton } from './GestureHandlerButton';\n","import React from 'react';\nimport { View } from 'react-native';\n\nexport default React.forwardRef((props, ref) => (\n  <View ref={ref} accessibilityRole=\"button\" {...props} />\n));\n","import React from 'react';\nimport {\n  DrawerLayoutAndroid as RNDrawerLayoutAndroid,\n  FlatList as RNFlatList,\n  Switch as RNSwitch,\n  TextInput as RNTextInput,\n  ScrollView as RNScrollView,\n} from 'react-native';\n\nimport createNativeWrapper from './createNativeWrapper';\n\nexport const ScrollView = createNativeWrapper(RNScrollView, {\n  disallowInterruption: true,\n});\n\nexport const Switch = createNativeWrapper(RNSwitch, {\n  shouldCancelWhenOutside: false,\n  shouldActivateOnStart: true,\n  disallowInterruption: true,\n});\nexport const TextInput = createNativeWrapper(RNTextInput);\nexport const DrawerLayoutAndroid = createNativeWrapper(RNDrawerLayoutAndroid, {\n  disallowInterruption: true,\n});\nDrawerLayoutAndroid.positions = RNDrawerLayoutAndroid.positions;\n\nexport const FlatList = React.forwardRef((props, ref) => (\n  <RNFlatList\n    ref={ref}\n    {...props}\n    renderScrollComponent={scrollProps => <ScrollView {...scrollProps} />}\n  />\n));\n","export default {\n  get forceTouchAvailable() {\n    return false;\n  },\n};\n","import PropTypes from 'prop-types';\nimport React from 'react';\n\nimport createHandler from './createHandler';\nimport GestureHandlerPropTypes from './GestureHandlerPropTypes';\nimport PlatformConstants from './PlatformConstants';\n\nexport const TapGestureHandler = createHandler(\n  'TapGestureHandler',\n  {\n    ...GestureHandlerPropTypes,\n    maxDurationMs: PropTypes.number,\n    maxDelayMs: PropTypes.number,\n    numberOfTaps: PropTypes.number,\n    maxDeltaX: PropTypes.number,\n    maxDeltaY: PropTypes.number,\n    maxDist: PropTypes.number,\n    minPointers: PropTypes.number,\n  },\n  {}\n);\n\nexport const FlingGestureHandler = createHandler(\n  'FlingGestureHandler',\n  {\n    ...GestureHandlerPropTypes,\n    numberOfPointers: PropTypes.number,\n    direction: PropTypes.number,\n  },\n  {}\n);\n\nclass ForceTouchFallback extends React.Component {\n  componentDidMount() {\n    console.warn(\n      'ForceTouchGestureHandler is not available on this platform. Please use ForceTouchGestureHandler.forceTouchAvailable to conditionally render other components that would provide a fallback behavior specific to your usecase'\n    );\n  }\n  render() {\n    return this.props.children;\n  }\n}\n\nexport const ForceTouchGestureHandler =\n  PlatformConstants && PlatformConstants.forceTouchAvailable\n    ? createHandler(\n        'ForceTouchGestureHandler',\n        {\n          ...GestureHandlerPropTypes,\n          minForce: PropTypes.number,\n          maxForce: PropTypes.number,\n          feedbackOnActivation: PropTypes.bool,\n        },\n        {}\n      )\n    : ForceTouchFallback;\n\nForceTouchGestureHandler.forceTouchAvailable =\n  (PlatformConstants && PlatformConstants.forceTouchAvailable) || false;\n\nexport const LongPressGestureHandler = createHandler(\n  'LongPressGestureHandler',\n  {\n    ...GestureHandlerPropTypes,\n    minDurationMs: PropTypes.number,\n    maxDist: PropTypes.number,\n  },\n  {}\n);\n\nfunction validatePanGestureHandlerProps(props) {\n  if (props.minDeltaX && props.activeOffsetX) {\n    throw new Error(\n      `It's not supported use minDeltaX with activeOffsetXStart or activeOffsetXEnd`\n    );\n  }\n  if (props.maxDeltaX && props.failOffsetX) {\n    throw new Error(\n      `It's not supported use minDeltaX with activeOffsetXStart or activeOffsetXEnd`\n    );\n  }\n  if (props.minDeltaY && props.activeOffsetY) {\n    throw new Error(\n      `It's not supported use minDeltaX with activeOffsetYStart or activeOffsetYEnd`\n    );\n  }\n  if (props.maxDeltaY && props.failOffsetY) {\n    throw new Error(\n      `It's not supported use minDeltaX with activeOffsetYStart or activeOffsetYEnd`\n    );\n  }\n  if (\n    Array.isArray(props.activeOffsetX) &&\n    (props.activeOffsetX[0] > 0 || props.activeOffsetX[1] < 0)\n  ) {\n    throw new Error(\n      `First element of activeOffsetX should be negative, a the second one should be positive`\n    );\n  }\n\n  if (\n    Array.isArray(props.activeOffsetY) &&\n    (props.activeOffsetY[0] > 0 || props.activeOffsetY[1] < 0)\n  ) {\n    throw new Error(\n      `First element of activeOffsetY should be negative, a the second one should be positive`\n    );\n  }\n\n  if (\n    Array.isArray(props.failOffsetX) &&\n    (props.failOffsetX[0] > 0 || props.failOffsetX[1] < 0)\n  ) {\n    throw new Error(\n      `First element of failOffsetX should be negative, a the second one should be positive`\n    );\n  }\n\n  if (\n    Array.isArray(props.failOffsetY) &&\n    (props.failOffsetY[0] > 0 || props.failOffsetY[1] < 0)\n  ) {\n    throw new Error(\n      `First element of failOffsetY should be negative, a the second one should be positive`\n    );\n  }\n}\n\nfunction transformPanGestureHandlerProps(props) {\n  const res = { ...props };\n  if (props.minDeltaX !== undefined) {\n    delete res['minDeltaX'];\n    res.activeOffsetXStart = -props.minDeltaX;\n    res.activeOffsetXEnd = props.minDeltaX;\n  }\n  if (props.maxDeltaX !== undefined) {\n    delete res['maxDeltaX'];\n    res.failOffsetXStart = -props.maxDeltaX;\n    res.failOffsetXEnd = props.maxDeltaX;\n  }\n  if (props.minOffsetX !== undefined) {\n    delete res['minOffsetX'];\n    if (props.minOffsetX < 0) {\n      res.activeOffsetXStart = props.minOffsetX;\n    } else {\n      res.activeOffsetXEnd = props.minOffsetX;\n    }\n  }\n\n  if (props.minDeltaY !== undefined) {\n    delete res['minDeltaY'];\n    res.activeOffsetYStart = -props.minDeltaY;\n    res.activeOffsetYEnd = props.minDeltaY;\n  }\n  if (props.maxDeltaY !== undefined) {\n    delete res['maxDeltaY'];\n    res.failOffsetYStart = -props.maxDeltaY;\n    res.failOffsetYEnd = props.maxDeltaY;\n  }\n\n  if (props.minOffsetY !== undefined) {\n    delete res['minOffsetY'];\n    if (props.minOffsetY < 0) {\n      res.activeOffsetYStart = props.minOffsetY;\n    } else {\n      res.activeOffsetYEnd = props.minOffsetY;\n    }\n  }\n\n  if (props.activeOffsetX !== undefined) {\n    delete res['activeOffsetX'];\n    if (Array.isArray(props.activeOffsetX)) {\n      res.activeOffsetXStart = props.activeOffsetX[0];\n      res.activeOffsetXEnd = props.activeOffsetX[1];\n    } else if (props.activeOffsetX < 0) {\n      res.activeOffsetXStart = props.activeOffsetX;\n    } else {\n      res.activeOffsetXEnd = props.activeOffsetX;\n    }\n  }\n\n  if (props.activeOffsetY !== undefined) {\n    delete res['activeOffsetY'];\n    if (Array.isArray(props.activeOffsetY)) {\n      res.activeOffsetYStart = props.activeOffsetY[0];\n      res.activeOffsetYEnd = props.activeOffsetY[1];\n    } else if (props.activeOffsetY < 0) {\n      res.activeOffsetYStart = props.activeOffsetY;\n    } else {\n      res.activeOffsetYEnd = props.activeOffsetY;\n    }\n  }\n\n  if (props.failOffsetX !== undefined) {\n    delete res['failOffsetX'];\n    if (Array.isArray(props.failOffsetX)) {\n      res.failOffsetXStart = props.failOffsetX[0];\n      res.failOffsetXEnd = props.failOffsetX[1];\n    } else if (props.failOffsetX < 0) {\n      res.failOffsetXStart = props.failOffsetX;\n    } else {\n      res.failOffsetXEnd = props.failOffsetX;\n    }\n  }\n\n  if (props.failOffsetY !== undefined) {\n    delete res['failOffsetY'];\n    if (Array.isArray(props.failOffsetY)) {\n      res.failOffsetYStart = props.failOffsetY[0];\n      res.failOffsetYEnd = props.failOffsetY[1];\n    } else if (props.failOffsetY < 0) {\n      res.failOffsetYStart = props.failOffsetY;\n    } else {\n      res.failOffsetYEnd = props.failOffsetY;\n    }\n  }\n\n  return res;\n}\n\nfunction managePanProps(props) {\n  if (__DEV__) {\n    validatePanGestureHandlerProps(props);\n  }\n  return transformPanGestureHandlerProps(props);\n}\n\nexport const PanGestureHandler = createHandler(\n  'PanGestureHandler',\n  {\n    ...GestureHandlerPropTypes,\n    activeOffsetY: PropTypes.oneOfType([\n      PropTypes.number,\n      PropTypes.arrayOf(PropTypes.number),\n    ]),\n    activeOffsetX: PropTypes.oneOfType([\n      PropTypes.number,\n      PropTypes.arrayOf(PropTypes.number),\n    ]),\n    failOffsetY: PropTypes.oneOfType([\n      PropTypes.number,\n      PropTypes.arrayOf(PropTypes.number),\n    ]),\n    failOffsetX: PropTypes.oneOfType([\n      PropTypes.number,\n      PropTypes.arrayOf(PropTypes.number),\n    ]),\n    minDist: PropTypes.number,\n    minVelocity: PropTypes.number,\n    minVelocityX: PropTypes.number,\n    minVelocityY: PropTypes.number,\n    minPointers: PropTypes.number,\n    maxPointers: PropTypes.number,\n    avgTouches: PropTypes.bool,\n  },\n  {},\n  managePanProps,\n  {\n    activeOffsetYStart: true,\n    activeOffsetYEnd: true,\n    activeOffsetXStart: true,\n    activeOffsetXEnd: true,\n    failOffsetYStart: true,\n    failOffsetYEnd: true,\n    failOffsetXStart: true,\n    failOffsetXEnd: true,\n  }\n);\nexport const PinchGestureHandler = createHandler(\n  'PinchGestureHandler',\n  GestureHandlerPropTypes,\n  {}\n);\nexport const RotationGestureHandler = createHandler(\n  'RotationGestureHandler',\n  GestureHandlerPropTypes,\n  {}\n);\n","// @flow\n\n// Similarily to the DrawerLayout component this deserves to be put in a\n// separate repo. Although, keeping it here for the time being will allow us\n// to move faster and fix possible issues quicker\n\nimport React, { Component } from 'react';\nimport { Animated, StyleSheet, View, I18nManager } from 'react-native';\n\nimport { PanGestureHandler, TapGestureHandler, State } from './GestureHandler';\n\nconst DRAG_TOSS = 0.05;\n\nexport type PropType = {\n  children: any,\n  friction: number,\n  leftThreshold?: number,\n  rightThreshold?: number,\n  overshootLeft?: boolean,\n  overshootRight?: boolean,\n  overshootFriction: number,\n  onSwipeableLeftOpen?: Function,\n  onSwipeableRightOpen?: Function,\n  onSwipeableOpen?: Function,\n  onSwipeableClose?: Function,\n  onSwipeableLeftWillOpen?: Function,\n  onSwipeableRightWillOpen?: Function,\n  onSwipeableWillOpen?: Function,\n  onSwipeableWillClose?: Function,\n  renderLeftActions?: (\n    progressAnimatedValue: any,\n    dragAnimatedValue: any\n  ) => any,\n  renderRightActions?: (\n    progressAnimatedValue: any,\n    dragAnimatedValue: any\n  ) => any,\n  useNativeAnimations: boolean,\n  animationOptions?: Object,\n  containerStyle?: Object,\n  childrenContainerStyle?: Object,\n};\ntype StateType = {\n  dragX: Animated.Value,\n  rowTranslation: Animated.Value,\n  rowState: number,\n  leftWidth: number | typeof undefined,\n  rightOffset: number | typeof undefined,\n  rowWidth: number | typeof undefined,\n};\n\nexport default class Swipeable extends Component<PropType, StateType> {\n  static defaultProps = {\n    friction: 1,\n    overshootFriction: 1,\n    useNativeAnimations: true,\n  };\n  _onGestureEvent: ?Animated.Event;\n  _transX: ?Animated.Interpolation;\n  _showLeftAction: ?Animated.Interpolation | ?Animated.Value;\n  _leftActionTranslate: ?Animated.Interpolation;\n  _showRightAction: ?Animated.Interpolation | ?Animated.Value;\n  _rightActionTranslate: ?Animated.Interpolation;\n\n  constructor(props: PropType) {\n    super(props);\n    const dragX = new Animated.Value(0);\n    this.state = {\n      dragX,\n      rowTranslation: new Animated.Value(0),\n      rowState: 0,\n      leftWidth: undefined,\n      rightOffset: undefined,\n      rowWidth: undefined,\n    };\n    this._updateAnimatedEvent(props, this.state);\n\n    this._onGestureEvent = Animated.event(\n      [{ nativeEvent: { translationX: dragX } }],\n      { useNativeDriver: props.useNativeAnimations }\n    );\n  }\n\n  UNSAFE_componentWillUpdate(props: PropType, state: StateType) {\n    if (\n      this.props.friction !== props.friction ||\n      this.props.overshootLeft !== props.overshootLeft ||\n      this.props.overshootRight !== props.overshootRight ||\n      this.props.overshootFriction !== props.overshootFriction ||\n      this.state.leftWidth !== state.leftWidth ||\n      this.state.rightOffset !== state.rightOffset ||\n      this.state.rowWidth !== state.rowWidth\n    ) {\n      this._updateAnimatedEvent(props, state);\n    }\n  }\n\n  _updateAnimatedEvent = (props: PropType, state: StateType) => {\n    const { friction, overshootFriction, useNativeAnimations } = props;\n    const { dragX, rowTranslation, leftWidth = 0, rowWidth = 0 } = state;\n    const { rightOffset = rowWidth } = state;\n    const rightWidth = Math.max(0, rowWidth - rightOffset);\n\n    const {\n      overshootLeft = leftWidth > 0,\n      overshootRight = rightWidth > 0,\n    } = props;\n\n    const transX = Animated.add(\n      rowTranslation,\n      dragX.interpolate({\n        inputRange: [0, friction],\n        outputRange: [0, 1],\n      })\n    ).interpolate({\n      inputRange: [\n        -rightWidth - (overshootRight ? 1 : overshootFriction),\n        -rightWidth,\n        leftWidth,\n        leftWidth + (overshootLeft ? 1 : overshootFriction),\n      ],\n      outputRange: [\n        -rightWidth - (overshootRight || overshootFriction > 1 ? 1 : 0),\n        -rightWidth,\n        leftWidth,\n        leftWidth + (overshootLeft || overshootFriction > 1 ? 1 : 0),\n      ],\n    });\n    this._transX = transX;\n    this._showLeftAction =\n      leftWidth > 0\n        ? transX.interpolate({\n            inputRange: [-1, 0, leftWidth],\n            outputRange: [0, 0, 1],\n          })\n        : new Animated.Value(0);\n    this._leftActionTranslate = this._showLeftAction.interpolate({\n      inputRange: [0, Number.MIN_VALUE],\n      outputRange: [-10000, 0],\n      extrapolate: 'clamp',\n    });\n    this._showRightAction =\n      rightWidth > 0\n        ? transX.interpolate({\n            inputRange: [-rightWidth, 0, 1],\n            outputRange: [1, 0, 0],\n          })\n        : new Animated.Value(0);\n    this._rightActionTranslate = this._showRightAction.interpolate({\n      inputRange: [0, Number.MIN_VALUE],\n      outputRange: [-10000, 0],\n      extrapolate: 'clamp',\n    });\n  };\n\n  _onTapHandlerStateChange = ({ nativeEvent }) => {\n    if (nativeEvent.oldState === State.ACTIVE) {\n      this.close();\n    }\n  };\n\n  _onHandlerStateChange = ({ nativeEvent }) => {\n    if (nativeEvent.oldState === State.ACTIVE) {\n      this._handleRelease(nativeEvent);\n    }\n  };\n\n  _handleRelease = nativeEvent => {\n    const { velocityX, translationX: dragX } = nativeEvent;\n    const { leftWidth = 0, rowWidth = 0, rowState } = this.state;\n    const { rightOffset = rowWidth } = this.state;\n    const rightWidth = rowWidth - rightOffset;\n    const {\n      friction,\n      leftThreshold = leftWidth / 2,\n      rightThreshold = rightWidth / 2,\n    } = this.props;\n\n    const startOffsetX = this._currentOffset() + dragX / friction;\n    const translationX = (dragX + DRAG_TOSS * velocityX) / friction;\n\n    let toValue = 0;\n    if (rowState === 0) {\n      if (translationX > leftThreshold) {\n        toValue = leftWidth;\n      } else if (translationX < -rightThreshold) {\n        toValue = -rightWidth;\n      }\n    } else if (rowState === 1) {\n      // swiped to left\n      if (translationX > -leftThreshold) {\n        toValue = leftWidth;\n      }\n    } else {\n      // swiped to right\n      if (translationX < rightThreshold) {\n        toValue = -rightWidth;\n      }\n    }\n\n    this._animateRow(startOffsetX, toValue, velocityX / friction);\n  };\n\n  _animateRow = (fromValue, toValue, velocityX) => {\n    const { dragX, rowTranslation } = this.state;\n    dragX.setValue(0);\n    rowTranslation.setValue(fromValue);\n\n    this.setState({ rowState: Math.sign(toValue) });\n    Animated.spring(rowTranslation, {\n      restSpeedThreshold: 1.7,\n      restDisplacementThreshold: 0.4,\n      velocity: velocityX,\n      bounciness: 0,\n      toValue,\n      useNativeDriver: this.props.useNativeAnimations,\n      ...this.props.animationOptions,\n    }).start(({ finished }) => {\n      if (finished) {\n        if (toValue > 0 && this.props.onSwipeableLeftOpen) {\n          this.props.onSwipeableLeftOpen();\n        } else if (toValue < 0 && this.props.onSwipeableRightOpen) {\n          this.props.onSwipeableRightOpen();\n        }\n\n        if (toValue === 0) {\n          this.props.onSwipeableClose && this.props.onSwipeableClose();\n        } else {\n          this.props.onSwipeableOpen && this.props.onSwipeableOpen();\n        }\n      }\n    });\n    if (toValue > 0 && this.props.onSwipeableLeftWillOpen) {\n      this.props.onSwipeableLeftWillOpen();\n    } else if (toValue < 0 && this.props.onSwipeableRightWillOpen) {\n      this.props.onSwipeableRightWillOpen();\n    }\n\n    if (toValue === 0) {\n      this.props.onSwipeableWillClose && this.props.onSwipeableWillClose();\n    } else {\n      this.props.onSwipeableWillOpen && this.props.onSwipeableWillOpen();\n    }\n  };\n\n  _onRowLayout = ({ nativeEvent }) => {\n    this.setState({ rowWidth: nativeEvent.layout.width });\n  };\n\n  _currentOffset = () => {\n    const { leftWidth = 0, rowWidth = 0, rowState } = this.state;\n    const { rightOffset = rowWidth } = this.state;\n    const rightWidth = rowWidth - rightOffset;\n    if (rowState === 1) {\n      return leftWidth;\n    } else if (rowState === -1) {\n      return -rightWidth;\n    }\n    return 0;\n  };\n\n  close = () => {\n    this._animateRow(this._currentOffset(), 0);\n  };\n\n  openLeft = () => {\n    const { leftWidth = 0 } = this.state;\n    this._animateRow(this._currentOffset(), leftWidth);\n  };\n\n  openRight = () => {\n    const { rowWidth = 0 } = this.state;\n    const { rightOffset = rowWidth } = this.state;\n    const rightWidth = rowWidth - rightOffset;\n    this._animateRow(this._currentOffset(), -rightWidth);\n  };\n\n  render() {\n    const { rowState } = this.state;\n    const { children, renderLeftActions, renderRightActions } = this.props;\n\n    const left = renderLeftActions && (\n      <Animated.View\n        style={[\n          styles.leftActions,\n          { transform: [{ translateX: this._leftActionTranslate }] },\n        ]}>\n        {renderLeftActions(this._showLeftAction, this._transX)}\n        <View\n          onLayout={({ nativeEvent }) =>\n            this.setState({ leftWidth: nativeEvent.layout.x })\n          }\n        />\n      </Animated.View>\n    );\n\n    const right = renderRightActions && (\n      <Animated.View\n        style={[\n          styles.rightActions,\n          { transform: [{ translateX: this._rightActionTranslate }] },\n        ]}>\n        {renderRightActions(this._showRightAction, this._transX)}\n        <View\n          onLayout={({ nativeEvent }) =>\n            this.setState({ rightOffset: nativeEvent.layout.x })\n          }\n        />\n      </Animated.View>\n    );\n\n    return (\n      <PanGestureHandler\n        activeOffsetX={[-10, 10]}\n        {...this.props}\n        onGestureEvent={this._onGestureEvent}\n        onHandlerStateChange={this._onHandlerStateChange}>\n        <Animated.View\n          onLayout={this._onRowLayout}\n          style={[styles.container, this.props.containerStyle]}>\n          {left}\n          {right}\n          <TapGestureHandler\n            enabled={rowState !== 0}\n            onHandlerStateChange={this._onTapHandlerStateChange}>\n            <Animated.View\n              pointerEvents={rowState === 0 ? 'auto' : 'box-only'}\n              style={[\n                {\n                  transform: [{ translateX: this._transX }],\n                },\n                this.props.childrenContainerStyle,\n              ]}>\n              {children}\n            </Animated.View>\n          </TapGestureHandler>\n        </Animated.View>\n      </PanGestureHandler>\n    );\n  }\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    overflow: 'hidden',\n  },\n  leftActions: {\n    ...StyleSheet.absoluteFillObject,\n    flexDirection: I18nManager.isRTL? 'row-reverse': 'row',\n  },\n  rightActions: {\n    ...StyleSheet.absoluteFillObject,\n    flexDirection: I18nManager.isRTL ? 'row' : 'row-reverse',\n  },\n});\n","// @flow\n\n// This component is based on RN's DrawerLayoutAndroid API\n//\n// It perhaps deserves to be put in a separate repo, but since it relies\n// on react-native-gesture-handler library which isn't very popular at the\n// moment I decided to keep it here for the time being. It will allow us\n// to move faster and fix issues that may arise in gesture handler library\n// that could be found when using the drawer component\n\nimport React, { Component } from 'react';\nimport invariant from 'invariant';\nimport {\n  Animated,\n  StyleSheet,\n  View,\n  Keyboard,\n  StatusBar,\n  I18nManager,\n} from 'react-native';\n\nimport { PanGestureHandler, TapGestureHandler, State } from './GestureHandler';\n\nconst DRAG_TOSS = 0.05;\n\nconst IDLE = 'Idle';\nconst DRAGGING = 'Dragging';\nconst SETTLING = 'Settling';\n\nexport type PropType = {\n  children: any,\n  drawerBackgroundColor?: string,\n  drawerPosition: 'left' | 'right',\n  drawerLockMode?: 'unlocked' | 'locked-closed' | 'locked-open',\n  drawerWidth: number,\n  keyboardDismissMode?: 'none' | 'on-drag',\n  onDrawerClose?: Function,\n  onDrawerOpen?: Function,\n  onDrawerStateChanged?: Function,\n  renderNavigationView: (progressAnimatedValue: any) => any,\n  useNativeAnimations: boolean,\n\n  // brand new properties\n  drawerType: 'front' | 'back' | 'slide',\n  edgeWidth: number,\n  minSwipeDistance: number,\n  hideStatusBar?: boolean,\n  statusBarAnimation?: 'slide' | 'none' | 'fade',\n  overlayColor: string,\n  drawerContainerStyle?: any,\n  contentContainerStyle?: any,\n  onGestureRef?: Function,\n\n  // Properties not yet supported\n  // onDrawerSlide?: Function\n};\n\nexport type StateType = {\n  dragX: any,\n  touchX: any,\n  drawerTranslation: any,\n  containerWidth: number,\n};\n\nexport type EventType = {\n  stopPropagation: Function,\n};\n\nexport type DrawerMovementOptionType = {\n  velocity?: number,\n};\n\nexport default class DrawerLayout extends Component<PropType, StateType> {\n  static defaultProps = {\n    drawerWidth: 200,\n    drawerPosition: 'left',\n    useNativeAnimations: true,\n    drawerType: 'front',\n    edgeWidth: 20,\n    minSwipeDistance: 3,\n    overlayColor: 'rgba(0, 0, 0, 0.7)',\n    drawerLockMode: 'unlocked',\n  };\n\n  static positions = {\n    Left: 'left',\n    Right: 'right',\n  };\n  _openValue: ?Animated.Interpolation;\n  _onGestureEvent: ?Animated.Event;\n  _accessibilityIsModalView = React.createRef();\n  _pointerEventsView = React.createRef();\n  _panGestureHandler = React.createRef();\n  _drawerShown = false;\n\n  constructor(props: PropType, context: any) {\n    super(props, context);\n\n    const dragX = new Animated.Value(0);\n    const touchX = new Animated.Value(0);\n    const drawerTranslation = new Animated.Value(0);\n\n    this.state = {\n      dragX,\n      touchX,\n      drawerTranslation,\n      containerWidth: 0,\n    };\n\n    this._updateAnimatedEvent(props, this.state);\n  }\n\n  UNSAFE_componentWillUpdate(props: PropType, state: StateType) {\n    if (\n      this.props.drawerPosition !== props.drawerPosition ||\n      this.props.drawerWidth !== props.drawerWidth ||\n      this.props.drawerType !== props.drawerType ||\n      this.state.containerWidth !== state.containerWidth\n    ) {\n      this._updateAnimatedEvent(props, state);\n    }\n  }\n\n  _updateAnimatedEvent = (props: PropType, state: StateType) => {\n    // Event definition is based on\n    const { drawerPosition, drawerWidth, drawerType } = props;\n    const {\n      dragX: dragXValue,\n      touchX: touchXValue,\n      drawerTranslation,\n      containerWidth,\n    } = state;\n\n    let dragX = dragXValue;\n    let touchX = touchXValue;\n\n    if (drawerPosition !== 'left') {\n      // Most of the code is written in a way to handle left-side drawer.\n      // In order to handle right-side drawer the only thing we need to\n      // do is to reverse events coming from gesture handler in a way they\n      // emulate left-side drawer gestures. E.g. dragX is simply -dragX, and\n      // touchX is calulcated by subtracing real touchX from the width of the\n      // container (such that when touch happens at the right edge the value\n      // is simply 0)\n      dragX = Animated.multiply(new Animated.Value(-1), dragXValue);\n      touchX = Animated.add(\n        new Animated.Value(containerWidth),\n        Animated.multiply(new Animated.Value(-1), touchXValue)\n      );\n      touchXValue.setValue(containerWidth);\n    } else {\n      touchXValue.setValue(0);\n    }\n\n    // While closing the drawer when user starts gesture outside of its area (in greyed\n    // out part of the window), we want the drawer to follow only once finger reaches the\n    // edge of the drawer.\n    // E.g. on the diagram below drawer is illustrate by X signs and the greyed out area by\n    // dots. The touch gesture starts at '*' and moves left, touch path is indicated by\n    // an arrow pointing left\n    // 1) +---------------+ 2) +---------------+ 3) +---------------+ 4) +---------------+\n    //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|\n    //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|\n    //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|\n    //    |XXXXXXXX|......|    |XXXXXXXX|.<-*..|    |XXXXXXXX|<--*..|    |XXXXX|<-----*..|\n    //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|\n    //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|\n    //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|\n    //    +---------------+    +---------------+    +---------------+    +---------------+\n    //\n    // For the above to work properly we define animated value that will keep start position\n    // of the gesture. Then we use that value to calculate how much we need to subtract from\n    // the dragX. If the gesture started on the greyed out area we take the distance from the\n    // edge of the drawer to the start position. Otherwise we don't subtract at all and the\n    // drawer be pulled back as soon as you start the pan.\n    //\n    // This is used only when drawerType is \"front\"\n    //\n    let translationX = dragX;\n    if (drawerType === 'front') {\n      const startPositionX = Animated.add(\n        touchX,\n        Animated.multiply(new Animated.Value(-1), dragX)\n      );\n\n      const dragOffsetFromOnStartPosition = startPositionX.interpolate({\n        inputRange: [drawerWidth - 1, drawerWidth, drawerWidth + 1],\n        outputRange: [0, 0, 1],\n      });\n      translationX = Animated.add(dragX, dragOffsetFromOnStartPosition);\n    }\n\n    this._openValue = Animated.add(translationX, drawerTranslation).interpolate(\n      {\n        inputRange: [0, drawerWidth],\n        outputRange: [0, 1],\n        extrapolate: 'clamp',\n      }\n    );\n\n    this._onGestureEvent = Animated.event(\n      [{ nativeEvent: { translationX: dragXValue, x: touchXValue } }],\n      { useNativeDriver: props.useNativeAnimations }\n    );\n  };\n\n  _handleContainerLayout = ({ nativeEvent }) => {\n    this.setState({ containerWidth: nativeEvent.layout.width });\n  };\n\n  _emitStateChanged = (newState: string, drawerWillShow: boolean) => {\n    this.props.onDrawerStateChanged &&\n      this.props.onDrawerStateChanged(newState, drawerWillShow);\n  };\n\n  _openingHandlerStateChange = ({ nativeEvent }) => {\n    if (nativeEvent.oldState === State.ACTIVE) {\n      this._handleRelease(nativeEvent);\n    } else if (nativeEvent.state === State.ACTIVE) {\n      this._emitStateChanged(DRAGGING, false);\n      if (this.props.keyboardDismissMode === 'on-drag') {\n        Keyboard.dismiss();\n      }\n      if (this.props.hideStatusBar) {\n        StatusBar.setHidden(true, this.props.statusBarAnimation || 'slide');\n      }\n    }\n  };\n\n  _onTapHandlerStateChange = ({ nativeEvent }) => {\n    if (\n      this._drawerShown &&\n      nativeEvent.oldState === State.ACTIVE &&\n      this.props.drawerLockMode !== 'locked-open'\n    ) {\n      this.closeDrawer();\n    }\n  };\n\n  _handleRelease = nativeEvent => {\n    const { drawerWidth, drawerPosition, drawerType } = this.props;\n    const { containerWidth } = this.state;\n    let { translationX: dragX, velocityX, x: touchX } = nativeEvent;\n\n    if (drawerPosition !== 'left') {\n      // See description in _updateAnimatedEvent about why events are flipped\n      // for right-side drawer\n      dragX = -dragX;\n      touchX = containerWidth - touchX;\n      velocityX = -velocityX;\n    }\n\n    const gestureStartX = touchX - dragX;\n    let dragOffsetBasedOnStart = 0;\n\n    if (drawerType === 'front') {\n      dragOffsetBasedOnStart =\n        gestureStartX > drawerWidth ? gestureStartX - drawerWidth : 0;\n    }\n\n    const startOffsetX =\n      dragX + dragOffsetBasedOnStart + (this._drawerShown ? drawerWidth : 0);\n    const projOffsetX = startOffsetX + DRAG_TOSS * velocityX;\n\n    const shouldOpen = projOffsetX > drawerWidth / 2;\n\n    if (shouldOpen) {\n      this._animateDrawer(startOffsetX, drawerWidth, velocityX);\n    } else {\n      this._animateDrawer(startOffsetX, 0, velocityX);\n    }\n  };\n\n  _updateShowing = (showing: boolean) => {\n    this._drawerShown = showing;\n    this._accessibilityIsModalView.current &&\n      this._accessibilityIsModalView.current.setNativeProps({\n        accessibilityViewIsModal: showing,\n      });\n    this._pointerEventsView.current &&\n      this._pointerEventsView.current.setNativeProps({\n        pointerEvents: showing ? 'auto' : 'none',\n      });\n    const { drawerPosition, minSwipeDistance, edgeWidth } = this.props;\n    const fromLeft = drawerPosition === 'left';\n    // gestureOrientation is 1 if the expected gesture is from left to right and -1 otherwise\n    // e.g. when drawer is on the left and is closed we expect left to right gesture, thus\n    // orientation will be 1.\n    const gestureOrientation =\n      (fromLeft ? 1 : -1) * (this._drawerShown ? -1 : 1);\n    // When drawer is closed we want the hitSlop to be horizontally shorter\n    // than the container size by the value of SLOP. This will make it only\n    // activate when gesture happens not further than SLOP away from the edge\n    const hitSlop = fromLeft\n      ? { left: 0, width: showing ? undefined : edgeWidth }\n      : { right: 0, width: showing ? undefined : edgeWidth };\n    this._panGestureHandler.current &&\n      this._panGestureHandler.current.setNativeProps({\n        hitSlop,\n        activeOffsetX: gestureOrientation * minSwipeDistance,\n      });\n  };\n\n  _animateDrawer = (fromValue: ?number, toValue: number, velocity: number) => {\n    this.state.dragX.setValue(0);\n    this.state.touchX.setValue(\n      this.props.drawerPosition === 'left' ? 0 : this.state.containerWidth\n    );\n\n    if (fromValue != null) {\n      let nextFramePosition = fromValue;\n      if (this.props.useNativeAnimations) {\n        // When using native driver, we predict the next position of the animation\n        // because it takes one frame of a roundtrip to pass RELEASE event from\n        // native driver to JS before we can start animating. Without it, it is more\n        // noticable that the frame is dropped.\n        if (fromValue < toValue && velocity > 0) {\n          nextFramePosition = Math.min(fromValue + velocity / 60.0, toValue);\n        } else if (fromValue > toValue && velocity < 0) {\n          nextFramePosition = Math.max(fromValue + velocity / 60.0, toValue);\n        }\n      }\n      this.state.drawerTranslation.setValue(nextFramePosition);\n    }\n\n    const willShow = toValue !== 0;\n    this._updateShowing(willShow);\n    this._emitStateChanged(SETTLING, willShow);\n    if (this.props.hideStatusBar) {\n      StatusBar.setHidden(willShow, this.props.statusBarAnimation || 'slide');\n    }\n    Animated.spring(this.state.drawerTranslation, {\n      velocity,\n      bounciness: 0,\n      toValue,\n      useNativeDriver: this.props.useNativeAnimations,\n    }).start(({ finished }) => {\n      if (finished) {\n        this._emitStateChanged(IDLE, willShow);\n        if (willShow) {\n          this.props.onDrawerOpen && this.props.onDrawerOpen();\n        } else {\n          this.props.onDrawerClose && this.props.onDrawerClose();\n        }\n      }\n    });\n  };\n\n  openDrawer = (options: DrawerMovementOptionType = {}) => {\n    this._animateDrawer(\n      undefined,\n      this.props.drawerWidth,\n      options.velocity ? options.velocity : 0\n    );\n\n    // We need to force the update, otherwise the overlay is not rerendered and it would not be clickable\n    this.forceUpdate();\n  };\n\n  closeDrawer = (options: DrawerMovementOptionType = {}) => {\n    this._animateDrawer(undefined, 0, options.velocity ? options.velocity : 0);\n\n    // We need to force the update, otherwise the overlay is not rerendered and it would be still clickable\n    this.forceUpdate();\n  };\n\n  _renderOverlay = () => {\n    /* Overlay styles */\n    invariant(this._openValue, 'should be set');\n    const overlayOpacity = this._openValue.interpolate({\n      inputRange: [0, 1],\n      outputRange: [0, 1],\n      extrapolate: 'clamp',\n    });\n    const dynamicOverlayStyles = {\n      opacity: overlayOpacity,\n      backgroundColor: this.props.overlayColor,\n    };\n\n    return (\n      <TapGestureHandler onHandlerStateChange={this._onTapHandlerStateChange}>\n        <Animated.View\n          pointerEvents={this._drawerShown ? 'auto' : 'none'}\n          ref={this._pointerEventsView}\n          style={[styles.overlay, dynamicOverlayStyles]}\n        />\n      </TapGestureHandler>\n    );\n  };\n\n  _renderDrawer = () => {\n    const {\n      drawerBackgroundColor,\n      drawerWidth,\n      drawerPosition,\n      drawerType,\n      drawerContainerStyle,\n      contentContainerStyle,\n    } = this.props;\n\n    const fromLeft = drawerPosition === 'left';\n    const drawerSlide = drawerType !== 'back';\n    const containerSlide = drawerType !== 'front';\n\n    // we rely on row and row-reverse flex directions to position the drawer\n    // properly. Apparently for RTL these are flipped which requires us to use\n    // the opposite setting for the drawer to appear from left or right according\n    // to the drawerPosition prop\n    const reverseContentDirection = I18nManager.isRTL ? fromLeft : !fromLeft;\n\n    const dynamicDrawerStyles = {\n      backgroundColor: drawerBackgroundColor,\n      width: drawerWidth,\n    };\n    const openValue = this._openValue;\n    invariant(openValue, 'should be set');\n\n    let containerStyles;\n    if (containerSlide) {\n      const containerTranslateX = openValue.interpolate({\n        inputRange: [0, 1],\n        outputRange: fromLeft ? [0, drawerWidth] : [0, -drawerWidth],\n        extrapolate: 'clamp',\n      });\n      containerStyles = {\n        transform: [{ translateX: containerTranslateX }],\n      };\n    }\n\n    let drawerTranslateX = 0;\n    if (drawerSlide) {\n      const closedDrawerOffset = fromLeft ? -drawerWidth : drawerWidth;\n      drawerTranslateX = openValue.interpolate({\n        inputRange: [0, 1],\n        outputRange: [closedDrawerOffset, 0],\n        extrapolate: 'clamp',\n      });\n    }\n    const drawerStyles = {\n      transform: [{ translateX: drawerTranslateX }],\n      flexDirection: reverseContentDirection ? 'row-reverse' : 'row',\n    };\n\n    return (\n      <Animated.View style={styles.main} onLayout={this._handleContainerLayout}>\n        <Animated.View\n          style={[\n            drawerType === 'front'\n              ? styles.containerOnBack\n              : styles.containerInFront,\n            containerStyles,\n            contentContainerStyle,\n          ]}\n          importantForAccessibility={\n            this._drawerShown ? 'no-hide-descendants' : 'yes'\n          }>\n          {typeof this.props.children === 'function'\n            ? this.props.children(this._openValue)\n            : this.props.children}\n          {this._renderOverlay()}\n        </Animated.View>\n        <Animated.View\n          pointerEvents=\"box-none\"\n          ref={this._accessibilityIsModalView}\n          accessibilityViewIsModal={this._drawerShown}\n          style={[styles.drawerContainer, drawerStyles, drawerContainerStyle]}>\n          <View style={dynamicDrawerStyles}>\n            {this.props.renderNavigationView(this._openValue)}\n          </View>\n        </Animated.View>\n      </Animated.View>\n    );\n  };\n\n  _setPanGestureRef = ref => {\n    this._panGestureHandler.current = ref;\n    this.props.onGestureRef && this.props.onGestureRef(ref);\n  };\n\n  render() {\n    const {\n      drawerPosition,\n      drawerLockMode,\n      edgeWidth,\n      minSwipeDistance,\n    } = this.props;\n\n    const fromLeft = drawerPosition === 'left';\n\n    // gestureOrientation is 1 if the expected gesture is from left to right and -1 otherwise\n    // e.g. when drawer is on the left and is closed we expect left to right gesture, thus\n    // orientation will be 1.\n    const gestureOrientation =\n      (fromLeft ? 1 : -1) * (this._drawerShown ? -1 : 1);\n\n    // When drawer is closed we want the hitSlop to be horizontally shorter\n    // than the container size by the value of SLOP. This will make it only\n    // activate when gesture happens not further than SLOP away from the edge\n    const hitSlop = fromLeft\n      ? { left: 0, width: this._drawerShown ? undefined : edgeWidth }\n      : { right: 0, width: this._drawerShown ? undefined : edgeWidth };\n\n    return (\n      <PanGestureHandler\n        ref={this._setPanGestureRef}\n        hitSlop={hitSlop}\n        activeOffsetX={gestureOrientation * minSwipeDistance}\n        failOffsetY={[-15, 15]}\n        onGestureEvent={this._onGestureEvent}\n        onHandlerStateChange={this._openingHandlerStateChange}\n        enabled={\n          drawerLockMode !== 'locked-closed' && drawerLockMode !== 'locked-open'\n        }>\n        {this._renderDrawer()}\n      </PanGestureHandler>\n    );\n  }\n}\n\nconst styles = StyleSheet.create({\n  drawerContainer: {\n    ...StyleSheet.absoluteFillObject,\n    zIndex: 1001,\n    flexDirection: 'row',\n  },\n  containerInFront: {\n    ...StyleSheet.absoluteFillObject,\n    zIndex: 1002,\n  },\n  containerOnBack: {\n    ...StyleSheet.absoluteFillObject,\n  },\n  main: {\n    flex: 1,\n    zIndex: 0,\n    overflow: 'hidden',\n  },\n  overlay: {\n    ...StyleSheet.absoluteFillObject,\n    zIndex: 1000,\n  },\n});\n","import { TouchableNativeFeedback } from 'react-native';\n\nexport default TouchableNativeFeedback;\n","import React, { Component } from 'react';\nimport { Animated, Platform } from 'react-native';\nimport { State, BaseButton } from '../GestureHandler';\nimport PropTypes from 'prop-types';\n\n/**\n * Each touchable is a states' machine which preforms transitions.\n * On very beginning (and on the very end or recognition) touchable is\n * UNDETERMINED. Then it moves to BEGAN. If touchable recognizes that finger\n * travel outside it transits to special MOVED_OUTSIDE state. Gesture recognition\n * finishes in UNDETERMINED state.\n */\nexport const TOUCHABLE_STATE = {\n  UNDETERMINED: 0,\n  BEGAN: 1,\n  MOVED_OUTSIDE: 2,\n};\n\nconst PublicPropTypes = {\n  // Decided to drop not used fields from RN's implementation.\n  // e.g. onBlur and onFocus as well as deprecated props.\n  accessible: PropTypes.bool,\n  accessibilityLabel: PropTypes.node,\n  accessibilityHint: PropTypes.string,\n  hitSlop: PropTypes.shape({\n    top: PropTypes.number,\n    left: PropTypes.number,\n    bottom: PropTypes.number,\n    right: PropTypes.number,\n  }),\n  disabled: PropTypes.bool,\n  onPress: PropTypes.func,\n  onPressIn: PropTypes.func,\n  onPressOut: PropTypes.func,\n  onLayout: PropTypes.func,\n  onLongPress: PropTypes.func,\n  nativeID: PropTypes.string,\n  testID: PropTypes.string,\n  delayPressIn: PropTypes.number,\n  delayPressOut: PropTypes.number,\n  delayLongPress: PropTypes.number,\n  shouldActivateOnStart: PropTypes.bool,\n  disallowInterruption: PropTypes.bool,\n};\n\nconst InternalPropTypes = {\n  extraButtonProps: PropTypes.object,\n  onStateChange: PropTypes.func,\n};\n\n/**\n * GenericTouchable is not intented to be used as it.\n * Should be treated as a source for the rest of touchables\n */\n\nexport default class GenericTouchable extends Component {\n  static publicPropTypes = PublicPropTypes;\n  static internalPropTypes = InternalPropTypes;\n\n  // The prop type collections have to be outside of the class, as metro\n  // at this time does not compile `this.foo` correctly if HMR is enabled.\n  // https://github.com/software-mansion/react-native-gesture-handler/pull/406#issuecomment-453779977\n  static propTypes = {\n    ...InternalPropTypes,\n    ...PublicPropTypes,\n  };\n\n  static defaultProps = {\n    delayLongPress: 600,\n    extraButtonProps: {\n      rippleColor: 'transparent',\n    },\n  };\n\n  // timeout handlers\n  pressInTimeout;\n  pressOutTimeout;\n  longPressTimeout;\n\n  // This flag is required since recognition of longPress implies not-invoking onPress\n  longPressDetected = false;\n\n  pointerInside = true;\n\n  // State of touchable\n  STATE = TOUCHABLE_STATE.UNDETERMINED;\n\n  // handlePressIn in called on first touch on traveling inside component.\n  // Handles state transition with delay.\n  handlePressIn() {\n    if (this.props.delayPressIn) {\n      this.pressInTimeout = setTimeout(() => {\n        this.moveToState(TOUCHABLE_STATE.BEGAN);\n        this.pressInTimeout = null;\n      }, this.props.delayPressIn);\n    } else {\n      this.moveToState(TOUCHABLE_STATE.BEGAN);\n    }\n    if (this.props.onLongPress) {\n      const time =\n        (this.props.delayPressIn || 0) + (this.props.delayLongPress || 0);\n      this.longPressTimeout = setTimeout(this.onLongPressDetected, time);\n    }\n  }\n  // handleMoveOutside in called on traveling outside component.\n  // Handles state transition with delay.\n  handleMoveOutside() {\n    if (this.props.delayPressOut) {\n      this.pressOutTimeout =\n        this.pressOutTimeout ||\n        setTimeout(() => {\n          this.moveToState(TOUCHABLE_STATE.MOVED_OUTSIDE);\n          this.pressOutTimeout = null;\n        }, this.props.delayPressOut);\n    } else {\n      this.moveToState(TOUCHABLE_STATE.MOVED_OUTSIDE);\n    }\n  }\n\n  // handleGoToUndetermined transits to UNDETERMINED state with proper delay\n  handleGoToUndetermined() {\n    clearTimeout(this.pressOutTimeout);\n    if (this.props.delayPressOut) {\n      this.pressOutTimeout = setTimeout(() => {\n        if (this.STATE === TOUCHABLE_STATE.UNDETERMINED) {\n          this.moveToState(TOUCHABLE_STATE.BEGAN);\n        }\n        this.moveToState(TOUCHABLE_STATE.UNDETERMINED);\n        this.pressOutTimeout = null;\n      }, this.props.delayPressOut);\n    } else {\n      if (this.STATE === TOUCHABLE_STATE.UNDETERMINED) {\n        this.moveToState(TOUCHABLE_STATE.BEGAN);\n      }\n      this.moveToState(TOUCHABLE_STATE.UNDETERMINED);\n    }\n  }\n\n  componentDidMount() {\n    this.reset();\n  }\n  // reset timeout to prevent memory leaks.\n  reset() {\n    this.longPressDetected = false;\n    this.pointerInside = true;\n    clearTimeout(this.pressInTimeout);\n    clearTimeout(this.pressOutTimeout);\n    clearTimeout(this.longPressTimeout);\n    this.pressOutTimeout = null;\n    this.longPressTimeout = null;\n    this.pressInTimeout = null;\n  }\n\n  // All states' transitions are defined here.\n  moveToState(newState) {\n    if (newState === this.STATE) {\n      // Ignore dummy transitions\n      return;\n    }\n    if (newState === TOUCHABLE_STATE.BEGAN) {\n      // First touch and moving inside\n      this.props.onPressIn && this.props.onPressIn();\n    } else if (newState === TOUCHABLE_STATE.MOVED_OUTSIDE) {\n      // Moving outside\n      this.props.onPressOut && this.props.onPressOut();\n    } else if (newState === TOUCHABLE_STATE.UNDETERMINED) {\n      // Need to reset each time on transition to UNDETERMINED\n      this.reset();\n      if (this.STATE === TOUCHABLE_STATE.BEGAN) {\n        // ... and if it happens inside button.\n        this.props.onPressOut && this.props.onPressOut();\n      }\n    }\n    // Finally call lister (used by subclasses)\n    this.props.onStateChange && this.props.onStateChange(this.STATE, newState);\n    // ... and make transition.\n    this.STATE = newState;\n  }\n\n  onGestureEvent = ({ nativeEvent: { pointerInside } }) => {\n    if (this.pointerInside !== pointerInside) {\n      if (pointerInside) {\n        this.onMoveIn();\n      } else {\n        this.onMoveOut();\n      }\n    }\n    this.pointerInside = pointerInside;\n  };\n\n  onHandlerStateChange = ({ nativeEvent }) => {\n    const { state } = nativeEvent;\n    if (state === State.CANCELLED || state === State.FAILED) {\n      // Need to handle case with external cancellation (e.g. by ScrollView)\n      this.moveToState(TOUCHABLE_STATE.UNDETERMINED);\n    } else if (\n      // This platform check is an implication of slightly different behavior of handlers on different platform.\n      // And Android \"Active\" state is achieving on first move of a finger, not on press in.\n      // On iOS event on \"Began\" is not delivered.\n      state === (Platform.OS !== 'android' ? State.ACTIVE : State.BEGAN) &&\n      this.STATE === TOUCHABLE_STATE.UNDETERMINED\n    ) {\n      // Moving inside requires\n      this.handlePressIn();\n    } else if (state === State.END) {\n      const shouldCallOnPress =\n        !this.longPressDetected &&\n        this.STATE !== TOUCHABLE_STATE.MOVED_OUTSIDE &&\n        this.pressOutTimeout === null;\n      this.handleGoToUndetermined();\n      if (shouldCallOnPress) {\n        // Calls only inside component whether no long press was called previously\n        this.props.onPress && this.props.onPress();\n      }\n    }\n  };\n\n  onLongPressDetected = () => {\n    this.longPressDetected = true;\n    this.props.onLongPress();\n  };\n\n  componentWillUnmount() {\n    // to prevent memory leaks\n    this.reset();\n  }\n\n  onMoveIn() {\n    if (this.STATE === TOUCHABLE_STATE.MOVED_OUTSIDE) {\n      // This call is not throttled with delays (like in RN's implementation).\n      this.moveToState(TOUCHABLE_STATE.BEGAN);\n    }\n  }\n\n  onMoveOut() {\n    // long press should no longer be detected\n    clearTimeout(this.longPressTimeout);\n    this.longPressTimeout = null;\n    if (this.STATE === TOUCHABLE_STATE.BEGAN) {\n      this.handleMoveOutside();\n    }\n  }\n\n  render() {\n    const coreProps = {\n      accessible: this.props.accessible !== false,\n      accessibilityLabel: this.props.accessibilityLabel,\n      accessibilityHint: this.props.accessibilityHint,\n      accessibilityComponentType: this.props.accessibilityComponentType,\n      accessibilityRole: this.props.accessibilityRole,\n      accessibilityStates: this.props.accessibilityStates,\n      accessibilityTraits: this.props.accessibilityTraits,\n      nativeID: this.props.nativeID,\n      onLayout: this.props.onLayout,\n      hitSlop: this.props.hitSlop,\n    };\n\n    return (\n      <BaseButton\n        style={this.props.containerStyle}\n        onHandlerStateChange={\n          this.props.disabled ? null : this.onHandlerStateChange\n        }\n        onGestureEvent={this.onGestureEvent}\n        hitSlop={this.props.hitSlop}\n        shouldActivateOnStart={this.props.shouldActivateOnStart}\n        disallowInterruption={this.props.disallowInterruption}\n        testID={this.props.testID}\n        {...this.props.extraButtonProps}>\n        <Animated.View {...coreProps} style={this.props.style}>\n          {this.props.children}\n        </Animated.View>\n      </BaseButton>\n    );\n  }\n}\n","import React from 'react';\nimport GenericTouchable from './GenericTouchable';\n\nconst TouchableWithoutFeedback = React.forwardRef((props, ref) => (\n  <GenericTouchable ref={ref} {...props} />\n));\n\nTouchableWithoutFeedback.defaultProps = GenericTouchable.defaultProps;\n\nTouchableWithoutFeedback.propTypes = GenericTouchable.publicPropTypes;\n\nexport default TouchableWithoutFeedback;\n","import { Animated, Easing, StyleSheet, View } from 'react-native';\nimport GenericTouchable, { TOUCHABLE_STATE } from './GenericTouchable';\nimport React, { Component } from 'react';\nimport PropTypes from 'prop-types';\n\n/**\n * TouchableOpacity bases on timing animation which has been used in RN's core\n */\nexport default class TouchableOpacity extends Component {\n  static defaultProps = {\n    ...GenericTouchable.defaultProps,\n    activeOpacity: 0.2,\n  };\n\n  static propTypes = {\n    ...GenericTouchable.publicPropTypes,\n    style: PropTypes.any,\n    activeOpacity: PropTypes.number,\n  };\n\n  // opacity is 1 one by default but could be overwritten\n  getChildStyleOpacityWithDefault = () => {\n    const childStyle = StyleSheet.flatten(this.props.style) || {};\n    return childStyle.opacity == null ? 1 : childStyle.opacity;\n  };\n\n  opacity = new Animated.Value(this.getChildStyleOpacityWithDefault());\n\n  setOpacityTo = (value, duration) => {\n    Animated.timing(this.opacity, {\n      toValue: value,\n      duration: duration,\n      easing: Easing.inOut(Easing.quad),\n      useNativeDriver: true,\n    }).start();\n  };\n\n  onStateChange = (from, to) => {\n    if (to === TOUCHABLE_STATE.BEGAN) {\n      this.setOpacityTo(this.props.activeOpacity, 0);\n    } else if (\n      to === TOUCHABLE_STATE.UNDETERMINED ||\n      to === TOUCHABLE_STATE.MOVED_OUTSIDE\n    ) {\n      this.setOpacityTo(this.getChildStyleOpacityWithDefault(), 150);\n    }\n  };\n\n  render() {\n    const { style = {}, ...rest } = this.props;\n    return (\n      <GenericTouchable\n        {...rest}\n        style={[\n          style,\n          {\n            opacity: this.opacity,\n          },\n        ]}\n        onStateChange={this.onStateChange}>\n        {this.props.children ? this.props.children : <View />}\n      </GenericTouchable>\n    );\n  }\n}\n","import React, { Component } from 'react';\nimport GenericTouchable, { TOUCHABLE_STATE } from './GenericTouchable';\nimport { StyleSheet, View } from 'react-native';\nimport PropTypes from 'prop-types';\n\n/**\n * TouchableHighlight follows RN's implementation\n */\nexport default class TouchableHighlight extends Component {\n  static defaultProps = {\n    ...GenericTouchable.defaultProps,\n    activeOpacity: 0.85,\n    delayPressOut: 100,\n    underlayColor: 'black',\n  };\n\n  static propTypes = {\n    ...GenericTouchable.publicPropTypes,\n    activeOpacity: PropTypes.number,\n    underlayColor: PropTypes.string,\n    style: PropTypes.any,\n    onShowUnderlay: PropTypes.func,\n    onHideUnderlay: PropTypes.func,\n  };\n\n  constructor(props) {\n    super(props);\n    this.state = {\n      extraChildStyle: null,\n      extraUnderlayStyle: null,\n    };\n  }\n\n  // Copied from RN\n  showUnderlay = () => {\n    if (!this.hasPressHandler()) {\n      return;\n    }\n    this.setState({\n      extraChildStyle: {\n        opacity: this.props.activeOpacity,\n      },\n      extraUnderlayStyle: {\n        backgroundColor: this.props.underlayColor,\n      },\n    });\n    this.props.onShowUnderlay && this.props.onShowUnderlay();\n  };\n\n  hasPressHandler = () =>\n    this.props.onPress ||\n    this.props.onPressIn ||\n    this.props.onPressOut ||\n    this.props.onLongPress;\n\n  hideUnderlay = () => {\n    this.setState({\n      extraChildStyle: null,\n      extraUnderlayStyle: null,\n    });\n    this.props.onHideUnderlay && this.props.onHideUnderlay();\n  };\n\n  renderChildren() {\n    if (!this.props.children) {\n      return <View />;\n    }\n\n    const child = React.Children.only(this.props.children);\n    return React.cloneElement(child, {\n      style: StyleSheet.compose(\n        child.props.style,\n        this.state.extraChildStyle\n      ),\n    });\n  }\n\n  onStateChange = (from, to) => {\n    if (to === TOUCHABLE_STATE.BEGAN) {\n      this.showUnderlay();\n    } else if (\n      to === TOUCHABLE_STATE.UNDETERMINED ||\n      to === TOUCHABLE_STATE.MOVED_OUTSIDE\n    ) {\n      this.hideUnderlay();\n    }\n  };\n\n  render() {\n    const { style = {}, ...rest } = this.props;\n    const { extraUnderlayStyle } = this.state;\n    return (\n      <GenericTouchable\n        {...rest}\n        style={[style, extraUnderlayStyle]}\n        onStateChange={this.onStateChange}>\n        {this.renderChildren()}\n      </GenericTouchable>\n    );\n  }\n}\n","/*! Hammer.JS - v2.0.17-rc - 2019-12-16\n * http://naver.github.io/egjs\n *\n * Forked By Naver egjs\n * Copyright (c) hammerjs\n * Licensed under the MIT license */\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\n/**\n * @private\n * extend object.\n * means that properties in dest will be overwritten by the ones in src.\n * @param {Object} target\n * @param {...Object} objects_to_assign\n * @returns {Object} target\n */\nvar assign;\n\nif (typeof Object.assign !== 'function') {\n  assign = function assign(target) {\n    if (target === undefined || target === null) {\n      throw new TypeError('Cannot convert undefined or null to object');\n    }\n\n    var output = Object(target);\n\n    for (var index = 1; index < arguments.length; index++) {\n      var source = arguments[index];\n\n      if (source !== undefined && source !== null) {\n        for (var nextKey in source) {\n          if (source.hasOwnProperty(nextKey)) {\n            output[nextKey] = source[nextKey];\n          }\n        }\n      }\n    }\n\n    return output;\n  };\n} else {\n  assign = Object.assign;\n}\n\nvar assign$1 = assign;\n\nvar VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];\nvar TEST_ELEMENT = typeof document === \"undefined\" ? {\n  style: {}\n} : document.createElement('div');\nvar TYPE_FUNCTION = 'function';\nvar round = Math.round,\n    abs = Math.abs;\nvar now = Date.now;\n\n/**\n * @private\n * get the prefixed property\n * @param {Object} obj\n * @param {String} property\n * @returns {String|Undefined} prefixed\n */\n\nfunction prefixed(obj, property) {\n  var prefix;\n  var prop;\n  var camelProp = property[0].toUpperCase() + property.slice(1);\n  var i = 0;\n\n  while (i < VENDOR_PREFIXES.length) {\n    prefix = VENDOR_PREFIXES[i];\n    prop = prefix ? prefix + camelProp : property;\n\n    if (prop in obj) {\n      return prop;\n    }\n\n    i++;\n  }\n\n  return undefined;\n}\n\n/* eslint-disable no-new-func, no-nested-ternary */\nvar win;\n\nif (typeof window === \"undefined\") {\n  // window is undefined in node.js\n  win = {};\n} else {\n  win = window;\n}\n\nvar PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');\nvar NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;\nfunction getTouchActionProps() {\n  if (!NATIVE_TOUCH_ACTION) {\n    return false;\n  }\n\n  var touchMap = {};\n  var cssSupports = win.CSS && win.CSS.supports;\n  ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function (val) {\n    // If css.supports is not supported but there is native touch-action assume it supports\n    // all values. This is the case for IE 10 and 11.\n    return touchMap[val] = cssSupports ? win.CSS.supports('touch-action', val) : true;\n  });\n  return touchMap;\n}\n\nvar TOUCH_ACTION_COMPUTE = 'compute';\nvar TOUCH_ACTION_AUTO = 'auto';\nvar TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented\n\nvar TOUCH_ACTION_NONE = 'none';\nvar TOUCH_ACTION_PAN_X = 'pan-x';\nvar TOUCH_ACTION_PAN_Y = 'pan-y';\nvar TOUCH_ACTION_MAP = getTouchActionProps();\n\nvar MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;\nvar SUPPORT_TOUCH = 'ontouchstart' in win;\nvar SUPPORT_POINTER_EVENTS = prefixed(win, 'PointerEvent') !== undefined;\nvar SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);\nvar INPUT_TYPE_TOUCH = 'touch';\nvar INPUT_TYPE_PEN = 'pen';\nvar INPUT_TYPE_MOUSE = 'mouse';\nvar INPUT_TYPE_KINECT = 'kinect';\nvar COMPUTE_INTERVAL = 25;\nvar INPUT_START = 1;\nvar INPUT_MOVE = 2;\nvar INPUT_END = 4;\nvar INPUT_CANCEL = 8;\nvar DIRECTION_NONE = 1;\nvar DIRECTION_LEFT = 2;\nvar DIRECTION_RIGHT = 4;\nvar DIRECTION_UP = 8;\nvar DIRECTION_DOWN = 16;\nvar DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;\nvar DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;\nvar DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;\nvar PROPS_XY = ['x', 'y'];\nvar PROPS_CLIENT_XY = ['clientX', 'clientY'];\n\n/**\n * @private\n * walk objects and arrays\n * @param {Object} obj\n * @param {Function} iterator\n * @param {Object} context\n */\nfunction each(obj, iterator, context) {\n  var i;\n\n  if (!obj) {\n    return;\n  }\n\n  if (obj.forEach) {\n    obj.forEach(iterator, context);\n  } else if (obj.length !== undefined) {\n    i = 0;\n\n    while (i < obj.length) {\n      iterator.call(context, obj[i], i, obj);\n      i++;\n    }\n  } else {\n    for (i in obj) {\n      obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);\n    }\n  }\n}\n\n/**\n * @private\n * let a boolean value also be a function that must return a boolean\n * this first item in args will be used as the context\n * @param {Boolean|Function} val\n * @param {Array} [args]\n * @returns {Boolean}\n */\n\nfunction boolOrFn(val, args) {\n  if (typeof val === TYPE_FUNCTION) {\n    return val.apply(args ? args[0] || undefined : undefined, args);\n  }\n\n  return val;\n}\n\n/**\n * @private\n * small indexOf wrapper\n * @param {String} str\n * @param {String} find\n * @returns {Boolean} found\n */\nfunction inStr(str, find) {\n  return str.indexOf(find) > -1;\n}\n\n/**\n * @private\n * when the touchActions are collected they are not a valid value, so we need to clean things up. *\n * @param {String} actions\n * @returns {*}\n */\n\nfunction cleanTouchActions(actions) {\n  // none\n  if (inStr(actions, TOUCH_ACTION_NONE)) {\n    return TOUCH_ACTION_NONE;\n  }\n\n  var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);\n  var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y); // if both pan-x and pan-y are set (different recognizers\n  // for different directions, e.g. horizontal pan but vertical swipe?)\n  // we need none (as otherwise with pan-x pan-y combined none of these\n  // recognizers will work, since the browser would handle all panning\n\n  if (hasPanX && hasPanY) {\n    return TOUCH_ACTION_NONE;\n  } // pan-x OR pan-y\n\n\n  if (hasPanX || hasPanY) {\n    return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;\n  } // manipulation\n\n\n  if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {\n    return TOUCH_ACTION_MANIPULATION;\n  }\n\n  return TOUCH_ACTION_AUTO;\n}\n\n/**\n * @private\n * Touch Action\n * sets the touchAction property or uses the js alternative\n * @param {Manager} manager\n * @param {String} value\n * @constructor\n */\n\nvar TouchAction =\n/*#__PURE__*/\nfunction () {\n  function TouchAction(manager, value) {\n    this.manager = manager;\n    this.set(value);\n  }\n  /**\n   * @private\n   * set the touchAction value on the element or enable the polyfill\n   * @param {String} value\n   */\n\n\n  var _proto = TouchAction.prototype;\n\n  _proto.set = function set(value) {\n    // find out the touch-action by the event handlers\n    if (value === TOUCH_ACTION_COMPUTE) {\n      value = this.compute();\n    }\n\n    if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {\n      this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;\n    }\n\n    this.actions = value.toLowerCase().trim();\n  };\n  /**\n   * @private\n   * just re-set the touchAction value\n   */\n\n\n  _proto.update = function update() {\n    this.set(this.manager.options.touchAction);\n  };\n  /**\n   * @private\n   * compute the value for the touchAction property based on the recognizer's settings\n   * @returns {String} value\n   */\n\n\n  _proto.compute = function compute() {\n    var actions = [];\n    each(this.manager.recognizers, function (recognizer) {\n      if (boolOrFn(recognizer.options.enable, [recognizer])) {\n        actions = actions.concat(recognizer.getTouchAction());\n      }\n    });\n    return cleanTouchActions(actions.join(' '));\n  };\n  /**\n   * @private\n   * this method is called on each input cycle and provides the preventing of the browser behavior\n   * @param {Object} input\n   */\n\n\n  _proto.preventDefaults = function preventDefaults(input) {\n    var srcEvent = input.srcEvent;\n    var direction = input.offsetDirection; // if the touch action did prevented once this session\n\n    if (this.manager.session.prevented) {\n      srcEvent.preventDefault();\n      return;\n    }\n\n    var actions = this.actions;\n    var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];\n    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];\n    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];\n\n    if (hasNone) {\n      // do not prevent defaults if this is a tap gesture\n      var isTapPointer = input.pointers.length === 1;\n      var isTapMovement = input.distance < 2;\n      var isTapTouchTime = input.deltaTime < 250;\n\n      if (isTapPointer && isTapMovement && isTapTouchTime) {\n        return;\n      }\n    }\n\n    if (hasPanX && hasPanY) {\n      // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent\n      return;\n    }\n\n    if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) {\n      return this.preventSrc(srcEvent);\n    }\n  };\n  /**\n   * @private\n   * call preventDefault to prevent the browser's default behavior (scrolling in most cases)\n   * @param {Object} srcEvent\n   */\n\n\n  _proto.preventSrc = function preventSrc(srcEvent) {\n    this.manager.session.prevented = true;\n    srcEvent.preventDefault();\n  };\n\n  return TouchAction;\n}();\n\n/**\n * @private\n * find if a node is in the given parent\n * @method hasParent\n * @param {HTMLElement} node\n * @param {HTMLElement} parent\n * @return {Boolean} found\n */\nfunction hasParent(node, parent) {\n  while (node) {\n    if (node === parent) {\n      return true;\n    }\n\n    node = node.parentNode;\n  }\n\n  return false;\n}\n\n/**\n * @private\n * get the center of all the pointers\n * @param {Array} pointers\n * @return {Object} center contains `x` and `y` properties\n */\n\nfunction getCenter(pointers) {\n  var pointersLength = pointers.length; // no need to loop when only one touch\n\n  if (pointersLength === 1) {\n    return {\n      x: round(pointers[0].clientX),\n      y: round(pointers[0].clientY)\n    };\n  }\n\n  var x = 0;\n  var y = 0;\n  var i = 0;\n\n  while (i < pointersLength) {\n    x += pointers[i].clientX;\n    y += pointers[i].clientY;\n    i++;\n  }\n\n  return {\n    x: round(x / pointersLength),\n    y: round(y / pointersLength)\n  };\n}\n\n/**\n * @private\n * create a simple clone from the input used for storage of firstInput and firstMultiple\n * @param {Object} input\n * @returns {Object} clonedInputData\n */\n\nfunction simpleCloneInputData(input) {\n  // make a simple copy of the pointers because we will get a reference if we don't\n  // we only need clientXY for the calculations\n  var pointers = [];\n  var i = 0;\n\n  while (i < input.pointers.length) {\n    pointers[i] = {\n      clientX: round(input.pointers[i].clientX),\n      clientY: round(input.pointers[i].clientY)\n    };\n    i++;\n  }\n\n  return {\n    timeStamp: now(),\n    pointers: pointers,\n    center: getCenter(pointers),\n    deltaX: input.deltaX,\n    deltaY: input.deltaY\n  };\n}\n\n/**\n * @private\n * calculate the absolute distance between two points\n * @param {Object} p1 {x, y}\n * @param {Object} p2 {x, y}\n * @param {Array} [props] containing x and y keys\n * @return {Number} distance\n */\n\nfunction getDistance(p1, p2, props) {\n  if (!props) {\n    props = PROPS_XY;\n  }\n\n  var x = p2[props[0]] - p1[props[0]];\n  var y = p2[props[1]] - p1[props[1]];\n  return Math.sqrt(x * x + y * y);\n}\n\n/**\n * @private\n * calculate the angle between two coordinates\n * @param {Object} p1\n * @param {Object} p2\n * @param {Array} [props] containing x and y keys\n * @return {Number} angle\n */\n\nfunction getAngle(p1, p2, props) {\n  if (!props) {\n    props = PROPS_XY;\n  }\n\n  var x = p2[props[0]] - p1[props[0]];\n  var y = p2[props[1]] - p1[props[1]];\n  return Math.atan2(y, x) * 180 / Math.PI;\n}\n\n/**\n * @private\n * get the direction between two points\n * @param {Number} x\n * @param {Number} y\n * @return {Number} direction\n */\n\nfunction getDirection(x, y) {\n  if (x === y) {\n    return DIRECTION_NONE;\n  }\n\n  if (abs(x) >= abs(y)) {\n    return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n  }\n\n  return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n}\n\nfunction computeDeltaXY(session, input) {\n  var center = input.center; // let { offsetDelta:offset = {}, prevDelta = {}, prevInput = {} } = session;\n  // jscs throwing error on defalut destructured values and without defaults tests fail\n\n  var offset = session.offsetDelta || {};\n  var prevDelta = session.prevDelta || {};\n  var prevInput = session.prevInput || {};\n\n  if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {\n    prevDelta = session.prevDelta = {\n      x: prevInput.deltaX || 0,\n      y: prevInput.deltaY || 0\n    };\n    offset = session.offsetDelta = {\n      x: center.x,\n      y: center.y\n    };\n  }\n\n  input.deltaX = prevDelta.x + (center.x - offset.x);\n  input.deltaY = prevDelta.y + (center.y - offset.y);\n}\n\n/**\n * @private\n * calculate the velocity between two points. unit is in px per ms.\n * @param {Number} deltaTime\n * @param {Number} x\n * @param {Number} y\n * @return {Object} velocity `x` and `y`\n */\nfunction getVelocity(deltaTime, x, y) {\n  return {\n    x: x / deltaTime || 0,\n    y: y / deltaTime || 0\n  };\n}\n\n/**\n * @private\n * calculate the scale factor between two pointersets\n * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\n * @param {Array} start array of pointers\n * @param {Array} end array of pointers\n * @return {Number} scale\n */\n\nfunction getScale(start, end) {\n  return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);\n}\n\n/**\n * @private\n * calculate the rotation degrees between two pointersets\n * @param {Array} start array of pointers\n * @param {Array} end array of pointers\n * @return {Number} rotation\n */\n\nfunction getRotation(start, end) {\n  return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);\n}\n\n/**\n * @private\n * velocity is calculated every x ms\n * @param {Object} session\n * @param {Object} input\n */\n\nfunction computeIntervalInputData(session, input) {\n  var last = session.lastInterval || input;\n  var deltaTime = input.timeStamp - last.timeStamp;\n  var velocity;\n  var velocityX;\n  var velocityY;\n  var direction;\n\n  if (input.eventType !== INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {\n    var deltaX = input.deltaX - last.deltaX;\n    var deltaY = input.deltaY - last.deltaY;\n    var v = getVelocity(deltaTime, deltaX, deltaY);\n    velocityX = v.x;\n    velocityY = v.y;\n    velocity = abs(v.x) > abs(v.y) ? v.x : v.y;\n    direction = getDirection(deltaX, deltaY);\n    session.lastInterval = input;\n  } else {\n    // use latest velocity info if it doesn't overtake a minimum period\n    velocity = last.velocity;\n    velocityX = last.velocityX;\n    velocityY = last.velocityY;\n    direction = last.direction;\n  }\n\n  input.velocity = velocity;\n  input.velocityX = velocityX;\n  input.velocityY = velocityY;\n  input.direction = direction;\n}\n\n/**\n* @private\n * extend the data with some usable properties like scale, rotate, velocity etc\n * @param {Object} manager\n * @param {Object} input\n */\n\nfunction computeInputData(manager, input) {\n  var session = manager.session;\n  var pointers = input.pointers;\n  var pointersLength = pointers.length; // store the first input to calculate the distance and direction\n\n  if (!session.firstInput) {\n    session.firstInput = simpleCloneInputData(input);\n  } // to compute scale and rotation we need to store the multiple touches\n\n\n  if (pointersLength > 1 && !session.firstMultiple) {\n    session.firstMultiple = simpleCloneInputData(input);\n  } else if (pointersLength === 1) {\n    session.firstMultiple = false;\n  }\n\n  var firstInput = session.firstInput,\n      firstMultiple = session.firstMultiple;\n  var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;\n  var center = input.center = getCenter(pointers);\n  input.timeStamp = now();\n  input.deltaTime = input.timeStamp - firstInput.timeStamp;\n  input.angle = getAngle(offsetCenter, center);\n  input.distance = getDistance(offsetCenter, center);\n  computeDeltaXY(session, input);\n  input.offsetDirection = getDirection(input.deltaX, input.deltaY);\n  var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);\n  input.overallVelocityX = overallVelocity.x;\n  input.overallVelocityY = overallVelocity.y;\n  input.overallVelocity = abs(overallVelocity.x) > abs(overallVelocity.y) ? overallVelocity.x : overallVelocity.y;\n  input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;\n  input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;\n  input.maxPointers = !session.prevInput ? input.pointers.length : input.pointers.length > session.prevInput.maxPointers ? input.pointers.length : session.prevInput.maxPointers;\n  computeIntervalInputData(session, input); // find the correct target\n\n  var target = manager.element;\n  var srcEvent = input.srcEvent;\n  var srcEventTarget;\n\n  if (srcEvent.composedPath) {\n    srcEventTarget = srcEvent.composedPath()[0];\n  } else if (srcEvent.path) {\n    srcEventTarget = srcEvent.path[0];\n  } else {\n    srcEventTarget = srcEvent.target;\n  }\n\n  if (hasParent(srcEventTarget, target)) {\n    target = srcEventTarget;\n  }\n\n  input.target = target;\n}\n\n/**\n * @private\n * handle input events\n * @param {Manager} manager\n * @param {String} eventType\n * @param {Object} input\n */\n\nfunction inputHandler(manager, eventType, input) {\n  var pointersLen = input.pointers.length;\n  var changedPointersLen = input.changedPointers.length;\n  var isFirst = eventType & INPUT_START && pointersLen - changedPointersLen === 0;\n  var isFinal = eventType & (INPUT_END | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;\n  input.isFirst = !!isFirst;\n  input.isFinal = !!isFinal;\n\n  if (isFirst) {\n    manager.session = {};\n  } // source event is the normalized value of the domEvents\n  // like 'touchstart, mouseup, pointerdown'\n\n\n  input.eventType = eventType; // compute scale, rotation etc\n\n  computeInputData(manager, input); // emit secret event\n\n  manager.emit('hammer.input', input);\n  manager.recognize(input);\n  manager.session.prevInput = input;\n}\n\n/**\n * @private\n * split string on whitespace\n * @param {String} str\n * @returns {Array} words\n */\nfunction splitStr(str) {\n  return str.trim().split(/\\s+/g);\n}\n\n/**\n * @private\n * addEventListener with multiple events at once\n * @param {EventTarget} target\n * @param {String} types\n * @param {Function} handler\n */\n\nfunction addEventListeners(target, types, handler) {\n  each(splitStr(types), function (type) {\n    target.addEventListener(type, handler, false);\n  });\n}\n\n/**\n * @private\n * removeEventListener with multiple events at once\n * @param {EventTarget} target\n * @param {String} types\n * @param {Function} handler\n */\n\nfunction removeEventListeners(target, types, handler) {\n  each(splitStr(types), function (type) {\n    target.removeEventListener(type, handler, false);\n  });\n}\n\n/**\n * @private\n * get the window object of an element\n * @param {HTMLElement} element\n * @returns {DocumentView|Window}\n */\nfunction getWindowForElement(element) {\n  var doc = element.ownerDocument || element;\n  return doc.defaultView || doc.parentWindow || window;\n}\n\n/**\n * @private\n * create new input type manager\n * @param {Manager} manager\n * @param {Function} callback\n * @returns {Input}\n * @constructor\n */\n\nvar Input =\n/*#__PURE__*/\nfunction () {\n  function Input(manager, callback) {\n    var self = this;\n    this.manager = manager;\n    this.callback = callback;\n    this.element = manager.element;\n    this.target = manager.options.inputTarget; // smaller wrapper around the handler, for the scope and the enabled state of the manager,\n    // so when disabled the input events are completely bypassed.\n\n    this.domHandler = function (ev) {\n      if (boolOrFn(manager.options.enable, [manager])) {\n        self.handler(ev);\n      }\n    };\n\n    this.init();\n  }\n  /**\n   * @private\n   * should handle the inputEvent data and trigger the callback\n   * @virtual\n   */\n\n\n  var _proto = Input.prototype;\n\n  _proto.handler = function handler() {};\n  /**\n   * @private\n   * bind the events\n   */\n\n\n  _proto.init = function init() {\n    this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);\n    this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);\n    this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n  };\n  /**\n   * @private\n   * unbind the events\n   */\n\n\n  _proto.destroy = function destroy() {\n    this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);\n    this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);\n    this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n  };\n\n  return Input;\n}();\n\n/**\n * @private\n * find if a array contains the object using indexOf or a simple polyFill\n * @param {Array} src\n * @param {String} find\n * @param {String} [findByKey]\n * @return {Boolean|Number} false when not found, or the index\n */\nfunction inArray(src, find, findByKey) {\n  if (src.indexOf && !findByKey) {\n    return src.indexOf(find);\n  } else {\n    var i = 0;\n\n    while (i < src.length) {\n      if (findByKey && src[i][findByKey] == find || !findByKey && src[i] === find) {\n        // do not use === here, test fails\n        return i;\n      }\n\n      i++;\n    }\n\n    return -1;\n  }\n}\n\nvar POINTER_INPUT_MAP = {\n  pointerdown: INPUT_START,\n  pointermove: INPUT_MOVE,\n  pointerup: INPUT_END,\n  pointercancel: INPUT_CANCEL,\n  pointerout: INPUT_CANCEL\n}; // in IE10 the pointer types is defined as an enum\n\nvar IE10_POINTER_TYPE_ENUM = {\n  2: INPUT_TYPE_TOUCH,\n  3: INPUT_TYPE_PEN,\n  4: INPUT_TYPE_MOUSE,\n  5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816\n\n};\nvar POINTER_ELEMENT_EVENTS = 'pointerdown';\nvar POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel'; // IE10 has prefixed support, and case-sensitive\n\nif (win.MSPointerEvent && !win.PointerEvent) {\n  POINTER_ELEMENT_EVENTS = 'MSPointerDown';\n  POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';\n}\n/**\n * @private\n * Pointer events input\n * @constructor\n * @extends Input\n */\n\n\nvar PointerEventInput =\n/*#__PURE__*/\nfunction (_Input) {\n  _inheritsLoose(PointerEventInput, _Input);\n\n  function PointerEventInput() {\n    var _this;\n\n    var proto = PointerEventInput.prototype;\n    proto.evEl = POINTER_ELEMENT_EVENTS;\n    proto.evWin = POINTER_WINDOW_EVENTS;\n    _this = _Input.apply(this, arguments) || this;\n    _this.store = _this.manager.session.pointerEvents = [];\n    return _this;\n  }\n  /**\n   * @private\n   * handle mouse events\n   * @param {Object} ev\n   */\n\n\n  var _proto = PointerEventInput.prototype;\n\n  _proto.handler = function handler(ev) {\n    var store = this.store;\n    var removePointer = false;\n    var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');\n    var eventType = POINTER_INPUT_MAP[eventTypeNormalized];\n    var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;\n    var isTouch = pointerType === INPUT_TYPE_TOUCH; // get index of the event in the store\n\n    var storeIndex = inArray(store, ev.pointerId, 'pointerId'); // start and mouse must be down\n\n    if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {\n      if (storeIndex < 0) {\n        store.push(ev);\n        storeIndex = store.length - 1;\n      }\n    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n      removePointer = true;\n    } // it not found, so the pointer hasn't been down (so it's probably a hover)\n\n\n    if (storeIndex < 0) {\n      return;\n    } // update the event in the store\n\n\n    store[storeIndex] = ev;\n    this.callback(this.manager, eventType, {\n      pointers: store,\n      changedPointers: [ev],\n      pointerType: pointerType,\n      srcEvent: ev\n    });\n\n    if (removePointer) {\n      // remove from the store\n      store.splice(storeIndex, 1);\n    }\n  };\n\n  return PointerEventInput;\n}(Input);\n\n/**\n * @private\n * convert array-like objects to real arrays\n * @param {Object} obj\n * @returns {Array}\n */\nfunction toArray(obj) {\n  return Array.prototype.slice.call(obj, 0);\n}\n\n/**\n * @private\n * unique array with objects based on a key (like 'id') or just by the array's value\n * @param {Array} src [{id:1},{id:2},{id:1}]\n * @param {String} [key]\n * @param {Boolean} [sort=False]\n * @returns {Array} [{id:1},{id:2}]\n */\n\nfunction uniqueArray(src, key, sort) {\n  var results = [];\n  var values = [];\n  var i = 0;\n\n  while (i < src.length) {\n    var val = key ? src[i][key] : src[i];\n\n    if (inArray(values, val) < 0) {\n      results.push(src[i]);\n    }\n\n    values[i] = val;\n    i++;\n  }\n\n  if (sort) {\n    if (!key) {\n      results = results.sort();\n    } else {\n      results = results.sort(function (a, b) {\n        return a[key] > b[key];\n      });\n    }\n  }\n\n  return results;\n}\n\nvar TOUCH_INPUT_MAP = {\n  touchstart: INPUT_START,\n  touchmove: INPUT_MOVE,\n  touchend: INPUT_END,\n  touchcancel: INPUT_CANCEL\n};\nvar TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';\n/**\n * @private\n * Multi-user touch events input\n * @constructor\n * @extends Input\n */\n\nvar TouchInput =\n/*#__PURE__*/\nfunction (_Input) {\n  _inheritsLoose(TouchInput, _Input);\n\n  function TouchInput() {\n    var _this;\n\n    TouchInput.prototype.evTarget = TOUCH_TARGET_EVENTS;\n    _this = _Input.apply(this, arguments) || this;\n    _this.targetIds = {}; // this.evTarget = TOUCH_TARGET_EVENTS;\n\n    return _this;\n  }\n\n  var _proto = TouchInput.prototype;\n\n  _proto.handler = function handler(ev) {\n    var type = TOUCH_INPUT_MAP[ev.type];\n    var touches = getTouches.call(this, ev, type);\n\n    if (!touches) {\n      return;\n    }\n\n    this.callback(this.manager, type, {\n      pointers: touches[0],\n      changedPointers: touches[1],\n      pointerType: INPUT_TYPE_TOUCH,\n      srcEvent: ev\n    });\n  };\n\n  return TouchInput;\n}(Input);\n\nfunction getTouches(ev, type) {\n  var allTouches = toArray(ev.touches);\n  var targetIds = this.targetIds; // when there is only one touch, the process can be simplified\n\n  if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {\n    targetIds[allTouches[0].identifier] = true;\n    return [allTouches, allTouches];\n  }\n\n  var i;\n  var targetTouches;\n  var changedTouches = toArray(ev.changedTouches);\n  var changedTargetTouches = [];\n  var target = this.target; // get target touches from touches\n\n  targetTouches = allTouches.filter(function (touch) {\n    return hasParent(touch.target, target);\n  }); // collect touches\n\n  if (type === INPUT_START) {\n    i = 0;\n\n    while (i < targetTouches.length) {\n      targetIds[targetTouches[i].identifier] = true;\n      i++;\n    }\n  } // filter changed touches to only contain touches that exist in the collected target ids\n\n\n  i = 0;\n\n  while (i < changedTouches.length) {\n    if (targetIds[changedTouches[i].identifier]) {\n      changedTargetTouches.push(changedTouches[i]);\n    } // cleanup removed touches\n\n\n    if (type & (INPUT_END | INPUT_CANCEL)) {\n      delete targetIds[changedTouches[i].identifier];\n    }\n\n    i++;\n  }\n\n  if (!changedTargetTouches.length) {\n    return;\n  }\n\n  return [// merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'\n  uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true), changedTargetTouches];\n}\n\nvar MOUSE_INPUT_MAP = {\n  mousedown: INPUT_START,\n  mousemove: INPUT_MOVE,\n  mouseup: INPUT_END\n};\nvar MOUSE_ELEMENT_EVENTS = 'mousedown';\nvar MOUSE_WINDOW_EVENTS = 'mousemove mouseup';\n/**\n * @private\n * Mouse events input\n * @constructor\n * @extends Input\n */\n\nvar MouseInput =\n/*#__PURE__*/\nfunction (_Input) {\n  _inheritsLoose(MouseInput, _Input);\n\n  function MouseInput() {\n    var _this;\n\n    var proto = MouseInput.prototype;\n    proto.evEl = MOUSE_ELEMENT_EVENTS;\n    proto.evWin = MOUSE_WINDOW_EVENTS;\n    _this = _Input.apply(this, arguments) || this;\n    _this.pressed = false; // mousedown state\n\n    return _this;\n  }\n  /**\n   * @private\n   * handle mouse events\n   * @param {Object} ev\n   */\n\n\n  var _proto = MouseInput.prototype;\n\n  _proto.handler = function handler(ev) {\n    var eventType = MOUSE_INPUT_MAP[ev.type]; // on start we want to have the left mouse button down\n\n    if (eventType & INPUT_START && ev.button === 0) {\n      this.pressed = true;\n    }\n\n    if (eventType & INPUT_MOVE && ev.which !== 1) {\n      eventType = INPUT_END;\n    } // mouse must be down\n\n\n    if (!this.pressed) {\n      return;\n    }\n\n    if (eventType & INPUT_END) {\n      this.pressed = false;\n    }\n\n    this.callback(this.manager, eventType, {\n      pointers: [ev],\n      changedPointers: [ev],\n      pointerType: INPUT_TYPE_MOUSE,\n      srcEvent: ev\n    });\n  };\n\n  return MouseInput;\n}(Input);\n\n/**\n * @private\n * Combined touch and mouse input\n *\n * Touch has a higher priority then mouse, and while touching no mouse events are allowed.\n * This because touch devices also emit mouse events while doing a touch.\n *\n * @constructor\n * @extends Input\n */\n\nvar DEDUP_TIMEOUT = 2500;\nvar DEDUP_DISTANCE = 25;\n\nfunction setLastTouch(eventData) {\n  var _eventData$changedPoi = eventData.changedPointers,\n      touch = _eventData$changedPoi[0];\n\n  if (touch.identifier === this.primaryTouch) {\n    var lastTouch = {\n      x: touch.clientX,\n      y: touch.clientY\n    };\n    var lts = this.lastTouches;\n    this.lastTouches.push(lastTouch);\n\n    var removeLastTouch = function removeLastTouch() {\n      var i = lts.indexOf(lastTouch);\n\n      if (i > -1) {\n        lts.splice(i, 1);\n      }\n    };\n\n    setTimeout(removeLastTouch, DEDUP_TIMEOUT);\n  }\n}\n\nfunction recordTouches(eventType, eventData) {\n  if (eventType & INPUT_START) {\n    this.primaryTouch = eventData.changedPointers[0].identifier;\n    setLastTouch.call(this, eventData);\n  } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n    setLastTouch.call(this, eventData);\n  }\n}\n\nfunction isSyntheticEvent(eventData) {\n  var x = eventData.srcEvent.clientX;\n  var y = eventData.srcEvent.clientY;\n\n  for (var i = 0; i < this.lastTouches.length; i++) {\n    var t = this.lastTouches[i];\n    var dx = Math.abs(x - t.x);\n    var dy = Math.abs(y - t.y);\n\n    if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nvar TouchMouseInput =\n/*#__PURE__*/\nfunction () {\n  var TouchMouseInput =\n  /*#__PURE__*/\n  function (_Input) {\n    _inheritsLoose(TouchMouseInput, _Input);\n\n    function TouchMouseInput(_manager, callback) {\n      var _this;\n\n      _this = _Input.call(this, _manager, callback) || this;\n\n      _this.handler = function (manager, inputEvent, inputData) {\n        var isTouch = inputData.pointerType === INPUT_TYPE_TOUCH;\n        var isMouse = inputData.pointerType === INPUT_TYPE_MOUSE;\n\n        if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {\n          return;\n        } // when we're in a touch event, record touches to  de-dupe synthetic mouse event\n\n\n        if (isTouch) {\n          recordTouches.call(_assertThisInitialized(_assertThisInitialized(_this)), inputEvent, inputData);\n        } else if (isMouse && isSyntheticEvent.call(_assertThisInitialized(_assertThisInitialized(_this)), inputData)) {\n          return;\n        }\n\n        _this.callback(manager, inputEvent, inputData);\n      };\n\n      _this.touch = new TouchInput(_this.manager, _this.handler);\n      _this.mouse = new MouseInput(_this.manager, _this.handler);\n      _this.primaryTouch = null;\n      _this.lastTouches = [];\n      return _this;\n    }\n    /**\n     * @private\n     * handle mouse and touch events\n     * @param {Hammer} manager\n     * @param {String} inputEvent\n     * @param {Object} inputData\n     */\n\n\n    var _proto = TouchMouseInput.prototype;\n\n    /**\n     * @private\n     * remove the event listeners\n     */\n    _proto.destroy = function destroy() {\n      this.touch.destroy();\n      this.mouse.destroy();\n    };\n\n    return TouchMouseInput;\n  }(Input);\n\n  return TouchMouseInput;\n}();\n\n/**\n * @private\n * create new input type manager\n * called by the Manager constructor\n * @param {Hammer} manager\n * @returns {Input}\n */\n\nfunction createInputInstance(manager) {\n  var Type; // let inputClass = manager.options.inputClass;\n\n  var inputClass = manager.options.inputClass;\n\n  if (inputClass) {\n    Type = inputClass;\n  } else if (SUPPORT_POINTER_EVENTS) {\n    Type = PointerEventInput;\n  } else if (SUPPORT_ONLY_TOUCH) {\n    Type = TouchInput;\n  } else if (!SUPPORT_TOUCH) {\n    Type = MouseInput;\n  } else {\n    Type = TouchMouseInput;\n  }\n\n  return new Type(manager, inputHandler);\n}\n\n/**\n * @private\n * if the argument is an array, we want to execute the fn on each entry\n * if it aint an array we don't want to do a thing.\n * this is used by all the methods that accept a single and array argument.\n * @param {*|Array} arg\n * @param {String} fn\n * @param {Object} [context]\n * @returns {Boolean}\n */\n\nfunction invokeArrayArg(arg, fn, context) {\n  if (Array.isArray(arg)) {\n    each(arg, context[fn], context);\n    return true;\n  }\n\n  return false;\n}\n\nvar STATE_POSSIBLE = 1;\nvar STATE_BEGAN = 2;\nvar STATE_CHANGED = 4;\nvar STATE_ENDED = 8;\nvar STATE_RECOGNIZED = STATE_ENDED;\nvar STATE_CANCELLED = 16;\nvar STATE_FAILED = 32;\n\n/**\n * @private\n * get a unique id\n * @returns {number} uniqueId\n */\nvar _uniqueId = 1;\nfunction uniqueId() {\n  return _uniqueId++;\n}\n\n/**\n * @private\n * get a recognizer by name if it is bound to a manager\n * @param {Recognizer|String} otherRecognizer\n * @param {Recognizer} recognizer\n * @returns {Recognizer}\n */\nfunction getRecognizerByNameIfManager(otherRecognizer, recognizer) {\n  var manager = recognizer.manager;\n\n  if (manager) {\n    return manager.get(otherRecognizer);\n  }\n\n  return otherRecognizer;\n}\n\n/**\n * @private\n * get a usable string, used as event postfix\n * @param {constant} state\n * @returns {String} state\n */\n\nfunction stateStr(state) {\n  if (state & STATE_CANCELLED) {\n    return 'cancel';\n  } else if (state & STATE_ENDED) {\n    return 'end';\n  } else if (state & STATE_CHANGED) {\n    return 'move';\n  } else if (state & STATE_BEGAN) {\n    return 'start';\n  }\n\n  return '';\n}\n\n/**\n * @private\n * Recognizer flow explained; *\n * All recognizers have the initial state of POSSIBLE when a input session starts.\n * The definition of a input session is from the first input until the last input, with all it's movement in it. *\n * Example session for mouse-input: mousedown -> mousemove -> mouseup\n *\n * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed\n * which determines with state it should be.\n *\n * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to\n * POSSIBLE to give it another change on the next cycle.\n *\n *               Possible\n *                  |\n *            +-----+---------------+\n *            |                     |\n *      +-----+-----+               |\n *      |           |               |\n *   Failed      Cancelled          |\n *                          +-------+------+\n *                          |              |\n *                      Recognized       Began\n *                                         |\n *                                      Changed\n *                                         |\n *                                  Ended/Recognized\n */\n\n/**\n * @private\n * Recognizer\n * Every recognizer needs to extend from this class.\n * @constructor\n * @param {Object} options\n */\n\nvar Recognizer =\n/*#__PURE__*/\nfunction () {\n  function Recognizer(options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    this.options = _extends({\n      enable: true\n    }, options);\n    this.id = uniqueId();\n    this.manager = null; // default is enable true\n\n    this.state = STATE_POSSIBLE;\n    this.simultaneous = {};\n    this.requireFail = [];\n  }\n  /**\n   * @private\n   * set options\n   * @param {Object} options\n   * @return {Recognizer}\n   */\n\n\n  var _proto = Recognizer.prototype;\n\n  _proto.set = function set(options) {\n    assign$1(this.options, options); // also update the touchAction, in case something changed about the directions/enabled state\n\n    this.manager && this.manager.touchAction.update();\n    return this;\n  };\n  /**\n   * @private\n   * recognize simultaneous with an other recognizer.\n   * @param {Recognizer} otherRecognizer\n   * @returns {Recognizer} this\n   */\n\n\n  _proto.recognizeWith = function recognizeWith(otherRecognizer) {\n    if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {\n      return this;\n    }\n\n    var simultaneous = this.simultaneous;\n    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n\n    if (!simultaneous[otherRecognizer.id]) {\n      simultaneous[otherRecognizer.id] = otherRecognizer;\n      otherRecognizer.recognizeWith(this);\n    }\n\n    return this;\n  };\n  /**\n   * @private\n   * drop the simultaneous link. it doesnt remove the link on the other recognizer.\n   * @param {Recognizer} otherRecognizer\n   * @returns {Recognizer} this\n   */\n\n\n  _proto.dropRecognizeWith = function dropRecognizeWith(otherRecognizer) {\n    if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {\n      return this;\n    }\n\n    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n    delete this.simultaneous[otherRecognizer.id];\n    return this;\n  };\n  /**\n   * @private\n   * recognizer can only run when an other is failing\n   * @param {Recognizer} otherRecognizer\n   * @returns {Recognizer} this\n   */\n\n\n  _proto.requireFailure = function requireFailure(otherRecognizer) {\n    if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {\n      return this;\n    }\n\n    var requireFail = this.requireFail;\n    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n\n    if (inArray(requireFail, otherRecognizer) === -1) {\n      requireFail.push(otherRecognizer);\n      otherRecognizer.requireFailure(this);\n    }\n\n    return this;\n  };\n  /**\n   * @private\n   * drop the requireFailure link. it does not remove the link on the other recognizer.\n   * @param {Recognizer} otherRecognizer\n   * @returns {Recognizer} this\n   */\n\n\n  _proto.dropRequireFailure = function dropRequireFailure(otherRecognizer) {\n    if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {\n      return this;\n    }\n\n    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n    var index = inArray(this.requireFail, otherRecognizer);\n\n    if (index > -1) {\n      this.requireFail.splice(index, 1);\n    }\n\n    return this;\n  };\n  /**\n   * @private\n   * has require failures boolean\n   * @returns {boolean}\n   */\n\n\n  _proto.hasRequireFailures = function hasRequireFailures() {\n    return this.requireFail.length > 0;\n  };\n  /**\n   * @private\n   * if the recognizer can recognize simultaneous with an other recognizer\n   * @param {Recognizer} otherRecognizer\n   * @returns {Boolean}\n   */\n\n\n  _proto.canRecognizeWith = function canRecognizeWith(otherRecognizer) {\n    return !!this.simultaneous[otherRecognizer.id];\n  };\n  /**\n   * @private\n   * You should use `tryEmit` instead of `emit` directly to check\n   * that all the needed recognizers has failed before emitting.\n   * @param {Object} input\n   */\n\n\n  _proto.emit = function emit(input) {\n    var self = this;\n    var state = this.state;\n\n    function emit(event) {\n      self.manager.emit(event, input);\n    } // 'panstart' and 'panmove'\n\n\n    if (state < STATE_ENDED) {\n      emit(self.options.event + stateStr(state));\n    }\n\n    emit(self.options.event); // simple 'eventName' events\n\n    if (input.additionalEvent) {\n      // additional event(panleft, panright, pinchin, pinchout...)\n      emit(input.additionalEvent);\n    } // panend and pancancel\n\n\n    if (state >= STATE_ENDED) {\n      emit(self.options.event + stateStr(state));\n    }\n  };\n  /**\n   * @private\n   * Check that all the require failure recognizers has failed,\n   * if true, it emits a gesture event,\n   * otherwise, setup the state to FAILED.\n   * @param {Object} input\n   */\n\n\n  _proto.tryEmit = function tryEmit(input) {\n    if (this.canEmit()) {\n      return this.emit(input);\n    } // it's failing anyway\n\n\n    this.state = STATE_FAILED;\n  };\n  /**\n   * @private\n   * can we emit?\n   * @returns {boolean}\n   */\n\n\n  _proto.canEmit = function canEmit() {\n    var i = 0;\n\n    while (i < this.requireFail.length) {\n      if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {\n        return false;\n      }\n\n      i++;\n    }\n\n    return true;\n  };\n  /**\n   * @private\n   * update the recognizer\n   * @param {Object} inputData\n   */\n\n\n  _proto.recognize = function recognize(inputData) {\n    // make a new copy of the inputData\n    // so we can change the inputData without messing up the other recognizers\n    var inputDataClone = assign$1({}, inputData); // is is enabled and allow recognizing?\n\n    if (!boolOrFn(this.options.enable, [this, inputDataClone])) {\n      this.reset();\n      this.state = STATE_FAILED;\n      return;\n    } // reset when we've reached the end\n\n\n    if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {\n      this.state = STATE_POSSIBLE;\n    }\n\n    this.state = this.process(inputDataClone); // the recognizer has recognized a gesture\n    // so trigger an event\n\n    if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {\n      this.tryEmit(inputDataClone);\n    }\n  };\n  /**\n   * @private\n   * return the state of the recognizer\n   * the actual recognizing happens in this method\n   * @virtual\n   * @param {Object} inputData\n   * @returns {constant} STATE\n   */\n\n  /* jshint ignore:start */\n\n\n  _proto.process = function process(inputData) {};\n  /* jshint ignore:end */\n\n  /**\n   * @private\n   * return the preferred touch-action\n   * @virtual\n   * @returns {Array}\n   */\n\n\n  _proto.getTouchAction = function getTouchAction() {};\n  /**\n   * @private\n   * called when the gesture isn't allowed to recognize\n   * like when another is being recognized or it is disabled\n   * @virtual\n   */\n\n\n  _proto.reset = function reset() {};\n\n  return Recognizer;\n}();\n\n/**\n * @private\n * A tap is recognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur\n * between the given interval and position. The delay option can be used to recognize multi-taps without firing\n * a single tap.\n *\n * The eventData from the emitted event contains the property `tapCount`, which contains the amount of\n * multi-taps being recognized.\n * @constructor\n * @extends Recognizer\n */\n\nvar TapRecognizer =\n/*#__PURE__*/\nfunction (_Recognizer) {\n  _inheritsLoose(TapRecognizer, _Recognizer);\n\n  function TapRecognizer(options) {\n    var _this;\n\n    if (options === void 0) {\n      options = {};\n    }\n\n    _this = _Recognizer.call(this, _extends({\n      event: 'tap',\n      pointers: 1,\n      taps: 1,\n      interval: 300,\n      // max time between the multi-tap taps\n      time: 250,\n      // max time of the pointer to be down (like finger on the screen)\n      threshold: 9,\n      // a minimal movement is ok, but keep it low\n      posThreshold: 10\n    }, options)) || this; // previous time and center,\n    // used for tap counting\n\n    _this.pTime = false;\n    _this.pCenter = false;\n    _this._timer = null;\n    _this._input = null;\n    _this.count = 0;\n    return _this;\n  }\n\n  var _proto = TapRecognizer.prototype;\n\n  _proto.getTouchAction = function getTouchAction() {\n    return [TOUCH_ACTION_MANIPULATION];\n  };\n\n  _proto.process = function process(input) {\n    var _this2 = this;\n\n    var options = this.options;\n    var validPointers = input.pointers.length === options.pointers;\n    var validMovement = input.distance < options.threshold;\n    var validTouchTime = input.deltaTime < options.time;\n    this.reset();\n\n    if (input.eventType & INPUT_START && this.count === 0) {\n      return this.failTimeout();\n    } // we only allow little movement\n    // and we've reached an end event, so a tap is possible\n\n\n    if (validMovement && validTouchTime && validPointers) {\n      if (input.eventType !== INPUT_END) {\n        return this.failTimeout();\n      }\n\n      var validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;\n      var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;\n      this.pTime = input.timeStamp;\n      this.pCenter = input.center;\n\n      if (!validMultiTap || !validInterval) {\n        this.count = 1;\n      } else {\n        this.count += 1;\n      }\n\n      this._input = input; // if tap count matches we have recognized it,\n      // else it has began recognizing...\n\n      var tapCount = this.count % options.taps;\n\n      if (tapCount === 0) {\n        // no failing requirements, immediately trigger the tap event\n        // or wait as long as the multitap interval to trigger\n        if (!this.hasRequireFailures()) {\n          return STATE_RECOGNIZED;\n        } else {\n          this._timer = setTimeout(function () {\n            _this2.state = STATE_RECOGNIZED;\n\n            _this2.tryEmit();\n          }, options.interval);\n          return STATE_BEGAN;\n        }\n      }\n    }\n\n    return STATE_FAILED;\n  };\n\n  _proto.failTimeout = function failTimeout() {\n    var _this3 = this;\n\n    this._timer = setTimeout(function () {\n      _this3.state = STATE_FAILED;\n    }, this.options.interval);\n    return STATE_FAILED;\n  };\n\n  _proto.reset = function reset() {\n    clearTimeout(this._timer);\n  };\n\n  _proto.emit = function emit() {\n    if (this.state === STATE_RECOGNIZED) {\n      this._input.tapCount = this.count;\n      this.manager.emit(this.options.event, this._input);\n    }\n  };\n\n  return TapRecognizer;\n}(Recognizer);\n\n/**\n * @private\n * This recognizer is just used as a base for the simple attribute recognizers.\n * @constructor\n * @extends Recognizer\n */\n\nvar AttrRecognizer =\n/*#__PURE__*/\nfunction (_Recognizer) {\n  _inheritsLoose(AttrRecognizer, _Recognizer);\n\n  function AttrRecognizer(options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    return _Recognizer.call(this, _extends({\n      pointers: 1\n    }, options)) || this;\n  }\n  /**\n   * @private\n   * Used to check if it the recognizer receives valid input, like input.distance > 10.\n   * @memberof AttrRecognizer\n   * @param {Object} input\n   * @returns {Boolean} recognized\n   */\n\n\n  var _proto = AttrRecognizer.prototype;\n\n  _proto.attrTest = function attrTest(input) {\n    var optionPointers = this.options.pointers;\n    return optionPointers === 0 || input.pointers.length === optionPointers;\n  };\n  /**\n   * @private\n   * Process the input and return the state for the recognizer\n   * @memberof AttrRecognizer\n   * @param {Object} input\n   * @returns {*} State\n   */\n\n\n  _proto.process = function process(input) {\n    var state = this.state;\n    var eventType = input.eventType;\n    var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);\n    var isValid = this.attrTest(input); // on cancel input and we've recognized before, return STATE_CANCELLED\n\n    if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {\n      return state | STATE_CANCELLED;\n    } else if (isRecognized || isValid) {\n      if (eventType & INPUT_END) {\n        return state | STATE_ENDED;\n      } else if (!(state & STATE_BEGAN)) {\n        return STATE_BEGAN;\n      }\n\n      return state | STATE_CHANGED;\n    }\n\n    return STATE_FAILED;\n  };\n\n  return AttrRecognizer;\n}(Recognizer);\n\n/**\n * @private\n * direction cons to string\n * @param {constant} direction\n * @returns {String}\n */\n\nfunction directionStr(direction) {\n  if (direction === DIRECTION_DOWN) {\n    return 'down';\n  } else if (direction === DIRECTION_UP) {\n    return 'up';\n  } else if (direction === DIRECTION_LEFT) {\n    return 'left';\n  } else if (direction === DIRECTION_RIGHT) {\n    return 'right';\n  }\n\n  return '';\n}\n\n/**\n * @private\n * Pan\n * Recognized when the pointer is down and moved in the allowed direction.\n * @constructor\n * @extends AttrRecognizer\n */\n\nvar PanRecognizer =\n/*#__PURE__*/\nfunction (_AttrRecognizer) {\n  _inheritsLoose(PanRecognizer, _AttrRecognizer);\n\n  function PanRecognizer(options) {\n    var _this;\n\n    if (options === void 0) {\n      options = {};\n    }\n\n    _this = _AttrRecognizer.call(this, _extends({\n      event: 'pan',\n      threshold: 10,\n      pointers: 1,\n      direction: DIRECTION_ALL\n    }, options)) || this;\n    _this.pX = null;\n    _this.pY = null;\n    return _this;\n  }\n\n  var _proto = PanRecognizer.prototype;\n\n  _proto.getTouchAction = function getTouchAction() {\n    var direction = this.options.direction;\n    var actions = [];\n\n    if (direction & DIRECTION_HORIZONTAL) {\n      actions.push(TOUCH_ACTION_PAN_Y);\n    }\n\n    if (direction & DIRECTION_VERTICAL) {\n      actions.push(TOUCH_ACTION_PAN_X);\n    }\n\n    return actions;\n  };\n\n  _proto.directionTest = function directionTest(input) {\n    var options = this.options;\n    var hasMoved = true;\n    var distance = input.distance;\n    var direction = input.direction;\n    var x = input.deltaX;\n    var y = input.deltaY; // lock to axis?\n\n    if (!(direction & options.direction)) {\n      if (options.direction & DIRECTION_HORIZONTAL) {\n        direction = x === 0 ? DIRECTION_NONE : x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n        hasMoved = x !== this.pX;\n        distance = Math.abs(input.deltaX);\n      } else {\n        direction = y === 0 ? DIRECTION_NONE : y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n        hasMoved = y !== this.pY;\n        distance = Math.abs(input.deltaY);\n      }\n    }\n\n    input.direction = direction;\n    return hasMoved && distance > options.threshold && direction & options.direction;\n  };\n\n  _proto.attrTest = function attrTest(input) {\n    return AttrRecognizer.prototype.attrTest.call(this, input) && ( // replace with a super call\n    this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input));\n  };\n\n  _proto.emit = function emit(input) {\n    this.pX = input.deltaX;\n    this.pY = input.deltaY;\n    var direction = directionStr(input.direction);\n\n    if (direction) {\n      input.additionalEvent = this.options.event + direction;\n    }\n\n    _AttrRecognizer.prototype.emit.call(this, input);\n  };\n\n  return PanRecognizer;\n}(AttrRecognizer);\n\n/**\n * @private\n * Swipe\n * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.\n * @constructor\n * @extends AttrRecognizer\n */\n\nvar SwipeRecognizer =\n/*#__PURE__*/\nfunction (_AttrRecognizer) {\n  _inheritsLoose(SwipeRecognizer, _AttrRecognizer);\n\n  function SwipeRecognizer(options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    return _AttrRecognizer.call(this, _extends({\n      event: 'swipe',\n      threshold: 10,\n      velocity: 0.3,\n      direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,\n      pointers: 1\n    }, options)) || this;\n  }\n\n  var _proto = SwipeRecognizer.prototype;\n\n  _proto.getTouchAction = function getTouchAction() {\n    return PanRecognizer.prototype.getTouchAction.call(this);\n  };\n\n  _proto.attrTest = function attrTest(input) {\n    var direction = this.options.direction;\n    var velocity;\n\n    if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {\n      velocity = input.overallVelocity;\n    } else if (direction & DIRECTION_HORIZONTAL) {\n      velocity = input.overallVelocityX;\n    } else if (direction & DIRECTION_VERTICAL) {\n      velocity = input.overallVelocityY;\n    }\n\n    return _AttrRecognizer.prototype.attrTest.call(this, input) && direction & input.offsetDirection && input.distance > this.options.threshold && input.maxPointers === this.options.pointers && abs(velocity) > this.options.velocity && input.eventType & INPUT_END;\n  };\n\n  _proto.emit = function emit(input) {\n    var direction = directionStr(input.offsetDirection);\n\n    if (direction) {\n      this.manager.emit(this.options.event + direction, input);\n    }\n\n    this.manager.emit(this.options.event, input);\n  };\n\n  return SwipeRecognizer;\n}(AttrRecognizer);\n\n/**\n * @private\n * Pinch\n * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).\n * @constructor\n * @extends AttrRecognizer\n */\n\nvar PinchRecognizer =\n/*#__PURE__*/\nfunction (_AttrRecognizer) {\n  _inheritsLoose(PinchRecognizer, _AttrRecognizer);\n\n  function PinchRecognizer(options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    return _AttrRecognizer.call(this, _extends({\n      event: 'pinch',\n      threshold: 0,\n      pointers: 2\n    }, options)) || this;\n  }\n\n  var _proto = PinchRecognizer.prototype;\n\n  _proto.getTouchAction = function getTouchAction() {\n    return [TOUCH_ACTION_NONE];\n  };\n\n  _proto.attrTest = function attrTest(input) {\n    return _AttrRecognizer.prototype.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);\n  };\n\n  _proto.emit = function emit(input) {\n    if (input.scale !== 1) {\n      var inOut = input.scale < 1 ? 'in' : 'out';\n      input.additionalEvent = this.options.event + inOut;\n    }\n\n    _AttrRecognizer.prototype.emit.call(this, input);\n  };\n\n  return PinchRecognizer;\n}(AttrRecognizer);\n\n/**\n * @private\n * Rotate\n * Recognized when two or more pointer are moving in a circular motion.\n * @constructor\n * @extends AttrRecognizer\n */\n\nvar RotateRecognizer =\n/*#__PURE__*/\nfunction (_AttrRecognizer) {\n  _inheritsLoose(RotateRecognizer, _AttrRecognizer);\n\n  function RotateRecognizer(options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    return _AttrRecognizer.call(this, _extends({\n      event: 'rotate',\n      threshold: 0,\n      pointers: 2\n    }, options)) || this;\n  }\n\n  var _proto = RotateRecognizer.prototype;\n\n  _proto.getTouchAction = function getTouchAction() {\n    return [TOUCH_ACTION_NONE];\n  };\n\n  _proto.attrTest = function attrTest(input) {\n    return _AttrRecognizer.prototype.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);\n  };\n\n  return RotateRecognizer;\n}(AttrRecognizer);\n\n/**\n * @private\n * Press\n * Recognized when the pointer is down for x ms without any movement.\n * @constructor\n * @extends Recognizer\n */\n\nvar PressRecognizer =\n/*#__PURE__*/\nfunction (_Recognizer) {\n  _inheritsLoose(PressRecognizer, _Recognizer);\n\n  function PressRecognizer(options) {\n    var _this;\n\n    if (options === void 0) {\n      options = {};\n    }\n\n    _this = _Recognizer.call(this, _extends({\n      event: 'press',\n      pointers: 1,\n      time: 251,\n      // minimal time of the pointer to be pressed\n      threshold: 9\n    }, options)) || this;\n    _this._timer = null;\n    _this._input = null;\n    return _this;\n  }\n\n  var _proto = PressRecognizer.prototype;\n\n  _proto.getTouchAction = function getTouchAction() {\n    return [TOUCH_ACTION_AUTO];\n  };\n\n  _proto.process = function process(input) {\n    var _this2 = this;\n\n    var options = this.options;\n    var validPointers = input.pointers.length === options.pointers;\n    var validMovement = input.distance < options.threshold;\n    var validTime = input.deltaTime > options.time;\n    this._input = input; // we only allow little movement\n    // and we've reached an end event, so a tap is possible\n\n    if (!validMovement || !validPointers || input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime) {\n      this.reset();\n    } else if (input.eventType & INPUT_START) {\n      this.reset();\n      this._timer = setTimeout(function () {\n        _this2.state = STATE_RECOGNIZED;\n\n        _this2.tryEmit();\n      }, options.time);\n    } else if (input.eventType & INPUT_END) {\n      return STATE_RECOGNIZED;\n    }\n\n    return STATE_FAILED;\n  };\n\n  _proto.reset = function reset() {\n    clearTimeout(this._timer);\n  };\n\n  _proto.emit = function emit(input) {\n    if (this.state !== STATE_RECOGNIZED) {\n      return;\n    }\n\n    if (input && input.eventType & INPUT_END) {\n      this.manager.emit(this.options.event + \"up\", input);\n    } else {\n      this._input.timeStamp = now();\n      this.manager.emit(this.options.event, this._input);\n    }\n  };\n\n  return PressRecognizer;\n}(Recognizer);\n\nvar defaults = {\n  /**\n   * @private\n   * set if DOM events are being triggered.\n   * But this is slower and unused by simple implementations, so disabled by default.\n   * @type {Boolean}\n   * @default false\n   */\n  domEvents: false,\n\n  /**\n   * @private\n   * The value for the touchAction property/fallback.\n   * When set to `compute` it will magically set the correct value based on the added recognizers.\n   * @type {String}\n   * @default compute\n   */\n  touchAction: TOUCH_ACTION_COMPUTE,\n\n  /**\n   * @private\n   * @type {Boolean}\n   * @default true\n   */\n  enable: true,\n\n  /**\n   * @private\n   * EXPERIMENTAL FEATURE -- can be removed/changed\n   * Change the parent input target element.\n   * If Null, then it is being set the to main element.\n   * @type {Null|EventTarget}\n   * @default null\n   */\n  inputTarget: null,\n\n  /**\n   * @private\n   * force an input class\n   * @type {Null|Function}\n   * @default null\n   */\n  inputClass: null,\n\n  /**\n   * @private\n   * Some CSS properties can be used to improve the working of Hammer.\n   * Add them to this method and they will be set when creating a new Manager.\n   * @namespace\n   */\n  cssProps: {\n    /**\n     * @private\n     * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.\n     * @type {String}\n     * @default 'none'\n     */\n    userSelect: \"none\",\n\n    /**\n     * @private\n     * Disable the Windows Phone grippers when pressing an element.\n     * @type {String}\n     * @default 'none'\n     */\n    touchSelect: \"none\",\n\n    /**\n     * @private\n     * Disables the default callout shown when you touch and hold a touch target.\n     * On iOS, when you touch and hold a touch target such as a link, Safari displays\n     * a callout containing information about the link. This property allows you to disable that callout.\n     * @type {String}\n     * @default 'none'\n     */\n    touchCallout: \"none\",\n\n    /**\n     * @private\n     * Specifies whether zooming is enabled. Used by IE10>\n     * @type {String}\n     * @default 'none'\n     */\n    contentZooming: \"none\",\n\n    /**\n     * @private\n     * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.\n     * @type {String}\n     * @default 'none'\n     */\n    userDrag: \"none\",\n\n    /**\n     * @private\n     * Overrides the highlight color shown when the user taps a link or a JavaScript\n     * clickable element in iOS. This property obeys the alpha value, if specified.\n     * @type {String}\n     * @default 'rgba(0,0,0,0)'\n     */\n    tapHighlightColor: \"rgba(0,0,0,0)\"\n  }\n};\n/**\n * @private\n * Default recognizer setup when calling `Hammer()`\n * When creating a new Manager these will be skipped.\n * This is separated with other defaults because of tree-shaking.\n * @type {Array}\n */\n\nvar preset = [[RotateRecognizer, {\n  enable: false\n}], [PinchRecognizer, {\n  enable: false\n}, ['rotate']], [SwipeRecognizer, {\n  direction: DIRECTION_HORIZONTAL\n}], [PanRecognizer, {\n  direction: DIRECTION_HORIZONTAL\n}, ['swipe']], [TapRecognizer], [TapRecognizer, {\n  event: 'doubletap',\n  taps: 2\n}, ['tap']], [PressRecognizer]];\n\nvar STOP = 1;\nvar FORCED_STOP = 2;\n/**\n * @private\n * add/remove the css properties as defined in manager.options.cssProps\n * @param {Manager} manager\n * @param {Boolean} add\n */\n\nfunction toggleCssProps(manager, add) {\n  var element = manager.element;\n\n  if (!element.style) {\n    return;\n  }\n\n  var prop;\n  each(manager.options.cssProps, function (value, name) {\n    prop = prefixed(element.style, name);\n\n    if (add) {\n      manager.oldCssProps[prop] = element.style[prop];\n      element.style[prop] = value;\n    } else {\n      element.style[prop] = manager.oldCssProps[prop] || \"\";\n    }\n  });\n\n  if (!add) {\n    manager.oldCssProps = {};\n  }\n}\n/**\n * @private\n * trigger dom event\n * @param {String} event\n * @param {Object} data\n */\n\n\nfunction triggerDomEvent(event, data) {\n  var gestureEvent = document.createEvent(\"Event\");\n  gestureEvent.initEvent(event, true, true);\n  gestureEvent.gesture = data;\n  data.target.dispatchEvent(gestureEvent);\n}\n/**\n* @private\n * Manager\n * @param {HTMLElement} element\n * @param {Object} [options]\n * @constructor\n */\n\n\nvar Manager =\n/*#__PURE__*/\nfunction () {\n  function Manager(element, options) {\n    var _this = this;\n\n    this.options = assign$1({}, defaults, options || {});\n    this.options.inputTarget = this.options.inputTarget || element;\n    this.handlers = {};\n    this.session = {};\n    this.recognizers = [];\n    this.oldCssProps = {};\n    this.element = element;\n    this.input = createInputInstance(this);\n    this.touchAction = new TouchAction(this, this.options.touchAction);\n    toggleCssProps(this, true);\n    each(this.options.recognizers, function (item) {\n      var recognizer = _this.add(new item[0](item[1]));\n\n      item[2] && recognizer.recognizeWith(item[2]);\n      item[3] && recognizer.requireFailure(item[3]);\n    }, this);\n  }\n  /**\n   * @private\n   * set options\n   * @param {Object} options\n   * @returns {Manager}\n   */\n\n\n  var _proto = Manager.prototype;\n\n  _proto.set = function set(options) {\n    assign$1(this.options, options); // Options that need a little more setup\n\n    if (options.touchAction) {\n      this.touchAction.update();\n    }\n\n    if (options.inputTarget) {\n      // Clean up existing event listeners and reinitialize\n      this.input.destroy();\n      this.input.target = options.inputTarget;\n      this.input.init();\n    }\n\n    return this;\n  };\n  /**\n   * @private\n   * stop recognizing for this session.\n   * This session will be discarded, when a new [input]start event is fired.\n   * When forced, the recognizer cycle is stopped immediately.\n   * @param {Boolean} [force]\n   */\n\n\n  _proto.stop = function stop(force) {\n    this.session.stopped = force ? FORCED_STOP : STOP;\n  };\n  /**\n   * @private\n   * run the recognizers!\n   * called by the inputHandler function on every movement of the pointers (touches)\n   * it walks through all the recognizers and tries to detect the gesture that is being made\n   * @param {Object} inputData\n   */\n\n\n  _proto.recognize = function recognize(inputData) {\n    var session = this.session;\n\n    if (session.stopped) {\n      return;\n    } // run the touch-action polyfill\n\n\n    this.touchAction.preventDefaults(inputData);\n    var recognizer;\n    var recognizers = this.recognizers; // this holds the recognizer that is being recognized.\n    // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED\n    // if no recognizer is detecting a thing, it is set to `null`\n\n    var curRecognizer = session.curRecognizer; // reset when the last recognizer is recognized\n    // or when we're in a new session\n\n    if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) {\n      session.curRecognizer = null;\n      curRecognizer = null;\n    }\n\n    var i = 0;\n\n    while (i < recognizers.length) {\n      recognizer = recognizers[i]; // find out if we are allowed try to recognize the input for this one.\n      // 1.   allow if the session is NOT forced stopped (see the .stop() method)\n      // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one\n      //      that is being recognized.\n      // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.\n      //      this can be setup with the `recognizeWith()` method on the recognizer.\n\n      if (session.stopped !== FORCED_STOP && ( // 1\n      !curRecognizer || recognizer === curRecognizer || // 2\n      recognizer.canRecognizeWith(curRecognizer))) {\n        // 3\n        recognizer.recognize(inputData);\n      } else {\n        recognizer.reset();\n      } // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the\n      // current active recognizer. but only if we don't already have an active recognizer\n\n\n      if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {\n        session.curRecognizer = recognizer;\n        curRecognizer = recognizer;\n      }\n\n      i++;\n    }\n  };\n  /**\n   * @private\n   * get a recognizer by its event name.\n   * @param {Recognizer|String} recognizer\n   * @returns {Recognizer|Null}\n   */\n\n\n  _proto.get = function get(recognizer) {\n    if (recognizer instanceof Recognizer) {\n      return recognizer;\n    }\n\n    var recognizers = this.recognizers;\n\n    for (var i = 0; i < recognizers.length; i++) {\n      if (recognizers[i].options.event === recognizer) {\n        return recognizers[i];\n      }\n    }\n\n    return null;\n  };\n  /**\n   * @private add a recognizer to the manager\n   * existing recognizers with the same event name will be removed\n   * @param {Recognizer} recognizer\n   * @returns {Recognizer|Manager}\n   */\n\n\n  _proto.add = function add(recognizer) {\n    if (invokeArrayArg(recognizer, \"add\", this)) {\n      return this;\n    } // remove existing\n\n\n    var existing = this.get(recognizer.options.event);\n\n    if (existing) {\n      this.remove(existing);\n    }\n\n    this.recognizers.push(recognizer);\n    recognizer.manager = this;\n    this.touchAction.update();\n    return recognizer;\n  };\n  /**\n   * @private\n   * remove a recognizer by name or instance\n   * @param {Recognizer|String} recognizer\n   * @returns {Manager}\n   */\n\n\n  _proto.remove = function remove(recognizer) {\n    if (invokeArrayArg(recognizer, \"remove\", this)) {\n      return this;\n    }\n\n    var targetRecognizer = this.get(recognizer); // let's make sure this recognizer exists\n\n    if (recognizer) {\n      var recognizers = this.recognizers;\n      var index = inArray(recognizers, targetRecognizer);\n\n      if (index !== -1) {\n        recognizers.splice(index, 1);\n        this.touchAction.update();\n      }\n    }\n\n    return this;\n  };\n  /**\n   * @private\n   * bind event\n   * @param {String} events\n   * @param {Function} handler\n   * @returns {EventEmitter} this\n   */\n\n\n  _proto.on = function on(events, handler) {\n    if (events === undefined || handler === undefined) {\n      return this;\n    }\n\n    var handlers = this.handlers;\n    each(splitStr(events), function (event) {\n      handlers[event] = handlers[event] || [];\n      handlers[event].push(handler);\n    });\n    return this;\n  };\n  /**\n   * @private unbind event, leave emit blank to remove all handlers\n   * @param {String} events\n   * @param {Function} [handler]\n   * @returns {EventEmitter} this\n   */\n\n\n  _proto.off = function off(events, handler) {\n    if (events === undefined) {\n      return this;\n    }\n\n    var handlers = this.handlers;\n    each(splitStr(events), function (event) {\n      if (!handler) {\n        delete handlers[event];\n      } else {\n        handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);\n      }\n    });\n    return this;\n  };\n  /**\n   * @private emit event to the listeners\n   * @param {String} event\n   * @param {Object} data\n   */\n\n\n  _proto.emit = function emit(event, data) {\n    // we also want to trigger dom events\n    if (this.options.domEvents) {\n      triggerDomEvent(event, data);\n    } // no handlers, so skip it all\n\n\n    var handlers = this.handlers[event] && this.handlers[event].slice();\n\n    if (!handlers || !handlers.length) {\n      return;\n    }\n\n    data.type = event;\n\n    data.preventDefault = function () {\n      data.srcEvent.preventDefault();\n    };\n\n    var i = 0;\n\n    while (i < handlers.length) {\n      handlers[i](data);\n      i++;\n    }\n  };\n  /**\n   * @private\n   * destroy the manager and unbinds all events\n   * it doesn't unbind dom events, that is the user own responsibility\n   */\n\n\n  _proto.destroy = function destroy() {\n    this.element && toggleCssProps(this, false);\n    this.handlers = {};\n    this.session = {};\n    this.input.destroy();\n    this.element = null;\n  };\n\n  return Manager;\n}();\n\nvar SINGLE_TOUCH_INPUT_MAP = {\n  touchstart: INPUT_START,\n  touchmove: INPUT_MOVE,\n  touchend: INPUT_END,\n  touchcancel: INPUT_CANCEL\n};\nvar SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';\nvar SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';\n/**\n * @private\n * Touch events input\n * @constructor\n * @extends Input\n */\n\nvar SingleTouchInput =\n/*#__PURE__*/\nfunction (_Input) {\n  _inheritsLoose(SingleTouchInput, _Input);\n\n  function SingleTouchInput() {\n    var _this;\n\n    var proto = SingleTouchInput.prototype;\n    proto.evTarget = SINGLE_TOUCH_TARGET_EVENTS;\n    proto.evWin = SINGLE_TOUCH_WINDOW_EVENTS;\n    _this = _Input.apply(this, arguments) || this;\n    _this.started = false;\n    return _this;\n  }\n\n  var _proto = SingleTouchInput.prototype;\n\n  _proto.handler = function handler(ev) {\n    var type = SINGLE_TOUCH_INPUT_MAP[ev.type]; // should we handle the touch events?\n\n    if (type === INPUT_START) {\n      this.started = true;\n    }\n\n    if (!this.started) {\n      return;\n    }\n\n    var touches = normalizeSingleTouches.call(this, ev, type); // when done, reset the started state\n\n    if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {\n      this.started = false;\n    }\n\n    this.callback(this.manager, type, {\n      pointers: touches[0],\n      changedPointers: touches[1],\n      pointerType: INPUT_TYPE_TOUCH,\n      srcEvent: ev\n    });\n  };\n\n  return SingleTouchInput;\n}(Input);\n\nfunction normalizeSingleTouches(ev, type) {\n  var all = toArray(ev.touches);\n  var changed = toArray(ev.changedTouches);\n\n  if (type & (INPUT_END | INPUT_CANCEL)) {\n    all = uniqueArray(all.concat(changed), 'identifier', true);\n  }\n\n  return [all, changed];\n}\n\n/**\n * @private\n * wrap a method with a deprecation warning and stack trace\n * @param {Function} method\n * @param {String} name\n * @param {String} message\n * @returns {Function} A new function wrapping the supplied method.\n */\nfunction deprecate(method, name, message) {\n  var deprecationMessage = \"DEPRECATED METHOD: \" + name + \"\\n\" + message + \" AT \\n\";\n  return function () {\n    var e = new Error('get-stack-trace');\n    var stack = e && e.stack ? e.stack.replace(/^[^\\(]+?[\\n$]/gm, '').replace(/^\\s+at\\s+/gm, '').replace(/^Object.<anonymous>\\s*\\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';\n    var log = window.console && (window.console.warn || window.console.log);\n\n    if (log) {\n      log.call(window.console, deprecationMessage, stack);\n    }\n\n    return method.apply(this, arguments);\n  };\n}\n\n/**\n * @private\n * extend object.\n * means that properties in dest will be overwritten by the ones in src.\n * @param {Object} dest\n * @param {Object} src\n * @param {Boolean} [merge=false]\n * @returns {Object} dest\n */\n\nvar extend = deprecate(function (dest, src, merge) {\n  var keys = Object.keys(src);\n  var i = 0;\n\n  while (i < keys.length) {\n    if (!merge || merge && dest[keys[i]] === undefined) {\n      dest[keys[i]] = src[keys[i]];\n    }\n\n    i++;\n  }\n\n  return dest;\n}, 'extend', 'Use `assign`.');\n\n/**\n * @private\n * merge the values from src in the dest.\n * means that properties that exist in dest will not be overwritten by src\n * @param {Object} dest\n * @param {Object} src\n * @returns {Object} dest\n */\n\nvar merge = deprecate(function (dest, src) {\n  return extend(dest, src, true);\n}, 'merge', 'Use `assign`.');\n\n/**\n * @private\n * simple class inheritance\n * @param {Function} child\n * @param {Function} base\n * @param {Object} [properties]\n */\n\nfunction inherit(child, base, properties) {\n  var baseP = base.prototype;\n  var childP;\n  childP = child.prototype = Object.create(baseP);\n  childP.constructor = child;\n  childP._super = baseP;\n\n  if (properties) {\n    assign$1(childP, properties);\n  }\n}\n\n/**\n * @private\n * simple function bind\n * @param {Function} fn\n * @param {Object} context\n * @returns {Function}\n */\nfunction bindFn(fn, context) {\n  return function boundFn() {\n    return fn.apply(context, arguments);\n  };\n}\n\n/**\n * @private\n * Simple way to create a manager with a default set of recognizers.\n * @param {HTMLElement} element\n * @param {Object} [options]\n * @constructor\n */\n\nvar Hammer =\n/*#__PURE__*/\nfunction () {\n  var Hammer =\n  /**\n    * @private\n    * @const {string}\n    */\n  function Hammer(element, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    return new Manager(element, _extends({\n      recognizers: preset.concat()\n    }, options));\n  };\n\n  Hammer.VERSION = \"2.0.17-rc\";\n  Hammer.DIRECTION_ALL = DIRECTION_ALL;\n  Hammer.DIRECTION_DOWN = DIRECTION_DOWN;\n  Hammer.DIRECTION_LEFT = DIRECTION_LEFT;\n  Hammer.DIRECTION_RIGHT = DIRECTION_RIGHT;\n  Hammer.DIRECTION_UP = DIRECTION_UP;\n  Hammer.DIRECTION_HORIZONTAL = DIRECTION_HORIZONTAL;\n  Hammer.DIRECTION_VERTICAL = DIRECTION_VERTICAL;\n  Hammer.DIRECTION_NONE = DIRECTION_NONE;\n  Hammer.DIRECTION_DOWN = DIRECTION_DOWN;\n  Hammer.INPUT_START = INPUT_START;\n  Hammer.INPUT_MOVE = INPUT_MOVE;\n  Hammer.INPUT_END = INPUT_END;\n  Hammer.INPUT_CANCEL = INPUT_CANCEL;\n  Hammer.STATE_POSSIBLE = STATE_POSSIBLE;\n  Hammer.STATE_BEGAN = STATE_BEGAN;\n  Hammer.STATE_CHANGED = STATE_CHANGED;\n  Hammer.STATE_ENDED = STATE_ENDED;\n  Hammer.STATE_RECOGNIZED = STATE_RECOGNIZED;\n  Hammer.STATE_CANCELLED = STATE_CANCELLED;\n  Hammer.STATE_FAILED = STATE_FAILED;\n  Hammer.Manager = Manager;\n  Hammer.Input = Input;\n  Hammer.TouchAction = TouchAction;\n  Hammer.TouchInput = TouchInput;\n  Hammer.MouseInput = MouseInput;\n  Hammer.PointerEventInput = PointerEventInput;\n  Hammer.TouchMouseInput = TouchMouseInput;\n  Hammer.SingleTouchInput = SingleTouchInput;\n  Hammer.Recognizer = Recognizer;\n  Hammer.AttrRecognizer = AttrRecognizer;\n  Hammer.Tap = TapRecognizer;\n  Hammer.Pan = PanRecognizer;\n  Hammer.Swipe = SwipeRecognizer;\n  Hammer.Pinch = PinchRecognizer;\n  Hammer.Rotate = RotateRecognizer;\n  Hammer.Press = PressRecognizer;\n  Hammer.on = addEventListeners;\n  Hammer.off = removeEventListeners;\n  Hammer.each = each;\n  Hammer.merge = merge;\n  Hammer.extend = extend;\n  Hammer.bindFn = bindFn;\n  Hammer.assign = assign$1;\n  Hammer.inherit = inherit;\n  Hammer.bindFn = bindFn;\n  Hammer.prefixed = prefixed;\n  Hammer.toArray = toArray;\n  Hammer.inArray = inArray;\n  Hammer.uniqueArray = uniqueArray;\n  Hammer.splitStr = splitStr;\n  Hammer.boolOrFn = boolOrFn;\n  Hammer.hasParent = hasParent;\n  Hammer.addEventListeners = addEventListeners;\n  Hammer.removeEventListeners = removeEventListeners;\n  Hammer.defaults = assign$1({}, defaults, {\n    preset: preset\n  });\n  return Hammer;\n}();\n\n//  style loader but by script tag, not by the loader.\n\nvar defaults$1 = Hammer.defaults;\n\nexport default Hammer;\nexport { INPUT_START, INPUT_MOVE, INPUT_END, INPUT_CANCEL, STATE_POSSIBLE, STATE_BEGAN, STATE_CHANGED, STATE_ENDED, STATE_RECOGNIZED, STATE_CANCELLED, STATE_FAILED, DIRECTION_NONE, DIRECTION_LEFT, DIRECTION_RIGHT, DIRECTION_UP, DIRECTION_DOWN, DIRECTION_HORIZONTAL, DIRECTION_VERTICAL, DIRECTION_ALL, Manager, Input, TouchAction, TouchInput, MouseInput, PointerEventInput, TouchMouseInput, SingleTouchInput, Recognizer, AttrRecognizer, TapRecognizer as Tap, PanRecognizer as Pan, SwipeRecognizer as Swipe, PinchRecognizer as Pinch, RotateRecognizer as Rotate, PressRecognizer as Press, addEventListeners as on, removeEventListeners as off, each, merge, extend, assign$1 as assign, inherit, bindFn, prefixed, toArray, inArray, uniqueArray, splitStr, boolOrFn, hasParent, addEventListeners, removeEventListeners, defaults$1 as defaults };\n//# sourceMappingURL=hammer.esm.js.map\n","import Hammer from '@egjs/hammerjs';\n\nimport State from '../State';\n\nexport const CONTENT_TOUCHES_DELAY = 240;\nexport const CONTENT_TOUCHES_QUICK_TAP_END_DELAY = 50;\nexport const MULTI_FINGER_PAN_MAX_PINCH_THRESHOLD = 0.1;\nexport const MULTI_FINGER_PAN_MAX_ROTATION_THRESHOLD = 7;\nexport const DEG_RAD = Math.PI / 180;\n\n// Map Hammer values to RNGH\nexport const EventMap = {\n  [Hammer.INPUT_START]: State.BEGAN,\n  [Hammer.INPUT_MOVE]: State.ACTIVE,\n  [Hammer.INPUT_END]: State.END,\n  [Hammer.INPUT_CANCEL]: State.FAILED,\n};\n\nexport const Direction = {\n  RIGHT: 1,\n  LEFT: 2,\n  UP: 4,\n  DOWN: 8,\n};\n\nexport const DirectionMap = {\n  [Hammer.DIRECTION_RIGHT]: Direction.RIGHT,\n  [Hammer.DIRECTION_LEFT]: Direction.LEFT,\n  [Hammer.DIRECTION_UP]: Direction.UP,\n  [Hammer.DIRECTION_DOWN]: Direction.DOWN,\n};\n\nexport const HammerInputNames = {\n  [Hammer.INPUT_START]: 'START',\n  [Hammer.INPUT_MOVE]: 'MOVE',\n  [Hammer.INPUT_END]: 'END',\n  [Hammer.INPUT_CANCEL]: 'CANCEL',\n};\nexport const HammerDirectionNames = {\n  [Hammer.DIRECTION_HORIZONTAL]: 'HORIZONTAL',\n  [Hammer.DIRECTION_UP]: 'UP',\n  [Hammer.DIRECTION_DOWN]: 'DOWN',\n  [Hammer.DIRECTION_VERTICAL]: 'VERTICAL',\n  [Hammer.DIRECTION_NONE]: 'NONE',\n  [Hammer.DIRECTION_ALL]: 'ALL',\n  [Hammer.DIRECTION_RIGHT]: 'RIGHT',\n  [Hammer.DIRECTION_LEFT]: 'LEFT',\n};\n","export class GesturePropError extends Error {\n  constructor(name, value, expectedType) {\n    super(`Invalid property \\`${name}: ${value}\\` expected \\`${expectedType}\\``);\n  }\n}\n","let gestures = {};\n\nexport function getHandler(tag) {\n  if (tag in gestures) return gestures[tag];\n\n  throw new Error('No handler for tag ' + tag);\n}\n\nexport function createGestureHandler(handlerTag, handler) {\n  if (handlerTag in gestures) {\n    throw new Error('Handler with tag ' + handlerTag + ' already exists');\n  }\n  gestures[handlerTag] = handler;\n  gestures[handlerTag].handlerTag = handlerTag;\n}\n\nexport function dropGestureHandler(handlerTag) {\n  getHandler(handlerTag).destroy();\n  delete gestures[handlerTag];\n}\n\nexport function getNodes() {\n  return { ...gestures };\n}\n","import Hammer from '@egjs/hammerjs';\nimport { findNodeHandle } from 'react-native';\n\nimport State from '../State';\nimport { EventMap } from './constants';\nimport * as NodeManager from './NodeManager';\n\nlet _gestureInstances = 0;\n\nclass GestureHandler {\n  isGestureRunning = false;\n  hasGestureFailed = false;\n  view = null;\n  config = {};\n  hammer = null;\n  pendingGestures = {};\n  oldState = State.UNDETERMINED;\n  previousState = State.UNDETERMINED;\n  lastSentState = null;\n\n  get id() {\n    return `${this.name}${this._gestureInstance}`;\n  }\n\n  get isDiscrete() {\n    return false;\n  }\n\n  get shouldEnableGestureOnSetup() {\n    throw new Error('Must override GestureHandler.shouldEnableGestureOnSetup');\n  }\n\n  constructor() {\n    this._gestureInstance = _gestureInstances++;\n  }\n\n  getConfig() {\n    return this.config;\n  }\n\n  onWaitingEnded(gesture) {}\n\n  removePendingGesture(id) {\n    delete this.pendingGestures[id];\n  }\n\n  addPendingGesture(gesture) {\n    this.pendingGestures[gesture.id] = gesture;\n  }\n\n  isGestureEnabledForEvent() {\n    return { success: true };\n  }\n\n  parseNativeEvent(nativeEvent) {\n    return nativeEvent;\n  }\n\n  get NativeGestureClass() {\n    throw new Error('Must override GestureHandler.NativeGestureClass');\n  }\n\n  updateHasCustomActivationCriteria(config) {\n    return true;\n  }\n\n  clearSelfAsPending = () => {\n    if (Array.isArray(this.config.waitFor)) {\n      for (const gesture of this.config.waitFor) {\n        gesture.removePendingGesture(this.id);\n      }\n    }\n  };\n\n  updateGestureConfig({ enabled = true, ...props }) {\n    this.clearSelfAsPending();\n\n    this.config = ensureConfig({ enabled, ...props });\n    this._hasCustomActivationCriteria = this.updateHasCustomActivationCriteria(\n      this.config\n    );\n    if (Array.isArray(this.config.waitFor)) {\n      for (const gesture of this.config.waitFor) {\n        gesture.addPendingGesture(this);\n      }\n    }\n\n    if (this.hammer) {\n      this.sync();\n    }\n    return this.config;\n  }\n\n  destroy = () => {\n    this.clearSelfAsPending();\n\n    if (this.hammer) {\n      this.hammer.stop();\n      this.hammer.destroy();\n    }\n    this.hammer = null;\n  };\n\n  isPointInView = ({ x, y }) => {\n    const rect = this.view.getBoundingClientRect();\n    const pointerInside =\n      x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom;\n    return pointerInside;\n  };\n\n  getState(type) {\n    return EventMap[type];\n  }\n\n  transformEventData(event) {\n    const { eventType, maxPointers: numberOfPointers } = event;\n    // const direction = DirectionMap[ev.direction];\n    const changedTouch = event.changedPointers[0];\n    const pointerInside = this.isPointInView({\n      x: changedTouch.clientX,\n      y: changedTouch.clientY,\n    });\n\n    const state = this.getState(eventType);\n    if (state !== this.previousState) {\n      this.oldState = this.previousState;\n      this.previousState = state;\n    }\n\n    return {\n      nativeEvent: {\n        numberOfPointers,\n        state,\n        pointerInside,\n        ...this.transformNativeEvent(event),\n        // onHandlerStateChange only\n        handlerTag: this.handlerTag,\n        target: this.ref,\n        oldState: this.oldState,\n      },\n      timeStamp: Date.now(),\n    };\n  }\n\n  transformNativeEvent(event) {\n    return {};\n  }\n\n  sendEvent = nativeEvent => {\n    const {\n      onGestureHandlerStateChange: onHandlerStateChange,\n      onGestureHandlerEvent: onGestureEvent,\n    } = this.ref.props;\n\n    const event = this.transformEventData(nativeEvent);\n\n    invokeNullableMethod('onGestureEvent', onGestureEvent, event);\n    if (this.lastSentState !== event.nativeEvent.state) {\n      this.lastSentState = event.nativeEvent.state;\n      invokeNullableMethod('onHandlerStateChange', onHandlerStateChange, event);\n    }\n  };\n\n  cancelPendingGestures(event) {\n    for (const gesture of Object.values(this.pendingGestures)) {\n      if (gesture && gesture.isGestureRunning) {\n        gesture.hasGestureFailed = true;\n        gesture.cancelEvent(event);\n      }\n    }\n  }\n\n  notifyPendingGestures() {\n    for (const gesture of Object.values(this.pendingGestures)) {\n      if (gesture) {\n        gesture.onWaitingEnded(this);\n      }\n    }\n  }\n\n  onGestureEnded(event) {\n    this.isGestureRunning = false;\n    this.cancelPendingGestures(event);\n  }\n\n  forceInvalidate(event) {\n    if (this.isGestureRunning) {\n      this.hasGestureFailed = true;\n      this.cancelEvent(event);\n    }\n  }\n\n  cancelEvent(event) {\n    this.notifyPendingGestures();\n    this.sendEvent({\n      ...event,\n      eventType: Hammer.INPUT_CANCEL,\n      isFinal: true,\n    });\n    this.onGestureEnded(event);\n  }\n\n  onRawEvent({ isFirst }) {\n    if (isFirst) {\n      this.hasGestureFailed = false;\n    }\n  }\n\n  setView(ref) {\n    if (ref == null) {\n      this.destroy();\n      this.view = null;\n      return;\n    }\n\n    this.ref = ref;\n\n    this.view = findNodeHandle(ref);\n    this.hammer = new Hammer.Manager(this.view);\n\n    this.oldState = State.UNDETERMINED;\n    this.previousState = State.UNDETERMINED;\n    this.lastSentState = null;\n\n    const { NativeGestureClass } = this;\n    const gesture = new NativeGestureClass(this.getHammerConfig());\n    this.hammer.add(gesture);\n\n    this.hammer.on('hammer.input', ev => {\n      if (!this.config.enabled) {\n        this.hasGestureFailed = false;\n        this.isGestureRunning = false;\n        return;\n      }\n\n      this.onRawEvent(ev);\n\n      // TODO: Bacon: Check against something other than null\n      // The isFirst value is not called when the first rotation is calculated.\n      if (this.initialRotation === null && ev.rotation !== 0) {\n        this.initialRotation = ev.rotation;\n      }\n      if (ev.isFinal) {\n        // in favor of a willFail otherwise the last frame of the gesture will be captured.\n        setTimeout(() => {\n          this.initialRotation = null;\n          this.hasGestureFailed = false;\n        });\n      }\n    });\n\n    this.setupEvents();\n    this.sync();\n  }\n\n  setupEvents() {\n    if (!this.isDiscrete) {\n      this.hammer.on(`${this.name}start`, event => this.onStart(event));\n      this.hammer.on(`${this.name}end ${this.name}cancel`, event =>\n        this.onGestureEnded(event)\n      );\n    }\n    this.hammer.on(this.name, ev => this.onGestureActivated(ev));\n  }\n\n  onStart({ deltaX, deltaY, rotation }) {\n    // Reset the state for the next gesture\n    this.oldState = State.UNDETERMINED;\n    this.previousState = State.UNDETERMINED;\n    this.lastSentState = null;\n\n    this.isGestureRunning = true;\n    this.__initialX = deltaX;\n    this.__initialY = deltaY;\n    this.initialRotation = rotation;\n  }\n\n  onGestureActivated(ev) {\n    this.sendEvent(ev);\n  }\n\n  onSuccess() {}\n\n  _getPendingGestures() {\n    if (Array.isArray(this.config.waitFor) && this.config.waitFor.length) {\n      // Get the list of gestures that this gesture is still waiting for.\n      // Use `=== false` in case a ref that isn't a gesture handler is used.\n      const stillWaiting = this.config.waitFor.filter(\n        ({ hasGestureFailed }) => hasGestureFailed === false\n      );\n      return stillWaiting;\n    }\n    return [];\n  }\n\n  getHammerConfig() {\n    const pointers =\n      this.config.minPointers === this.config.maxPointers\n        ? this.config.minPointers\n        : 0;\n    return {\n      pointers,\n    };\n  }\n\n  sync = () => {\n    const gesture = this.hammer.get(this.name);\n    if (!gesture) return;\n\n    const enable = (recognizer, inputData) => {\n      if (!this.config.enabled) {\n        this.isGestureRunning = false;\n        this.hasGestureFailed = false;\n        return false;\n      }\n\n      // Prevent events before the system is ready.\n      if (\n        !inputData ||\n        !recognizer.options ||\n        typeof inputData.maxPointers === 'undefined'\n      ) {\n        return this.shouldEnableGestureOnSetup;\n      }\n\n      if (this.hasGestureFailed) {\n        return false;\n      }\n\n      if (!this.isDiscrete) {\n        if (this.isGestureRunning) {\n          return true;\n        }\n        // The built-in hammer.js \"waitFor\" doesn't work across multiple views.\n        // Only process if there are views to wait for.\n        this._stillWaiting = this._getPendingGestures();\n        // This gesture should continue waiting.\n        if (this._stillWaiting.length) {\n          // Check to see if one of the gestures you're waiting for has started.\n          // If it has then the gesture should fail.\n          for (const gesture of this._stillWaiting) {\n            // When the target gesture has started, this gesture must force fail.\n            if (!gesture.isDiscrete && gesture.isGestureRunning) {\n              this.hasGestureFailed = true;\n              this.isGestureRunning = false;\n              return false;\n            }\n          }\n          // This gesture shouldn't start until the others have finished.\n          return false;\n        }\n      }\n\n      // Use default behaviour\n      if (!this._hasCustomActivationCriteria) {\n        return true;\n      }\n\n      const deltaRotation =\n        this.initialRotation == null\n          ? 0\n          : inputData.rotation - this.initialRotation;\n      const { success, failed } = this.isGestureEnabledForEvent(\n        this.getConfig(),\n        recognizer,\n        {\n          ...inputData,\n          deltaRotation,\n        }\n      );\n\n      if (failed) {\n        this.simulateCancelEvent(inputData);\n        this.hasGestureFailed = true;\n      }\n      return success;\n    };\n\n    const params = this.getHammerConfig();\n    gesture.set({ ...params, enable });\n  };\n\n  simulateCancelEvent(inputData) {}\n}\n\n// Used for sending data to a callback or AnimatedEvent\nfunction invokeNullableMethod(name, method, event) {\n  if (method) {\n    if (typeof method === 'function') {\n      method(event);\n    } else {\n      // For use with reanimated's AnimatedEvent\n      if (\n        '__getHandler' in method &&\n        typeof method.__getHandler === 'function'\n      ) {\n        const handler = method.__getHandler();\n        invokeNullableMethod(name, handler, event);\n      } else {\n        if ('__nodeConfig' in method) {\n          const { argMapping } = method.__nodeConfig;\n          if (Array.isArray(argMapping)) {\n            for (const index in argMapping) {\n              const [key, value] = argMapping[index];\n              if (key in event.nativeEvent) {\n                const nativeValue = event.nativeEvent[key];\n                if (value && value.setValue) {\n                  // Reanimated API\n                  value.setValue(nativeValue);\n                } else {\n                  // RN Animated API\n                  method.__nodeConfig.argMapping[index] = [key, nativeValue];\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\n// Validate the props\nfunction ensureConfig(config) {\n  const props = { ...config };\n\n  if ('minDist' in config) {\n    props.minDist = config.minDist;\n    props.minDistSq = props.minDist * props.minDist;\n  }\n  if ('minVelocity' in config) {\n    props.minVelocity = config.minVelocity;\n    props.minVelocitySq = props.minVelocity * props.minVelocity;\n  }\n  if ('maxDist' in config) {\n    props.maxDist = config.maxDist;\n    props.maxDistSq = config.maxDist * config.maxDist;\n  }\n  if ('waitFor' in config) {\n    props.waitFor = asArray(config.waitFor)\n      .map(({ _handlerTag }) => NodeManager.getHandler(_handlerTag))\n      .filter(v => v);\n  } else {\n    props.waitFor = null;\n  }\n\n  [\n    'minPointers',\n    'maxPointers',\n    'minDist',\n    'maxDist',\n    'maxDistSq',\n    'minVelocitySq',\n    'minDistSq',\n    'minVelocity',\n    'failOffsetXStart',\n    'failOffsetYStart',\n    'failOffsetXEnd',\n    'failOffsetYEnd',\n    'activeOffsetXStart',\n    'activeOffsetXEnd',\n    'activeOffsetYStart',\n    'activeOffsetYEnd',\n  ].forEach(prop => {\n    if (typeof props[prop] === 'undefined') {\n      props[prop] = Number.NaN;\n    }\n  });\n  return props;\n}\n\nfunction asArray(value) {\n  return value == null ? [] : Array.isArray(value) ? value : [value];\n}\n\nexport default GestureHandler;\n","import GestureHandler from './GestureHandler';\nimport { PixelRatio } from 'react-native';\n\nclass DraggingGestureHandler extends GestureHandler {\n  get shouldEnableGestureOnSetup() {\n    return true;\n  }\n\n  transformNativeEvent({\n    deltaX,\n    deltaY,\n    velocityX,\n    velocityY,\n    center: { x, y },\n  }) {\n    const rect = this.view.getBoundingClientRect();\n    const ratio = PixelRatio.get();\n    return {\n      translationX: deltaX - (this.__initialX || 0),\n      translationY: deltaY - (this.__initialY || 0),\n      absoluteX: x,\n      absoluteY: y,\n      velocityX: velocityX * ratio,\n      velocityY: velocityY * ratio,\n      x: x - rect.left,\n      y: y - rect.top,\n    };\n  }\n}\n\nexport default DraggingGestureHandler;\n","export const isnan = v => Number.isNaN(v);\n\nexport const isValidNumber = v => typeof v === 'number' && !Number.isNaN(v);\n\nexport const TEST_MIN_IF_NOT_NAN = (value, limit) =>\n  !isnan(limit) &&\n  ((limit < 0 && value <= limit) || (limit >= 0 && value >= limit));\nexport const VEC_LEN_SQ = ({ x = 0, y = 0 } = {}) => x * x + y * y;\nexport const TEST_MAX_IF_NOT_NAN = (value, max) =>\n  !isnan(max) && ((max < 0 && value < max) || (max >= 0 && value > max));\n\nexport function fireAfterInterval(method, interval) {\n  if (!interval) {\n    method();\n    return null;\n  }\n  return setTimeout(() => method(), interval);\n}\n","import Hammer from '@egjs/hammerjs';\n\nimport { Direction } from './constants';\nimport { GesturePropError } from './Errors';\nimport DraggingGestureHandler from './DraggingGestureHandler';\nimport { isnan } from './utils';\n\nclass FlingGestureHandler extends DraggingGestureHandler {\n  get name() {\n    return 'swipe';\n  }\n\n  get NativeGestureClass() {\n    return Hammer.Swipe;\n  }\n\n  onGestureActivated(event) {\n    this.sendEvent({\n      ...event,\n      eventType: Hammer.INPUT_MOVE,\n      isFinal: false,\n      isFirst: true,\n    });\n    this.isGestureRunning = false;\n    this.hasGestureFailed = false;\n    this.sendEvent({\n      ...event,\n      eventType: Hammer.INPUT_END,\n      isFinal: true,\n    });\n  }\n\n  onRawEvent(ev) {\n    super.onRawEvent(ev);\n    if (this.hasGestureFailed) {\n      return;\n    }\n    // Hammer doesn't send a `cancel` event for taps.\n    // Manually fail the event.\n    if (ev.isFinal) {\n      setTimeout(() => {\n        if (this.isGestureRunning) {\n          this.cancelEvent(ev);\n        }\n      });\n    } else if (!this.hasGestureFailed && !this.isGestureRunning) {\n      // Tap Gesture start event\n      const gesture = this.hammer.get(this.name);\n      if (gesture.options.enable(gesture, ev)) {\n        this.onStart(ev);\n        this.sendEvent(ev);\n      }\n    }\n  }\n\n  getHammerConfig() {\n    return {\n      pointers: this.config.numberOfPointers,\n      direction: this.getDirection(),\n    };\n  }\n\n  getTargetDirections(direction) {\n    const directions = [];\n    if (direction & Direction.RIGHT) {\n      directions.push(Hammer.DIRECTION_RIGHT);\n    }\n    if (direction & Direction.LEFT) {\n      directions.push(Hammer.DIRECTION_LEFT);\n    }\n    if (direction & Direction.UP) {\n      directions.push(Hammer.DIRECTION_UP);\n    }\n    if (direction & Direction.DOWN) {\n      directions.push(Hammer.DIRECTION_DOWN);\n    }\n    // const hammerDirection = directions.reduce((a, b) => a | b, 0);\n    return directions;\n  }\n\n  getDirection() {\n    const { direction } = this.getConfig();\n\n    let directions = [];\n    if (direction & Direction.RIGHT) {\n      directions.push(Hammer.DIRECTION_HORIZONTAL);\n    }\n    if (direction & Direction.LEFT) {\n      directions.push(Hammer.DIRECTION_HORIZONTAL);\n    }\n    if (direction & Direction.UP) {\n      directions.push(Hammer.DIRECTION_VERTICAL);\n    }\n    if (direction & Direction.DOWN) {\n      directions.push(Hammer.DIRECTION_VERTICAL);\n    }\n    directions = [...new Set(directions)];\n\n    if (directions.length === 0) return Hammer.DIRECTION_NONE;\n    if (directions.length === 1) return directions[0];\n    return Hammer.DIRECTION_ALL;\n  }\n\n  isGestureEnabledForEvent(\n    {\n      minPointers,\n      maxPointers,\n      numberOfPointers,\n      maxDist,\n      maxDeltaX,\n      maxDeltaY,\n      maxDistSq,\n      shouldCancelWhenOutside,\n    },\n    recognizer,\n    { maxPointers: pointerLength, deltaX: dx, deltaY: dy, ...props }\n  ) {\n    const validPointerCount = pointerLength === numberOfPointers;\n    if (!validPointerCount && this.isGestureRunning) {\n      return { failed: true };\n    }\n    return { success: validPointerCount };\n  }\n\n  updateGestureConfig({ numberOfPointers = 1, direction, ...props }) {\n    if (isnan(direction) || typeof direction !== 'number') {\n      throw new GesturePropError('direction', direction, 'number');\n    }\n    return super.updateGestureConfig({\n      numberOfPointers,\n      direction,\n      ...props,\n    });\n  }\n}\n\nexport default FlingGestureHandler;\n","import GestureHandler from './GestureHandler';\nimport { TEST_MAX_IF_NOT_NAN } from './utils';\n\nclass DiscreteGestureHandler extends GestureHandler {\n  get isDiscrete() {\n    return true;\n  }\n\n  get shouldEnableGestureOnSetup() {\n    return true;\n  }\n\n  shouldFailUnderCustomCriteria(\n    { x, y, deltaX, deltaY },\n    { maxDeltaX, maxDeltaY, maxDistSq, shouldCancelWhenOutside }\n  ) {\n    if (shouldCancelWhenOutside) {\n      if (!this.isPointInView({ x, y })) {\n        return true;\n      }\n    }\n    return (\n      TEST_MAX_IF_NOT_NAN(Math.abs(deltaX), maxDeltaX) ||\n      TEST_MAX_IF_NOT_NAN(Math.abs(deltaY), maxDeltaY) ||\n      TEST_MAX_IF_NOT_NAN(Math.abs(deltaY * deltaY + deltaX * deltaX), maxDistSq)\n    );\n  }\n\n  transformNativeEvent({ center: { x, y } }) {\n    const rect = this.view.getBoundingClientRect();\n\n    return {\n      absoluteX: x,\n      absoluteY: y,\n      x: x - rect.left,\n      y: y - rect.top,\n    };\n  }\n\n  isGestureEnabledForEvent(\n    { minPointers, maxPointers, maxDist, maxDeltaX, maxDeltaY, maxDistSq, shouldCancelWhenOutside },\n    recognizer,\n    { maxPointers: pointerLength, center, deltaX, deltaY, ...props }\n  ) {\n    const validPointerCount = pointerLength >= minPointers && pointerLength <= maxPointers;\n\n    if (\n      this.shouldFailUnderCustomCriteria(\n        { ...center, deltaX, deltaY },\n        {\n          maxDeltaX,\n          maxDeltaY,\n          maxDistSq,\n          shouldCancelWhenOutside,\n        }\n      ) ||\n      // A user probably won't land a multi-pointer tap on the first tick (so we cannot just cancel each time)\n      // but if the gesture is running and the user adds or subtracts another pointer then it should fail.\n      (!validPointerCount && this.isGestureRunning)\n    ) {\n      return { failed: true };\n    }\n\n    return { success: validPointerCount };\n  }\n}\n\nexport default DiscreteGestureHandler;\n","import Hammer from '@egjs/hammerjs';\n\nimport State from '../State';\nimport {\n  CONTENT_TOUCHES_DELAY,\n  CONTENT_TOUCHES_QUICK_TAP_END_DELAY,\n} from './constants';\nimport DiscreteGestureHandler from './DiscreteGestureHandler';\nimport { fireAfterInterval, isValidNumber, isnan } from './utils';\n\nclass PressGestureHandler extends DiscreteGestureHandler {\n  get name() {\n    return 'press';\n  }\n\n  get minDurationMs() {\n    return isnan(this.config.minDurationMs) ? 5 : this.config.minDurationMs;\n  }\n\n  get maxDist() {\n    return isnan(this.config.maxDist) ? 9 : this.config.maxDist;\n  }\n\n  get NativeGestureClass() {\n    return Hammer.Press;\n  }\n\n  shouldDelayTouches = true;\n\n  simulateCancelEvent(inputData) {\n    // Long press never starts so we can't rely on the running event boolean.\n    this.hasGestureFailed = true;\n    this.cancelEvent(inputData);\n  }\n\n  updateHasCustomActivationCriteria({ shouldCancelWhenOutside, maxDistSq }) {\n    return shouldCancelWhenOutside || !isValidNumber(maxDistSq);\n  }\n\n  getState(type) {\n    return {\n      [Hammer.INPUT_START]: State.BEGAN,\n      [Hammer.INPUT_MOVE]: State.ACTIVE,\n      [Hammer.INPUT_END]: State.END,\n      [Hammer.INPUT_CANCEL]: State.CANCELLED,\n    }[type];\n  }\n\n  getConfig() {\n    if (!this._hasCustomActivationCriteria) {\n      // Default config\n      // If no params have been defined then this config should emulate the native gesture as closely as possible.\n      return {\n        shouldCancelWhenOutside: true,\n        maxDistSq: 10,\n      };\n    }\n    return this.config;\n  }\n\n  getHammerConfig() {\n    return {\n      ...super.getHammerConfig(),\n      // threshold: this.maxDist,\n      time: this.minDurationMs,\n    };\n  }\n\n  onGestureActivated(ev) {\n    this.onGestureStart(ev);\n  }\n\n  shouldDelayTouchForEvent({ pointerType }) {\n    // Don't disable event for mouse input\n    return this.shouldDelayTouches && pointerType === 'touch';\n  }\n\n  onGestureStart(ev) {\n    this.isGestureRunning = true;\n    clearTimeout(this.visualFeedbackTimer);\n    this.initialEvent = ev;\n    this.visualFeedbackTimer = fireAfterInterval(() => {\n      this.sendGestureStartedEvent(this.initialEvent);\n      this.initialEvent = null;\n    }, this.shouldDelayTouchForEvent(ev) && CONTENT_TOUCHES_DELAY);\n  }\n\n  sendGestureStartedEvent(ev) {\n    clearTimeout(this.visualFeedbackTimer);\n    this.visualFeedbackTimer = null;\n    this.sendEvent({\n      ...ev,\n      eventType: Hammer.INPUT_MOVE,\n      isFirst: true,\n    });\n  }\n\n  forceInvalidate(event) {\n    super.forceInvalidate(event);\n    clearTimeout(this.visualFeedbackTimer);\n    this.visualFeedbackTimer = null;\n    this.initialEvent = null;\n  }\n\n  onRawEvent(ev) {\n    super.onRawEvent(ev);\n    if (ev.isFinal && this.isGestureRunning) {\n      let timeout;\n      if (this.visualFeedbackTimer) {\n        // Aesthetic timing for a quick tap.\n        // We haven't activated the tap right away to emulate iOS `delaysContentTouches`\n        // Now we must send the initial activation event and wait a set amount of time before firing the end event.\n        timeout = CONTENT_TOUCHES_QUICK_TAP_END_DELAY;\n        this.sendGestureStartedEvent(this.initialEvent);\n        this.initialEvent = null;\n      }\n      fireAfterInterval(() => {\n        this.sendEvent({\n          ...ev,\n          eventType: Hammer.INPUT_END,\n          isFinal: true,\n        });\n        this.onGestureEnded();\n      }, timeout);\n    }\n  }\n\n  updateGestureConfig({\n    shouldActivateOnStart = false,\n    disallowInterruption = false,\n    shouldCancelWhenOutside = true,\n    minDurationMs = Number.NaN,\n    maxDist = Number.NaN,\n    minPointers = 1,\n    maxPointers = 1,\n    ...props\n  }) {\n    return super.updateGestureConfig({\n      shouldActivateOnStart,\n      disallowInterruption,\n      shouldCancelWhenOutside,\n      minDurationMs,\n      maxDist,\n      minPointers,\n      maxPointers,\n      ...props,\n    });\n  }\n}\nexport default PressGestureHandler;\n","import Hammer from '@egjs/hammerjs';\n\nimport State from '../State';\nimport PressGestureHandler from './PressGestureHandler';\nimport { isnan, isValidNumber } from './utils';\n\nclass LongPressGestureHandler extends PressGestureHandler {\n  get minDurationMs() {\n    return isnan(this.config.minDurationMs) ? 251 : this.config.minDurationMs;\n  }\n\n  get maxDist() {\n    return isnan(this.config.maxDist) ? 9 : this.config.maxDist;\n  }\n\n  updateHasCustomActivationCriteria({ maxDistSq }) {\n    return !isValidNumber(maxDistSq);\n  }\n\n  getConfig() {\n    if (!this._hasCustomActivationCriteria) {\n      // Default config\n      // If no params have been defined then this config should emulate the native gesture as closely as possible.\n      return {\n        shouldCancelWhenOutside: true,\n        maxDistSq: 10,\n      };\n    }\n    return this.config;\n  }\n\n  getHammerConfig() {\n    return {\n      ...super.getHammerConfig(),\n      // threshold: this.maxDist,\n      time: this.minDurationMs,\n    };\n  }\n\n  getState(type) {\n    return {\n      [Hammer.INPUT_START]: State.ACTIVE,\n      [Hammer.INPUT_MOVE]: State.ACTIVE,\n      [Hammer.INPUT_END]: State.END,\n      [Hammer.INPUT_CANCEL]: State.FAILED,\n    }[type];\n  }\n}\n\nexport default LongPressGestureHandler;\n","import DiscreteGestureHandler from './DiscreteGestureHandler';\nimport * as NodeManager from './NodeManager';\nimport PressGestureHandler from './PressGestureHandler';\nimport { TEST_MIN_IF_NOT_NAN, VEC_LEN_SQ } from './utils';\n\nclass NativeViewGestureHandler extends PressGestureHandler {\n  onRawEvent(ev) {\n    super.onRawEvent(ev);\n    if (!ev.isFinal) {\n      // if (this.ref instanceof ScrollView) {\n      if (TEST_MIN_IF_NOT_NAN(VEC_LEN_SQ({ x: ev.deltaX, y: ev.deltaY }), 10)) {\n        if (this.config.disallowInterruption) {\n          const gestures = Object.values(NodeManager.getNodes()).filter(gesture => {\n            const { handlerTag, view, isGestureRunning } = gesture;\n            return (\n              // Check if this gesture isn't self\n              handlerTag !== this.handlerTag &&\n              // Ensure the gesture needs to be cancelled\n              isGestureRunning &&\n              // ScrollView can cancel discrete gestures like taps and presses\n              gesture instanceof DiscreteGestureHandler &&\n              // Ensure a view exists and is a child of the current view\n              view &&\n              this.view.contains(view)\n            );\n          });\n          // Cancel all of the gestures that passed the filter\n          for (const gesture of gestures) {\n            // TODO: Bacon: Send some cached event.\n            gesture.forceInvalidate(ev);\n          }\n        }\n      }\n    }\n  }\n}\n\nexport default NativeViewGestureHandler;\n","import Hammer from '@egjs/hammerjs';\n\nimport {\n  MULTI_FINGER_PAN_MAX_PINCH_THRESHOLD,\n  MULTI_FINGER_PAN_MAX_ROTATION_THRESHOLD,\n} from './constants';\nimport DraggingGestureHandler from './DraggingGestureHandler';\nimport { isValidNumber, isnan, TEST_MIN_IF_NOT_NAN, VEC_LEN_SQ } from './utils';\nimport State from '../State';\n\nclass PanGestureHandler extends DraggingGestureHandler {\n  get name() {\n    return 'pan';\n  }\n\n  get NativeGestureClass() {\n    return Hammer.Pan;\n  }\n\n  getHammerConfig() {\n    return {\n      ...super.getHammerConfig(),\n      direction: this.getDirection(),\n    };\n  }\n\n  getState(type) {\n    const nextState = super.getState(type);\n    // Ensure that the first state sent is `BEGAN` and not `ACTIVE`\n    if (\n      this.previousState === State.UNDETERMINED &&\n      nextState === State.ACTIVE\n    ) {\n      return State.BEGAN;\n    }\n    return nextState;\n  }\n\n  getDirection() {\n    const config = this.getConfig();\n    const {\n      activeOffsetXStart,\n      activeOffsetXEnd,\n      activeOffsetYStart,\n      activeOffsetYEnd,\n      minDist,\n    } = config;\n    let directions = [];\n    let horizontalDirections = [];\n\n    if (!isnan(minDist)) {\n      return Hammer.DIRECTION_ALL;\n    }\n\n    if (!isnan(activeOffsetXStart))\n      horizontalDirections.push(Hammer.DIRECTION_LEFT);\n    if (!isnan(activeOffsetXEnd))\n      horizontalDirections.push(Hammer.DIRECTION_RIGHT);\n    if (horizontalDirections.length === 2)\n      horizontalDirections = [Hammer.DIRECTION_HORIZONTAL];\n\n    directions = directions.concat(horizontalDirections);\n    let verticalDirections = [];\n\n    if (!isnan(activeOffsetYStart))\n      verticalDirections.push(Hammer.DIRECTION_UP);\n    if (!isnan(activeOffsetYEnd))\n      verticalDirections.push(Hammer.DIRECTION_DOWN);\n\n    if (verticalDirections.length === 2)\n      verticalDirections = [Hammer.DIRECTION_VERTICAL];\n\n    directions = directions.concat(verticalDirections);\n\n    if (!directions.length) {\n      return Hammer.DIRECTION_NONE;\n    }\n    if (\n      directions[0] === Hammer.DIRECTION_HORIZONTAL &&\n      directions[1] === Hammer.DIRECTION_VERTICAL\n    ) {\n      return Hammer.DIRECTION_ALL;\n    }\n    if (horizontalDirections.length && verticalDirections.length) {\n      return Hammer.DIRECTION_ALL;\n    }\n\n    return directions[0];\n  }\n\n  getConfig() {\n    if (!this._hasCustomActivationCriteria) {\n      // Default config\n      // If no params have been defined then this config should emulate the native gesture as closely as possible.\n      return {\n        minDistSq: 10,\n      };\n    }\n    return this.config;\n  }\n\n  shouldFailUnderCustomCriteria({ deltaX, deltaY }, criteria) {\n    return (\n      (!isnan(criteria.failOffsetXStart) &&\n        deltaX < criteria.failOffsetXStart) ||\n      (!isnan(criteria.failOffsetXEnd) && deltaX > criteria.failOffsetXEnd) ||\n      (!isnan(criteria.failOffsetYStart) &&\n        deltaY < criteria.failOffsetYStart) ||\n      (!isnan(criteria.failOffsetYEnd) && deltaY > criteria.failOffsetYEnd)\n    );\n  }\n\n  shouldActivateUnderCustomCriteria({ deltaX, deltaY, velocity }, criteria) {\n    return (\n      (!isnan(criteria.activeOffsetXStart) &&\n        deltaX < criteria.activeOffsetXStart) ||\n      (!isnan(criteria.activeOffsetXEnd) &&\n        deltaX > criteria.activeOffsetXEnd) ||\n      (!isnan(criteria.activeOffsetYStart) &&\n        deltaY < criteria.activeOffsetYStart) ||\n      (!isnan(criteria.activeOffsetYEnd) &&\n        deltaY > criteria.activeOffsetYEnd) ||\n      TEST_MIN_IF_NOT_NAN(\n        VEC_LEN_SQ({ x: deltaX, y: deltaY }),\n        criteria.minDistSq\n      ) ||\n      TEST_MIN_IF_NOT_NAN(velocity.x, criteria.minVelocityX) ||\n      TEST_MIN_IF_NOT_NAN(velocity.y, criteria.minVelocityY) ||\n      TEST_MIN_IF_NOT_NAN(VEC_LEN_SQ(velocity), criteria.minVelocitySq)\n    );\n  }\n\n  shouldMultiFingerPanFail({ pointerLength, scale, deltaRotation }) {\n    if (pointerLength <= 1) {\n      return false;\n    }\n\n    // Test if the pan had too much pinching or rotating.\n    const deltaScale = Math.abs(scale - 1);\n    const absDeltaRotation = Math.abs(deltaRotation);\n    if (deltaScale > MULTI_FINGER_PAN_MAX_PINCH_THRESHOLD) {\n      // > If the threshold doesn't seem right.\n      // You can log the value which it failed at here:\n      return true;\n    }\n    if (absDeltaRotation > MULTI_FINGER_PAN_MAX_ROTATION_THRESHOLD) {\n      // > If the threshold doesn't seem right.\n      // You can log the value which it failed at here:\n      return true;\n    }\n\n    return false;\n  }\n\n  updateHasCustomActivationCriteria(criteria) {\n    return (\n      isValidNumber(criteria.minDistSq) ||\n      isValidNumber(criteria.minVelocityX) ||\n      isValidNumber(criteria.minVelocityY) ||\n      isValidNumber(criteria.minVelocitySq) ||\n      isValidNumber(criteria.activeOffsetXStart) ||\n      isValidNumber(criteria.activeOffsetXEnd) ||\n      isValidNumber(criteria.activeOffsetYStart) ||\n      isValidNumber(criteria.activeOffsetYEnd)\n    );\n  }\n\n  isGestureEnabledForEvent(props, recognizer, inputData) {\n    if (this.shouldFailUnderCustomCriteria(inputData, props)) {\n      return { failed: true };\n    }\n\n    const velocity = { x: inputData.velocityX, y: inputData.velocityY };\n    if (\n      this._hasCustomActivationCriteria &&\n      this.shouldActivateUnderCustomCriteria(\n        { deltaX: inputData.deltaX, deltaY: inputData.deltaY, velocity },\n        props\n      )\n    ) {\n      if (\n        this.shouldMultiFingerPanFail({\n          pointerLength: inputData.maxPointers,\n          scale: inputData.scale,\n          deltaRotation: inputData.deltaRotation,\n        })\n      ) {\n        return {\n          failed: true,\n        };\n      }\n      return { success: true };\n    }\n    return { success: false };\n  }\n}\n\nfunction validateConfig(config = {}) {\n  const isNum = v => isnan(v) || typeof v === 'number';\n  const isBool = v => typeof v === 'boolean';\n\n  const valid = {\n    enabled: isBool,\n    minDistSq: isNum,\n    minVelocityX: isNum,\n    minVelocityY: isNum,\n    // TODO: Bacon: remove `minVelocity`\n    minVelocity: isNum,\n    minVelocitySq: isNum,\n    activeOffsetXStart: isNum,\n    activeOffsetXEnd: isNum,\n    failOffsetXStart: isNum,\n    failOffsetXEnd: isNum,\n    activeOffsetYStart: isNum,\n    activeOffsetYEnd: isNum,\n    failOffsetYStart: isNum,\n    failOffsetYEnd: isNum,\n    hasCustomActivationCriteria: isBool,\n    minPointers: isNum,\n    maxPointers: isNum,\n  };\n  const keys = Object.keys(valid);\n\n  let invalidKeys = [];\n  for (const key of Object.keys(config)) {\n    if (keys.includes(key)) {\n      if (valid[key](config[key])) {\n        console.warn('Invalid type: ' + key + ': ' + config[key]);\n      }\n    } else {\n      invalidKeys.push(key);\n    }\n  }\n\n  if (invalidKeys.length) {\n    throw new Error('Invalid config props found: ' + invalidKeys.join(', '));\n  }\n  return config;\n}\n\nexport default PanGestureHandler;\n","import GestureHandler from './GestureHandler';\n\n/**\n * The base class for **Rotation** and **Pinch** gesture handlers.\n */\nclass IndiscreteGestureHandler extends GestureHandler {\n  get shouldEnableGestureOnSetup() {\n    return false;\n  }\n\n  updateGestureConfig({ minPointers = 2, maxPointers = 2, ...props }) {\n    return super.updateGestureConfig({\n      minPointers,\n      maxPointers,\n      ...props,\n    });\n  }\n\n  isGestureEnabledForEvent(\n    { minPointers, maxPointers },\n    recognizer,\n    { maxPointers: pointerLength }\n  ) {\n    if (pointerLength > maxPointers) {\n      return { failed: true };\n    }\n    const validPointerCount = pointerLength >= minPointers;\n    return {\n      success: validPointerCount,\n    };\n  }\n}\nexport default IndiscreteGestureHandler;\n","import Hammer from '@egjs/hammerjs';\n\nimport IndiscreteGestureHandler from './IndiscreteGestureHandler';\n\nclass PinchGestureHandler extends IndiscreteGestureHandler {\n  get name() {\n    return 'pinch';\n  }\n\n  get NativeGestureClass() {\n    return Hammer.Pinch;\n  }\n\n  transformNativeEvent({ scale, velocity, center }) {\n    return {\n      focalX: center.x,\n      focalY: center.y,\n      velocity,\n      scale,\n    };\n  }\n}\n\nexport default PinchGestureHandler;\n","import { Direction } from './web/constants';\nimport FlingGestureHandler from './web/FlingGestureHandler';\nimport LongPressGestureHandler from './web/LongPressGestureHandler';\nimport NativeViewGestureHandler from './web/NativeViewGestureHandler';\nimport * as NodeManager from './web/NodeManager';\nimport PanGestureHandler from './web/PanGestureHandler';\nimport PinchGestureHandler from './web/PinchGestureHandler';\nimport RotationGestureHandler from './web/RotationGestureHandler';\nimport TapGestureHandler from './web/TapGestureHandler';\n\nconst Gestures = {\n  PanGestureHandler,\n  RotationGestureHandler,\n  PinchGestureHandler,\n  TapGestureHandler,\n  NativeViewGestureHandler,\n  LongPressGestureHandler,\n  FlingGestureHandler,\n  // ForceTouchGestureHandler,\n};\n\nexport default {\n  Direction,\n  handleSetJSResponder(tag, blockNativeResponder) {\n    console.warn('handleSetJSResponder: ', tag, blockNativeResponder);\n  },\n  handleClearJSResponder() {\n    console.warn('handleClearJSResponder: ');\n  },\n  createGestureHandler(handlerName, handlerTag, config) {\n    if (!(handlerName in Gestures))\n      throw new Error(`react-native-gesture-handler: ${handlerName} is not supported on web.`);\n    const GestureClass = Gestures[handlerName];\n    NodeManager.createGestureHandler(handlerTag, new GestureClass());\n    this.updateGestureHandler(handlerTag, config);\n  },\n  attachGestureHandler(handlerTag, newView) {\n    NodeManager.getHandler(handlerTag).setView(newView);\n  },\n  updateGestureHandler(handlerTag, newConfig) {\n    NodeManager.getHandler(handlerTag).updateGestureConfig(newConfig);\n  },\n  getGestureHandlerNode(handlerTag) {\n    return NodeManager.getHandler(handlerTag);\n  },\n  dropGestureHandler(handlerTag) {\n    NodeManager.dropGestureHandler(handlerTag);\n  },\n};\n","import Hammer from '@egjs/hammerjs';\n\nimport { DEG_RAD } from './constants';\nimport IndiscreteGestureHandler from './IndiscreteGestureHandler';\n\nclass RotationGestureHandler extends IndiscreteGestureHandler {\n  get name() {\n    return 'rotate';\n  }\n\n  get NativeGestureClass() {\n    return Hammer.Rotate;\n  }\n\n  transformNativeEvent({ rotation, velocity, center }) {\n    return {\n      rotation: (rotation - this.initialRotation) * DEG_RAD,\n      anchorX: center.x,\n      anchorY: center.y,\n      velocity,\n    };\n  }\n}\nexport default RotationGestureHandler;\n","import Hammer from '@egjs/hammerjs';\n\nimport DiscreteGestureHandler from './DiscreteGestureHandler';\nimport { isnan } from './utils';\n\nclass TapGestureHandler extends DiscreteGestureHandler {\n  get name() {\n    return 'tap';\n  }\n\n  get NativeGestureClass() {\n    return Hammer.Tap;\n  }\n\n  get maxDelayMs() {\n    return isnan(this.config.maxDelayMs) ? 300 : this.config.maxDelayMs;\n  }\n\n  simulateCancelEvent(inputData) {\n    if (this.isGestureRunning) {\n      this.cancelEvent(inputData);\n    }\n  }\n\n  onGestureActivated(ev) {\n    if (this.isGestureRunning) {\n      this.onSuccessfulTap(ev);\n    }\n  }\n\n  onSuccessfulTap = ev => {\n    if (this._getPendingGestures().length) {\n      this._shouldFireEndEvent = ev;\n      return;\n    }\n    if (ev.eventType === Hammer.INPUT_END) {\n      this.sendEvent({ ...ev, eventType: Hammer.INPUT_MOVE });\n    }\n    // When handler gets activated it will turn into State.END immediately.\n    this.sendEvent({ ...ev, isFinal: true });\n    this.onGestureEnded(ev);\n  };\n\n  onRawEvent(ev) {\n    super.onRawEvent(ev);\n\n    // Attempt to create a touch-down event by checking if a valid tap hasn't started yet, then validating the input.\n    if (\n      !this.hasGestureFailed &&\n      !this.isGestureRunning &&\n      // Prevent multi-pointer events from misfiring.\n      !ev.isFinal\n    ) {\n      // Tap Gesture start event\n      const gesture = this.hammer.get(this.name);\n      if (gesture.options.enable(gesture, ev)) {\n        clearTimeout(this._multiTapTimer);\n\n        this.onStart(ev);\n        this.sendEvent(ev);\n      }\n    }\n    if (ev.isFinal && ev.maxPointers > 1) {\n      setTimeout(() => {\n        // Handle case where one finger presses slightly\n        // after the first finger on a multi-tap event\n        if (this.isGestureRunning) {\n          this.cancelEvent(ev);\n        }\n      });\n    }\n\n    if (this.hasGestureFailed) {\n      return;\n    }\n    // Hammer doesn't send a `cancel` event for taps.\n    // Manually fail the event.\n    if (ev.isFinal) {\n      // Handle case where one finger presses slightly\n      // after the first finger on a multi-tap event\n      if (ev.maxPointers > 1) {\n        setTimeout(() => {\n          if (this.isGestureRunning) {\n            this.cancelEvent(ev);\n          }\n        });\n      }\n\n      // Clear last timer\n      clearTimeout(this._timer);\n      // Create time out for multi-taps.\n      this._timer = setTimeout(() => {\n        this.hasGestureFailed = true;\n        this.cancelEvent(ev);\n      }, this.maxDelayMs);\n    } else if (!this.hasGestureFailed && !this.isGestureRunning) {\n      // Tap Gesture start event\n      const gesture = this.hammer.get(this.name);\n      if (gesture.options.enable(gesture, ev)) {\n        clearTimeout(this._multiTapTimer);\n\n        this.onStart(ev);\n        this.sendEvent(ev);\n      }\n    }\n  }\n\n  getHammerConfig() {\n    return {\n      ...super.getHammerConfig(),\n      event: this.name,\n      taps: isnan(this.config.numberOfTaps) ? 1 : this.config.numberOfTaps,\n      interval: this.maxDelayMs,\n      time:\n        isnan(this.config.maxDurationMs) || this.config.maxDurationMs == null\n          ? 250\n          : this.config.maxDurationMs,\n    };\n  }\n\n  updateGestureConfig({\n    shouldCancelWhenOutside = true,\n    maxDeltaX = Number.NaN,\n    maxDeltaY = Number.NaN,\n    numberOfTaps = 1,\n    minDurationMs = 525,\n    maxDelayMs = Number.NaN,\n    maxDurationMs = Number.NaN,\n    maxDist = 2,\n    minPointers = 1,\n    maxPointers = 1,\n    ...props\n  }) {\n    return super.updateGestureConfig({\n      shouldCancelWhenOutside,\n      numberOfTaps,\n      maxDeltaX,\n      maxDeltaY,\n      minDurationMs,\n      maxDelayMs,\n      maxDist,\n      minPointers,\n      maxPointers,\n      ...props,\n    });\n  }\n\n  onGestureEnded(...props) {\n    clearTimeout(this._timer);\n    super.onGestureEnded(...props);\n  }\n\n  onWaitingEnded(gesture) {\n    if (this._shouldFireEndEvent) {\n      this.onSuccessfulTap(this._shouldFireEndEvent);\n      this._shouldFireEndEvent = null;\n    }\n  }\n}\nexport default TapGestureHandler;\n","(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== \"function\") {\n        callback = new Function(\"\" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === \"string\" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 68\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n","\"use strict\";\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nvar aStackPool = [];\nvar bStackPool = [];\n/**\n * Checks if two values are equal. Values may be primitives, arrays, or objects.\n * Returns true if both arguments have the same keys and values.\n *\n * @see http://underscorejs.org\n * @copyright 2009-2013 Jeremy Ashkenas, DocumentCloud Inc.\n * @license MIT\n */\n\nfunction areEqual(a, b) {\n  var aStack = aStackPool.length ? aStackPool.pop() : [];\n  var bStack = bStackPool.length ? bStackPool.pop() : [];\n  var result = eq(a, b, aStack, bStack);\n  aStack.length = 0;\n  bStack.length = 0;\n  aStackPool.push(aStack);\n  bStackPool.push(bStack);\n  return result;\n}\n\nfunction eq(a, b, aStack, bStack) {\n  if (a === b) {\n    // Identical objects are equal. `0 === -0`, but they aren't identical.\n    return a !== 0 || 1 / a == 1 / b;\n  }\n\n  if (a == null || b == null) {\n    // a or b can be `null` or `undefined`\n    return false;\n  }\n\n  if (typeof a != 'object' || typeof b != 'object') {\n    return false;\n  }\n\n  var objToStr = Object.prototype.toString;\n  var className = objToStr.call(a);\n\n  if (className != objToStr.call(b)) {\n    return false;\n  }\n\n  switch (className) {\n    case '[object String]':\n      return a == String(b);\n\n    case '[object Number]':\n      return isNaN(a) || isNaN(b) ? false : a == Number(b);\n\n    case '[object Date]':\n    case '[object Boolean]':\n      return +a == +b;\n\n    case '[object RegExp]':\n      return a.source == b.source && a.global == b.global && a.multiline == b.multiline && a.ignoreCase == b.ignoreCase;\n  } // Assume equality for cyclic structures.\n\n\n  var length = aStack.length;\n\n  while (length--) {\n    if (aStack[length] == a) {\n      return bStack[length] == b;\n    }\n  }\n\n  aStack.push(a);\n  bStack.push(b);\n  var size = 0; // Recursively compare objects and arrays.\n\n  if (className === '[object Array]') {\n    size = a.length;\n\n    if (size !== b.length) {\n      return false;\n    } // Deep compare the contents, ignoring non-numeric properties.\n\n\n    while (size--) {\n      if (!eq(a[size], b[size], aStack, bStack)) {\n        return false;\n      }\n    }\n  } else {\n    if (a.constructor !== b.constructor) {\n      return false;\n    }\n\n    if (a.hasOwnProperty('valueOf') && b.hasOwnProperty('valueOf')) {\n      return a.valueOf() == b.valueOf();\n    }\n\n    var keys = Object.keys(a);\n\n    if (keys.length != Object.keys(b).length) {\n      return false;\n    }\n\n    for (var i = 0; i < keys.length; i++) {\n      if (!eq(a[keys[i]], b[keys[i]], aStack, bStack)) {\n        return false;\n      }\n    }\n  }\n\n  aStack.pop();\n  bStack.pop();\n  return true;\n}\n\nmodule.exports = areEqual;","var getPrototypeOf = require(\"./getPrototypeOf.js\");\n\nfunction _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = getPrototypeOf(object);\n    if (object === null) break;\n  }\n\n  return object;\n}\n\nmodule.exports = _superPropBase;\nmodule.exports[\"default\"] = module.exports, module.exports.__esModule = true;"],"sourceRoot":""}